proceedings
the
2018
winter
simulation
conference
m.
rabe,
a.
a.
juan,
n.
mustafee,
a.
skoogh,
s.
jain,
b.
johansson,
eds.
introduction
statecharts
modeling,
simulation,
testing,
and
deployment
simon
van
mierlo
hans
vangheluwe
department
mathematics
computer
science
university
antwerp
-
flanders
make
vzw
middelheimlaan
1
antwerp,
belgium
abstract
statecharts,
introduced
david
harel
1987,
a
formalism
used
specify
the
behaviour
timed,
autonomous,
reactive
system
using
a
discrete-event
abstraction.
timed
finite
state
automata
depth,
orthogonality,
broadcast
communication,
history.
visual
representation
based
higraphs,
combine
graph
venn
diagrams.
many
tool
offer
visual
editing,
simulation,
code
synthesis
support
the
statechart
formalism.
example
include
statemate,
rhapsody,
yakindu,
stateflow,
each
implementing
different
variant
harel’s
original
semantics.
this
tutorial
modeling,
simulation,
testing
statecharts.
a
running
example,
the
behaviour
a
traffic
a
simple
timed,
autonomous,
reactive
system
modeled.
start
the
basic
concept
state
transition
explain
the
advanced
concept
statecharts
extending
the
example
incrementally.
discuss
several
semantic
variants,
such
statemate
rhapsody.
use
yakindu
model
the
example
system.
1
introduction
the
system
analyze,
design,
build
today
characterized
an
ever-increasing
complexity.
this
complexity
a
variety
sources,
such
the
complex
interplay
physical
component
(sensors
actuators)
software,
the
large
amount
datum
these
system
process,
etc.
almost
always,
however,
complex
system
exhibit
event-processing
behaviour:
the
system
stimulus
coming
the
environment
(in
the
form
input
events)
changing
internal
state
influence
the
environment
output
events.
such
event-processing
system
fundamentally
different
more
traditional
software
systems,
transformational
(i.e.,
receive
a
number
input
parameters,
perform
computations,
return
the
result
output).
reactive
system
run
continuously,
often
multiple
concurrently
executing
components,
reactive
respect
the
environment.
an
example
a
modern
car,
system
increasingly
controlled
software.
multiple
concurrently
running
software
component
interpreting
signal
coming
the
environment
(the
driver’s
as
well
sensor
interpreting
current
driving
conditions)
making
(autonomous)
decision
generate
signal
the
car’s
actuators.
such
complex
event
processing
behaviour
specified
an
appropriate
language,
order
validate
the
behaviour
respect
specification
(using
verification
validation
techniques,
such
formal
verification,
model
checking,
as
well
testing
techniques),
ultimately
deploy
the
software
the
system’s
hardware
components.
traditional
programming
language
designed
transformational
system
mind,
not
well-suited
describing
timed,
autonomous,
reactive,
concurrent
behaviour.
fact,
describing
complex
system
using
thread
quickly
result
unreadable,
incomprehensible,
unverifiable
program
code
(lee
2006).
this
partly
due
the
978-1-5386-6572-5/18/$31.00
©2018
ieee
306

van
mierlo
vangheluwe
cognitive
gap
the
abstraction
offered
the
language
the
complexity
the
specification,
as
well
the
sometimes
ill-defined
semantics
programming
languages,
understandability.
an
alternative,
this
tutorial
the
statechart
formalism,
introduced
david
harel
(1987).
talk
a
formalism
this
paper,
mean
a
language
offering
abstraction
semantics
well-defined,
meaning
analysis
the
model
possible
resort
compiling
executing
observe
behaviour.
an
instance
a
formalism
a
model,
written
the
syntax
the
formalism,
executed
appropriate
interpreters,
compiled,
analyzed,
.
.
.
the
syntax
semantics
statecharts
well-defined
natively
describe
a
system’s
timed,
autonomous,
reactive
behaviour.
basic
building
block
state
transition
those
states.
states
combined
hierarchically
composite
states,
orthogonally
concurrent
regions.
many
(visual)
modeling
tool
exist
that
support
the
complete
life-cycle
modeling
a
system’s
behaviour
using
statecharts:
design
verification
validation,
ultimately
deployment
(code
generation).
the
sections,
introduce
the
construct
the
statechart
formalism
incrementally
building
the
model
the
behaviour
an
example
system.
explain
the
syntax
as
well
the
semantics
each
construct.
the
example
modeled
the
yakindu
(https://www.itemis.com/en/yakindu/
state-machine/)
tool,
the
technique
transferred
any
statecharts
modeling
simulation
tool
comparable
functionality.
section
2
a
system’s
behaviour
observed
described
using
a
discrete-event
abstraction.
section
3
the
running
example
the
tutorial:
a
traffic
light
autonomously
light
according
a
fixed
schedule,
interrupted
a
policeman
the
traffic
controlled
manually.
section
4
the
basic
building
block
a
statechart
model:
state
transitions.
section
5
state
combined
composite
state
orthogonal
regions,
as
well
history
state
a
number
construct
the
statechart
formalism
make
the
modeler’s
life
easier,
considered
“syntactic
sugar”.
section
7
code
generated
a
statechart
model,
integrated
a
visualization
framework
deploy
the
(simulated)
system.
section
8
the
tutorial.
2
discrete-event
abstraction
certain
system
behaviour,
particular
the
behaviour
control
software,
described
using
a
discreteevent
abstraction.
figure
1
a
view
the
behaviour
an
example
system
shown
–
this
case,
the
system
a
“tank
wars”
game,
a
tank
a
virtual
map
reacting
a
player’s
input
the
keyboard.
the
tank
shoot
the
player’s
command,
run
fuel,
point
a
mode
only
drive
a
fueling
station
(and
no
able
shoot).
as
clear
this
intuitive
description,
the
system
input
the
environment,
output
the
environment.
such
input/output
signal
described
events.
the
top
figure
1,
an
input
event
segment
shown.
a
segment
a
finite
interval
time,
a
number
event
occur.
a
finite
interval,
only
a
finite
number
such
event
occur
(which
discrete-event
system
continuous
systems,
input
output
behaviour
infinitely
zoom
into,
continuous
functions).
the
system
the
input
event
segment
producing
an
output
event
segment,
shown
the
bottom
figure
1.
the
environment
(entities
interacting
the
system)
view
the
system
a
black-box
an
interface
(defined
the
input
event
accepts,
as
well
the
output
event
this
case,
the
player
the
system
sending
input
event
corresponding
key
strokes:
the
player
the
tank
pressing
the
up,
down,
enter
key.
a
result,
the
system
output,
the
reaction
the
system
the
input
this
case,
four
output
event
produced:
move
up,
move
down,
shoot,
signify
the
tank
moving
up,
start
moving
down,
shoots,
respectively,
low
fuel,
the
tank
low
fuel.
the
system
an
internal
state,
time
a
result
input
received,
well
as
autonomously
the
system.
a
possible
system
state
trajectory
the
example
system
shown
the
307

van
mierlo
vangheluwe
input
event
segment
key_up
key_down
key_enter
system
state
trajectory
time
moving
w
key_up
/
raise
move_up
shooting
key_down
/
raise
move_down
key_up
/
raise
move_up
moving
u
low_fuel
d
key_down
/
raise
move_down
time
output
event
segment
after(3s)
key_enter
/
raise
shoot
shooting
move_up
[fuel_ok()]
[low_fuel_detected()]
/
raise
low_fuel
low_fuel
[low_fuel_detected()]
/
raise
low_fuel
move_down
shoot
low_fuel
time
figure
1:
discrete-event
abstraction
the
example
“tank
wars”
game.
figure
2:
a
possible
behavioural
model
the
example
“tank
wars”
game.
middle
figure
1.
three
state
defined:
shooting,
moving,
low
fuel.
the
first
two
input
event
do
not
cause
the
state
the
system
change,
cause
two
corresponding
output
event
raised
the
system.
the
third
input
event
the
system
state
moving
shooting.
and,
some
point
that,
the
system
autonomously
state
low
fuel.
the
input,
output,
state
trace,
deduce
the
system
timed,
reactive,
autonomous.
describe
all
possible
state
trajectory
the
system,
a
state
diagram
used
–
see
figure
2
a
possible
model
describing
the
system’s
behaviour.
the
different
state
mode
the
system
in:
the
highest
level,
three
state
(moving,
shooting,
low
fuel)
defined
(represented
rounded
rectangles).
the
moving
state
three
substates,
corresponding
the
direction
the
tank
traveling
in.
the
state
the
system
change
a
transition
(represented
an
arrow)
triggers.
a
transition
due
an
(optional)
event
timeout,
an
optional
condition
the
total
state
the
system
(including
the
value
the
system’s
variables).
a
transition
triggered,
an
action
executed,
change
the
value
the
system’s
variables,
raise
an
event.
this
a
high-level
description
discrete-event
abstraction
describe
a
system’s
behaviour,
including
a
possible
diagrammatic
notation.
the
rest
this
paper,
the
statechart
formalism
explained
an
example
a
diagrammatic
language
describe
the
timed,
reactive,
autonomous
behaviour
systems.
308

van
mierlo
vangheluwe
:gatherreqs
m:statecharts
gatherreqs
:modelsystem
:revisesystem
text.
req.
definetestcases
:text.
req.
verify
system
revisesystem
modelsystem
statecharts
:defineinput
it:
tracelang
simulate
tc:
statecharts
defineinput
:simulate
tracelang
test
generate
code
checkoutput
java
boolean
st:
tracelang
:test
tt:
tracelang
:checkoutput
[false]
:boolean
[false]
language
model
artefact
manual
transformation
manual
activity
automatic
transformation
automatic
activity
:boolean
[true]
[true]
:generatecode
:java
figure
3:
the
workflow
modeling,
simulating,
testing,
ultimately
generating
code
statechart
models.
3
running
example
a
running
example,
develop
a
statechart
model
describing
the
timed,
autonomous,
reactive
behaviour
a
traffic
light.
a
system
developed,
however,
important
consider
the
artefact
created
development
describe
the
process
system
development.
this
process,
workflow,
guide
the
tutorial
design,
simulate,
test,
ultimately
deploy
example
system.
figure
3
show
a
model
this
process,
a
formalism
transformation
graph
process
modeling
(ftg+pm)
language
(lúcio
et
al.
2013).
the
right
a
process
model
(pm)
the
different
phase
developing
the
system.
the
process
several
activities,
manual
automatic.
manual
activity
require
user
input:
example,
creating
a
model
a
user
opening
a
model
editor
the
user
the
model
the
model
editor.
automatic
activity
program
transformational,
the
sense
seen
black
box
take
input
produce
output.
all
activity
produce
artefacts,
receive
artefact
input.
fork
join
node
split
the
workflow
parallel
branches,
multiple
activity
active
the
same
time.
decision
node
decide,
depending
a
boolean
value,
the
process
proceeds.
the
left
side,
a
formalism
transformation
graph
(ftg)
a
map
the
language
used
system
development.
each
artefact
produced
the
process
model
a
language
the
formalism
transformation
graph.
moreover,
the
transformation
the
languages,
either
manual
automatic.
again,
there
a
correspondence
activity
the
process
model
309

van
mierlo
vangheluwe
e
ai
/r
after(60)
/
raise
out::displaygreen
editor
yr
pla
dis
t::
ou
red
after(55)
/
raise
out::displayyellow
green
yellow
after(5)
/
raise
out::displayred
figure
4:
the
basic
model
the
traffic
light’s
behaviour.
transformation
the
formalism
transformation
graph:
the
transformation
act
an
“interface”
defining
the
input
output
artefacts,
the
activity
the
workflow
need
conform.
workflow,
start
defining
the
requirement
the
example
system
developing
an
initial
model
the
system.
this
model
subsequently
(and
parallel)
simulated
tested.
a
simulation
an
output
trace
a
given
input
trace
(see
the
previous
section
a
discussion
discrete-event
abstraction).
this
output
trace
manually
checked
a
decision
made
not
the
requirement
satisfied.
the
other
parallel
branch
the
workflow,
a
test
case
defined
a
generator
(which
input
events)
an
acceptor,
the
generated
output
trace
correct.
a
test
fully
automatically,
again
a
decision
made
the
requirement
satisfied
the
design
the
system.
not
the
case,
the
model
the
system
revised
all
requirement
satisfied.
all
requirement
satisfied,
the
system
deployed
generating
appropriate
application
code.
case,
the
system
deployed
generating
java
code.
complete
the
first
step
the
workflow,
the
requirement
the
traffic
light
listed
below:
1.
2.
3.
4.
5.
6.
three
differently
colored
lights:
red,
green,
yellow.
most
one
light
any
point
time.
system
start-up,
the
red
light
on.
the
traffic
light
cycle
red
on,
green
on,
yellow
on.
the
red
light
60s,
the
green
light
55s,
the
yellow
light
5s.
the
police
interrupt
the
traffic
light’s
autonomous
operation.
this
result
a
blinking
yellow
light
(on
1
second,
off
1
second
repeatedly).
7.
the
police
resume
an
interrupted
traffic
light.
the
result
the
light
time
interrupt
turned
again.
8.
a
timer
the
remaining
time
the
light
red
green;
this
timer
value
every
second.
the
color
the
timer
the
color
the
traffic
light.
the
next
sections,
the
model
the
system
incrementally
developed,
the
syntax
the
semantics
the
different
element
the
statechart
formalism.
4
basic
building
the
basic
building
block
any
statechart
model
state
transition
those
states.
essential
concept
need
explained
moving
more
advanced
statechart
elements.
these
basic
building
block
a
theoretical
underpinning
finite
state
automata
(hopcroft
et
al.
2006).
illustrate
the
use
state
transitions,
a
basic
model
a
traffic
light
(implementing
the
first
five
requirement
listed
the
previous
section)
presented
figure
4.
4.1
states
states
model
the
mode
a
system
in.
the
absence
concurrent
regions,
exactly
one
state
active
any
point
time
the
system’s
execution.
a
state
a
name,
uniquely
identifying
it.
exactly
one
state
the
initial
state
–
system
start-up,
the
state
the
system
initialized
that
initial
state.
the
visual
310

van
mierlo
vangheluwe
representation
a
state
a
rounded
rectangle,
roundtangle.
visualize
the
initial
state,
a
small
black
circle
drawn,
an
arrow
pointing
the
initial
state.
figure
4,
three
state
the
traffic
light
modeled,
corresponding
the
possible
color
the
traffic
light:
red,
green,
yellow.
states
no
semantics;
no
link
the
actual
color
the
physical
traffic
light
made
yet.
however,
aptly
naming
state
important,
and,
therefore,
mentally
make
the
connection
the
system
the
red
state,
the
red
light
on,
the
other
off.
the
state
–
mode
–
the
system
in,
a
system
track
a
number
state
variable
{v1
,
v2
,
.
.
.
,
vi
}.
the
datum
type
possible
assignment
these
variable
depend
the
datum
model
supported
the
specific
variant
the
statechart
formalism.
case
yakindu,
the
implementationlanguage-independent
type
integer,
real,
boolean,
string,
void
defined
(https://www.itemis.com/
en/yakindu/state-machine/documentation/user-guide/sclang
statechart
language
reference#sclang
types).
4.2
transition
state
describe
the
current
configuration
the
system
in,
transition
model
the
dynamics
the
system
describe
this
configuration
time.
a
transition
exactly
two
states:
the
source
state
the
target
state.
the
system
running,
a
transition
trigger
triggering
condition
satisfied.
the
transition
the
current
state
the
system
changed
the
source
state
the
target
state.
the
same
time,
the
transition’s
action
executed.
general,
the
signature
a
transition
written
follows:
<
trigger
−
event
>
[<
trigger
−
condition
>]
/
<
action
>.
the
triggering
condition
a
transition
the
following
elements:
•
•
a
triggering
event
(optional),
identified
a
name
a
list
parameters.
general,
an
event
the
following
signature:
<
event
−
name
>
(<
event
−
params
>).
the
event
an
input
event
(coming
the
environment),
case
the
event
name
preceded
::.
or,
internal
the
statechart
model,
case
no
prefix.
the
triggering
event
also
a
timeout,
identified
the
reserved
event
name
a
parameter
denoting
the
amount
second
pass
the
timeout
triggers.
a
triggering
condition
(optional),
a
boolean
condition
the
state
the
system.
example,
check
the
value
system
variables.
a
transition
no
triggering
condition
said
spontaneous.
the
transition
leaving
the
marker
the
initial
state
always
spontaneous.
the
transition’s
action
can:
•
•
raise
events,
local
the
statechart
model,
the
environment.
general,
an
event
the
following
signature:
<
event
−
name
>
(<
event
−
params
>).
the
name
event
raised
the
environment
preceded
::.
perform
computation
assignment
the
system’s
variables.
figure
4,
transition
modeled
that
describe
the
traffic
light’s
timed
behaviour:
the
state
the
system
change
certain
delays,
an
output
event
raised
the
state
changed,
corresponding
the
light
activated.
the
interface
this
model
the
set
accepted
input
event
x
=
∅
the
set
possible
output
event
y
=
{displayred,
displaygreen,
displayyellow}.
this
system
placed
an
environment
executed,
the
environment
listen
the
output
event
take
appropriate
action
(in
this
case,
turning
the
correct
light
off),
influence
the
behaviour
the
system
raising
input
events.
this
first
version
the
system
fully
autonomous
not
accept
input
event
(yet).
311

van
mierlo
vangheluwe
5
statecharts
extension
the
statechart
formalism
a
number
extension
make
easier
develop
complex
systems.
only
basic
state
transition
available,
model
not
scale
grow
rapidly,
hindering
understandability.
the
next
subsections,
explore
composite
state
(which
allow
nesting
state
arbitrary
depth),
orthogonal
region
(which
allow
modelling
concurrent
behaviour),
history
state
(which
allow
restoring
the
state
a
re-entered
composite
state).
last,
explain
a
number
construct
do
not
add
functionality,
make
easier
express
certain
behaviour,
so-called
“syntactic
sugar”.
use
the
full
model
the
traffic
light’s
behaviour,
shown
figure
5,
illustrate
the
different
element
the
statechart
formalism.
5.1
composite
states
a
composite
state
a
collection
substates,
basic
state
composite
states.
this
nesting
state
arbitrary
depths.
the
main
purpose
composite
state
group
behaviour
logically
belong
together.
transition
defined
the
outer
state
thought
as
defined
any
the
inner
state
well
–
a
flattening
procedure,
possible
obtain
an
equivalent
statechart
model
only
basic
state
transitions.
example,
figure
5,
two
high-level
mode
the
traffic
light
defined
the
composite
state
normal
interrupted.
a
police
interrupt
event
raised
the
environment,
the
mode
regardless
the
active
substate.
case
a
transition
a
composite
state
target,
the
default
state
that
composite
state
entered
(transitively,
the
lowest
level).
this
all
composite
state
need
exactly
one
default
state,
as
the
case
the
statechart
model
well.
one
important
issue
composite
state
unwanted
non-determinism
occur
a
substate
an
outgoing
transition
triggered
the
same
event
composite
state’s
transition.
the
flattened
version
the
statechart
model,
this
non-determinism
obvious,
a
state
two
outgoing
transition
triggered
the
same
event.
example,
figure
5,
a
transition
the
police
interrupt
event
the
state
red
the
state
green,
the
model
non-deterministic
case
the
red
state
active
a
police
interrupt
event
raised
the
environment.
resolve
such
non-determinism
(as
statecharts
a
deterministic
formalism),
the
outer-most
transition
chosen
–
as
the
case
statemate
(harel
naamad
1996)
–
the
inner-most
transition
chosen
–
as
rhapsody
(harel
kugler
2004).
these
different
option
presented
figure
6.
this
tutorial,
assume
statemate
semantics.
5.2
concurrent
region
states
combined
hierarchically
composite
state
(as
explained
the
previous
subsection),
orthogonally
concurrent
regions.
before,
exactly
one
state
the
statechart
model
active
the
same
time,
entering
a
state
concurrent
regions,
all
region
execute
simultaneously.
this
react
event
concurrently,
communicate
each
other.
this
done
raising
event
one
concurrent
region
“sensed”
the
other
concurrent
region
(broadcast
communication).
the
full
statechart
model
the
traffic
light
system
figure
5,
two
orthogonal
region
trafficlight
timer
modeled.
the
behaviour
the
first
region
the
color
the
traffic
light,
switching
red,
green,
yellow,
back
red,
allowing
a
policeman
interrupt
the
“normal”
behaviour
showing
a
blinking
yellow
light.
the
second
region
the
timer:
a
timer
the
green
red
light
active.
implement
this
behaviour,
a
variable
counter
introduced,
type
integer.
two
method
settimervalue
gettimervalue
used
set
get
the
value
this
counter,
decreasetimervalue
the
counter
1.
the
trafficlight
component
the
timer
sending
the
following
events:
312

van
mierlo
vangheluwe
trafficlight
/
raise
out::displayred;
settimervalue(60);
raise
resettimer
normal
in::police_interrupt
/
raise
disabletimer
interrupted
red
/
raise
out::displayyellow
after(60)
/
raise
out::displaygreen;
settimervalue(55);
raise
resettimer
after(5)
/
raise
out::displayred;
settimervalue(60);
raise
enabletimer;
raise
resettimer
yellow
after(1)
/
raise
out::displayyellow
green
after(1)
/
raise
out::displaynone
after(55)
/
raise
out::displayyellow;
raise
disabletimer
black
yellow
in::police_interrupt
/
raise
out::enabletimer
h
timer
disabled
disabletimer
/
raise
out::updatetimervalue(-1)
resettimer
/
raise
out::updatetimervalue(-1)
enabletimer
running
decidingcolor
[in(trafficlight/normal/red)]
/
raise
out::updatetimercolor("red");
raise
out::updatetimervalue(gettimervalue())
[in(trafficlight/normal/green)]
/
raise(updatetimercolor("green"),
out);
raise(updatetimervalue(gettimervalue(),
out)
green
red
after(1)
/
decreasetimervalue();
raise
out::updatetimervalue(gettimervalue()
after(1)
/
decreasetimervalue();
raise
out::updatetimervalue(gettimervalue())
figure
5:
the
full
model
the
traffic
light’s
behaviour.
313

van
mierlo
vangheluwe
c
a
e
e
b
d
c/a
e
c/b
(a)
c/a
e
c/a
e
d
d
e
c/b
(b)
e
(c)
e
c/b
d
e
(d)
figure
6:
non-determinism
composite
state;
(a)
an
example
model
containing
non-determinism,
(b)
flattened
version:
non-determinism
state
a,
(c)
statemate
semantics:
outermost
transition
prioritized,
(d)
rhapsody
semantics:
innermost
transition
prioritized.
•
•
•
resettimer,
reset
the
timer
the
appropriate
color
value.
disabletimer,
disable
the
timer.
enabletimer,
enable
the
timer
it’s
disabled.
the
timer
component
then
the
communication
the
environment
raising
the
following
events:
•
•
updatetimervalue
the
environment
update
the
displayed
value
the
timer.
a
negative
value
no
value
displayed.
updatetimercolour
the
environment
update
the
displayed
color
the
timer.
5.3
history
a
last
element
the
statechart
formalism
the
history
state.
a
history
state
placed
a
composite
state
a
direct
child.
the
current
state
the
composite
state
the
composite
state
exited.
two
type
history
state
exist:
shallow
history
state
remember
the
current
state
own
level,
deep
history
state
remember
the
current
state
own
level
all
lower
level
the
hierarchy.
a
transition
the
history
state
target,
the
state
remembered
restored
(instead
entering
the
default
state
the
composite
state).
figure
5,
a
history
state
modeled
that
the
state
the
normal
composite
state
exited
the
transition
the
interrupted
composite
state.
the
transition
the
normal
state
the
history
state
target,
the
state
remembered.
example,
the
green
state
active
a
police
interrupt
state
raised
the
environment,
the
next
police
interrupt
event
re-active
the
green
state.
the
history
state
not
present,
the
red
state
entered
instead.
5.4
syntactic
sugar
the
previous
subsection
discussed
the
essential
element
the
statechart
formalism.
there
are,
however,
additional
syntactic
construct
make
the
modeler’s
life
easier,
modeled
using
the
“standard”
statechart
construct
well.
one
those
“syntactic
sugar”
addition
the
entry/exit
action
states,
a
efficient
way
specifying
action
always
need
executed
a
state
entered
exited,
instead
repeating
the
action
each
incoming/outgoing
transition.
an
entry
action
executed
a
state
entered,
an
exit
action
executed
a
state
exited.
this
an
important
effect
the
semantics
executing
a
transition
combined
composite
states.
a
transition
defined
state
a
b.
executing
this
transition,
the
state
a
exited,
the
state
b
entered.
however,
this
only
the
314

van
mierlo
vangheluwe
generator
normal
/
raise
displayyellow
after(60)
/
raise
displaygreen
after(5)
/
raise
displayred
police_interrupt
yellow
phase3
in(interrupted)
after(1)
/
raise
displayblack
after(1)
/
raise
displaynone
green
police_interrupt
after(3)
/
raise
police_interrupt
phase2
in(normal/green)
black
after(55)
/
raise
displayyellow
phase3
after(4)
phase2
in(normal/red)
after(66)
after(65)
/
raise
police_interrupt
interrupted
red
after(1)
phase1
/
raise
displayred
phase1
acceptor
trafficlight
pass
yellow
h
fail
figure
7:
a
test
the
traffic
light
system
(without
timer).
case
a
b
part
the
same
composite
states.
more
state
exited
a
part
a
state
hierarchy,
more
state
entered
case
b
part
a
(different)
state
hierarchy.
execute
a
transition,
the
“least
common
ancestor”
(lca)
state
computed
the
source
state
a
target
state
b.
the
lca
a
state
the
hierarchy
both
a
b
both
a
b
a
substate
(and
the
bottom-most
state
that
property).
execute
a
transition,
starting
a,
the
state
the
hierarchy
up
not
including
the
lca
exited
(and
exit
action
executed
the
same
order).
then,
the
transition’s
action
executed.
then,
the
state
the
hierarchy
b
entered,
including
b
excluding
the
lca
(and
enter
action
executed
the
same
order).
6
testing
statechart
model
test
a
statechart
model,
need
define
a
trace
input
event
an
expected
trace
output
events,
as
shown
figure
3.
test
need
fully
automated.
therefore,
need
a
different
tactic
simulating
the
model
manually
providing
the
input
events,
checking
the
model’s
reaction.
want
autonomously
generate
a
number
event
(timed)
a
“generator”
check
the
system
the
correct
event
an
“acceptor”.
basically,
an
environment
interacting
the
system
simulated
the
form
this
generator-acceptor
pair.
simulate
an
environment,
regard
the
system
black
box
use
a
mechanism
generate
event
correctly
outside
the
model.
alternatively,
view
the
system
a
white
box
model
the
generator/acceptor
pair
using
statecharts
well.
this
the
advantage
instrumenting
the
model
the
same
language
developed
in.
moreover,
the
statechart
language
appropriate
express
the
behaviour
the
generator
acceptor,
timed,
autonomous,
reactive
systems.
this
illustrated
figure
7,
develop
a
test
case
(a
part
of)
the
traffic
light
the
generator
acceptor
modeled
orthogonal
region
the
actual
system.
the
test
case
the
expected
behaviour
the
traffic
light
two
police
raised
the
environment.
the
generator
a
police
interrupt
65
seconds,
one
more
3
(in
total
68)
seconds.
the
acceptor
check
the
correct
state
traversed
the
system.
first,
315

van
mierlo
vangheluwe
the
system
initialized
the
normal/red
state.
then,
the
interrupted
state
entered.
last,
the
system’s
state
restored
normal/green
(since
the
state
active
the
system
transitioned
the
interrupted
state).
each
state
a
timeout:
the
system’s
state
not
change
time
(according
the
time
delay
after
transitions),
the
acceptor
transition
a
fail
state.
the
test
the
acceptor
the
pass
state.
due
white-box
approach,
able
both
check
the
output
event
produced
the
system,
as
well
internal
state.
able
check
the
event
raised
the
model,
change
these
event
locally
raised,
instead
raised
the
environment.
testing
using
a
black-box
the
generator
acceptor
modeled
separate
statechart
models,
a
communication
channel
the
generator,
the
system,
the
acceptor
set
up.
however,
this
the
disadvantage
a
delay
introduced
the
communication
channels,
difficult
account
the
generator
acceptor.
allow
testing
a
system
do
not
access
the
model,
outside
the
scope
this
tutorial.
7
tool
support:
yakindu
yakindu
a
statecharts
modeling
simulation
tool,
the
following
features:
•
•
•
•
a
graphical
modeling
tool
describing
system
the
statechart
formalism.
a
neutral
action
language
use
transition
constraint
actions.
a
simulator,
simulate
statechart
model
check
behaviour.
the
simulator
user
raise
event
the
simulation
running.
a
code
generator
interface
generating
code
any
programming
language
–
pre-defined
code
generator
provided
java,
c,
c++.
the
code
generator’s
configurable
option
include
the
folder
generate
file
in,
the
“execution
scheme”
(cycle-based
event-driven),
listener
external
event
need
generated,
etc.
yakindu
writing
custom
own
code
generators,
increasing
the
flexibility
the
tool.
figure
8
show
the
traffic
light
model
figure
5
modeled
yakindu.
central
the
figure
the
canvas,
the
statechart
model
drawn.
the
tool
“syntax-directed”,
only
syntactically
correct
model
constructed.
the
valid
syntactic
element
shown
the
right
side
a
palette.
these
element
correspond
the
one
discussed
the
previous
sections,
a
few
extra
syntactic
sugar
elements,
not
discussed
here.
the
left
the
figure,
an
interface
the
statechart
model
defined.
this
interface
explicit
the
possible
input,
output,
locally
raised
events,
as
well
any
data
variable
operation
these
variables.
the
previous
sections,
left
this
definition
the
interface
implicit,
yakindu
make
explicit
various
reasons:
•
•
•
transition
trigger
validated,
only
use
an
after-event
an
event
declared
the
interface
(which
either
internal
external).
action
validated
only
access
variable
declared,
perform
operation
valid
datum
type,
only
call
function
declared
the
interface.
generating
code,
interface
method
output
event
listener
generated,
corresponding
the
possible
output
event
the
system.
similarly,
interface
method
raising
input
event
(from
the
environment)
generated.
checking
the
syntactic
validity
the
model
as
well
the
validity
condition
trigger
action
code,
yakindu
many
possible
error
a
modeler
make.
can,
this
model,
also
generate
a
running
application.
case,
generate
the
behaviour
visualize
a
java
gui,
the
current
state
the
system
(which
light
currently
on,
the
value
the
timer),
interact
the
system
pressing
a
button.
do
this,
define
a
visualization
library
display
the
state
system.
the
following
interface:
316

van
mierlo
vangheluwe
figure
8:
screenshot
the
traffic
light
model
the
yakindu
modeling
simulation
tool.
317

van
mierlo
vangheluwe
figure
9:
the
deployed
system.
•
•
•
•
•
•
setred(boolean):
the
red
light
the
boolean
true,
off
the
boolean
false.
setgreen(boolean):
the
green
light
the
boolean
true,
off
the
boolean
false.
setyellow(boolean):
the
yellow
light
the
boolean
true,
off
the
boolean
false.
settimervalue(int):
the
value
the
timer
the
specified
integer
value.
a
value
-1
the
timer.
settimercolour(string):
the
color
the
specified
string,
“red”
“green”.
addlistener(button,
listener):
a
listener
the
button
the
gui
turning
on/off
the
traffic
light,
the
police
interrupt.
this
library
instantiated
show
the
current
state
a
traffic
light,
as
shown
figure
9,
the
red
light
active
the
44
second
remaining
the
light
green.
connect
this
gui
the
code
generated
yakindu
the
statechart
model,
define
appropriate
listener
the
button
the
interface:
•
•
the
on/off
button
a
toggle
event
the
system,
turning
the
traffic
light.
the
police
interrupt
button
a
police
interrupt
event
the
system,
interrupting
the
normal
operation
the
traffic
light
restoring
it.
also
define
appropriate
listener
translate
output
event
raised
the
system
method
call
the
gui:
•
•
•
the
displayred
event
translated
three
method
call
a
listener:
setred(true),
setgreen(false),
setyellow(false).
similarly,
the
displaygreen,
displayyellow,
displaynone
event
translated
appropriate
method
calls.
the
updatetimervalue
event
translated
a
method
call
settimervalue,
passing
the
correct
value
the
counter.
the
updatetimercolour
event
translated
a
method
call
settimercolour,
passing
the
correct
color
the
counter.
318

van
mierlo
vangheluwe
this
development
method
cleanly
separating
behaviour
(encoded
the
model,
generated
executable
code
an
appropriate
code
generator)
the
presentation
(encoded
a
visualization
library).
complex
control
system
benefit
this
separating
the
control
logic
the
actuator
sensors,
appropriate
interface
offer
the
necessary
functionality.
8
conclusion
this
tutorial,
introduce
statecharts
an
appropriate
language
describing
the
timed,
reactive,
autonomous
behaviour
systems.
the
statechart
formalism
the
following
abstractions:
•
•
•
states,
combined
hierarchically
composite
state
orthogonally
orthogonal
regions.
transition
states,
encoding
the
dynamics
the
system.
history
states,
remember
the
active
child
state(s)
a
composite
state
the
composite
state
exited.
explained
the
syntax
semantics
each
the
construct
demonstrated
use
a
running
example:
a
traffic
light
a
counter
showing
long
the
traffic
light’s
current
light
stay
on,
interrupted
a
policeman.
use
yakindu,
an
eclipse-based
visual
modeling
tool,
model
the
system,
simulate
it,
test
it,
ultimately
generate
code
connected
a
visualization
library
deploy
the
system.
acknowledgment
this
research
partially
supported
flanders
make
vzw,
the
strategic
research
center
the
manufacturing
industry.
harel,
d.
1987.
“statecharts:
a
visual
formalism
complex
systems”.
science
computer
programming
8(3):231–274.
harel,
d.,
h.
kugler.
2004.
“the
rhapsody
semantics
statecharts
(or,
the
executable
core
the
uml)”.
integration
software
specification
technique
applications
engineering,
edited
h.
ehrig
al.,
325–354.
berlin
heidelberg:
springer.
harel,
d.,
a.
naamad.
1996.
“the
statemate
semantics
statecharts”.
acm
transaction
software
engineering
methodology
5(4):293–333.
hopcroft,
j.
e.,
r.
motwani,
j.
d.
ullman.
2006.
introduction
automata
theory,
languages,
computation.
3rd
editor
boston,
ma,
usa:
addison-wesley
longman
publishing
co.,
inc.
lee,
e.
a.
2006.
“the
problem
threads”.
computer
39(5):33–42.
lúcio,
l.,
s.
mustafiz,
j.
denil,
h.
vangheluwe,
m.
jukss.
2013.
“ftg+pm:
an
integrated
framework
investigating
model
transformation
chains”.
proceedings
sdl
2013:
model-driven
dependability
engineering:
16th
international
sdl
forum,
edited
f.
khendek
al.,
182–202.
berlin,
heidelberg:
springer.
author
biography
simon
van
mierlo
a
post-doctoral
researcher
the
university
antwerp
(belgium).
a
member
the
modeling,
simulation
design
(msdl)
research
lab.
phd
thesis,
developed
debugging
technique
modeling
simulation
formalism
explicitly
modeling
executor’s
control
flow
using
statecharts.
the
main
developer
maintainer
sccd,
a
hybrid
formalism
statecharts
class
diagrams.
e-mail
address
simon.vanmierlo@uantwerpen.be.
319

van
mierlo
vangheluwe
hans
vangheluwe
a
professor
the
university
antwerp
–
flanders
make
(belgium),
an
adjunct
professor
mcgill
university
(canada)
an
adjunct
professor
the
national
university
defense
technology
(nudt)
changsha,
china.
the
modeling,
simulation
design
(msdl)
research
lab.
a
variety
projects,
often
industrial
partners,
the
model-based
theory
technique
multi-paradigm
modeling
(mpm).
current
interest
domain-specific
modeling
simulation,
including
the
development
graphical
user
interface
multiple
platforms.
model
such
reactive
systems,
the
use
statecharts
describe
behaviour.
e-mail
address
hans.vangheluwe@uantwerpen.be.
320



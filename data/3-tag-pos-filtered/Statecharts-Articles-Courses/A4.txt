12.
finite-state
machines
12.1
introduction
this
chapter
finite-state
machines,
a
primitive,
useful
computational
model
both
hardware
certain
type
software.
also
discuss
regular
expressions,
the
correspondence
non-deterministic
deterministic
machines,
more
grammars.
finally,
describe
typical
hardware
component
essentially
physical
realization
finite-state
machines.
finite-state
machine
provide
a
simple
computational
model
many
applications.
recall
the
definition
a
turing
machine:
a
finite-state
controller
a
movable
read/write
head
an
unbounded
storage
tape.
restrict
the
head
move
only
one
direction,
the
general
case
a
finite-state
machine.
the
sequence
symbol
read
thought
constitute
the
input,
the
sequence
symbol
written
thought
constitute
the
output.
also
derive
output
looking
the
internal
state
the
controller
the
input
read.
finite-state
machines,
also
called
finite-state
automata
(singular:
automaton)
just
finite
automata
much
restrictive
capability
turing
machines.
example,
show
not
possible
a
finite-state
machine
determine
the
input
a
prime
number
symbols.
much
simpler
languages,
such
the
sequence
well-balanced
parenthesis
strings,
also
recognized
finite-state
machines.
still
the
following
applications:
•
simple
form
pattern
matching
(precisely
the
pattern
definable
"regular
expressions”,
see).
•
model
sequential
logic
circuits,
the
kind
every
present-day
computer
many
device
controller
based.
•
an
intimate
relationship
directed
graph
arc
labeled
symbol
the
input
alphabet.
even
each
these
model
depicted
a
different
setting,
a
common
mathematical
basis.
the
following
diagram
the
context
finite-state
machine
other
model
studied
study.

472
finite-state
machines
turing
machines
context-free
grammar
sequential
logic
switching
finite-state
machines,
finite-state
automata
finite-state
grammar
combinational
logic
switching
circuit
finite
directed
labelled
graph
regular
expressions,
regular
language
figure
189:
the
interrelationship
various
model
respect
computational
representational
power.
the
arrows
move
the
direction
restricting
power.
the
bi-directional
arrow
show
equivalences.
finite-state
machines
restricted
turing
machines
one
way
view
the
finite-state
machine
model
a
restrictive
turing
machine
separate
the
input
output
half
the
tapes,
shown
below.
however,
mathematically
don't
need
rely
the
tape
metaphor;
just
viewing
the
input
output
sequence
event
occurring
time
adequate.
output
written
so
far
input
read
q
direction
head
motion
figure
190:
finite-state
machine
a
one-way
moving
turing
machine
input
read
q
direction
head
motion
output
written
so
far
figure
191:
finite-state
machine
viewed
separate
input
output

finite-state
machines
473
direction
tape
motion
q
reading
writing
direction
tape
motion
figure
192:
finite-state
machine
viewed
a
stationary-head,
moving-tape,
device
the
motion
the
head
the
tape
strictly
one-way,
abstract
the
idea
a
tape
just
refer
the
input
sequence
read
the
output
sequence
produced,
as
suggested
the
next
diagram.
a
machine
this
form
called
a
transducer,
input
sequence
output
sequences.
the
term
mealy
machine,
george
h.
mealy
(1965),
also
often
used
transducer.
output
sequence
y
y
y
input
sequence
x
x
x
x
...
y
...
1
2
3
4
1
2
3
4
finite
set
internal
state
figure
193:
a
transducer
finite-state
machine
viewed
a
tapeless
"black
box"
processing
an
input
sequence
produce
an
output
sequence
the
other
hand,
occasionally
not
interested
the
sequence
output
produced,
just
an
output
associated
the
current
state
the
machine.
this
simpler
model
called
a
classifier,
moore
machine,
e.f.
moore
(1965).
output
associated
current
state
z
input
sequence
x
x
x
x
...
1
2
3
4
finite
set
internal
state
figure
194:
classifier
finite-state
machine.
output
a
function
current
state,
rather
a
sequence

474
finite-state
machines
modeling
the
behavior
finite-state
machines
concentrating
initially
transducers,
several
different
notation
use
capture
the
behavior
finite-state
machines:
•
a
functional
program
mapping
one
list
another.
•
a
restricted
imperative
program,
reading
input
a
single
character
a
time
producing
output
a
single
character
a
time.
•
a
feedback
system.
•
representation
function
a
table
•
representation
function
a
directed
labeled
graph
concreteness,
use
the
sequence-to-sequence
model
the
machine,
the
other
model
represented
similarly.
let
give
an
example
use
show
the
different
notations:
example:
an
edge-detector
the
function
an
edge
detector
detect
transition
two
symbol
the
input
sequence,
say
0
1.
this
outputting
0
long
the
recent
input
symbol
the
same
the
previous
one.
however,
the
recent
one
the
previous
one,
output
a
1.
convention,
the
edge
detector
always
output
0
reading
the
very
first
symbol.
thus
the
following
input
output
sequence
pair
the
edge-detector,
an
infinite
number
possible
pairs:
input
0
00
01
011
0111
01110
output
0
00
01
010
0100
01001
1
10
101
1010
10100
etc.
0
01
011
0111
01110

finite-state
machines
475
functional
program
view
finite-state
machines
this
view,
the
behavior
a
machine
as
a
function
list
lists.
each
state
the
machine
identified
a
function.
the
initial
state
identified
the
overall
function
the
machine.
the
function
interrelated
mutual
recursion:
a
function
an
input
symbol,
another
function
process
the
remaining
input.
each
function:
input
one
application
first,
an
output
one
application
cons,
the
first
argument
determined
purely
the
input
obtained
first,
another
function
(or
itself)
rest
the
input.
make
the
assumption
that:
the
result
cons,
particular
the
first
argument,
partially
available
even
second
argument
computed.
each
function
return
nil
the
input
list
nil,
do
not
show
this
explicitly.
functional
code
example
the
edge-detector:
use
three
functions,
f,
g,
h.
the
function
f
the
overall
representation
the
edge
detector.
f([0
|
rest])
=>
[0
|
g(rest)];
f([1
|
rest])
=>
[0
|
h(rest)];
f([])
=>
[];
g([0
|
rest])
=>
[0
|
g(rest)];
g([1
|
rest])
=>
[1
|
h(rest)];
g([])
=>
[];
h([0
|
rest])
=>
[1
|
g(rest)];
h([1
|
rest])
=>
[0
|
h(rest)];
h([])
=>
[];
notice
f
never
called
initial
use.
only
purpose
provide
the
proper
output
(namely
0)
the
first
symbol
the
input.

476
finite-state
machines
example
f
applied
a
specific
input:
f([0,
1,
1,
1,
0])
==>
[0,
1,
0,
0,
1]
an
alternative
representation
use
a
single
function,
say
k,
an
extra
argument,
treated
just
a
symbol.
this
argument
the
name
the
function
called
the
original
representation.
the
top-level
call
k
give
the
initial
state
this
argument:
k("f",
[0
|
rest])
=>
[0
|
k("g",
rest)];
k("f",
[1
|
rest])
=>
[0
|
k("h",
rest)];
k("f",
[])
=>
[];
k("g",
[0
|
rest])
=>
[0
|
k("g",
rest)];
k("g",
[1
|
rest])
=>
[1
|
k("h",
rest)];
k("g",
[])
=>
[];
k("h",
[0
|
rest])
=>
[1
|
k("g",
rest)];
k("h",
[1
|
rest])
=>
[0
|
k("h",
rest)];
k("h",
[])
=>
[];
the
top
level
call
input
sequence
x
k("f",
x)
"f"
the
initial
state.
imperative
program
view
finite-state
machines
this
view,
the
input
output
viewed
stream
characters.
the
program
the
processing
cycle:
read
character,
select
next
state,
write
character,
go
next
state
ad
the
state
represented
separate
"functions",
the
functional
view,
just
the
value
one
more
variables.
however
the
allowable
value
restricted
a
finite
set.
no
stack
other
extendible
structure
used,
any
arithmetic
restricted
a
finite
range.
the
following
a
transliteration
the
previous
program
this
view.
the
program
started
calling
f().
here
assume
read()
a
method
the
next
character
the
input
stream
write(c)
character
c
the
output
stream.
void
f()
//
initial
function
{
switch(
read()
)
{
case
'0':
write('0');
g();
break;
case
'1':
write('0');
h();
break;
}

finite-state
machines
477
}
void
g()
//
previous
input
0
{
switch(
read()
)
{
case
'0':
write('0');
g();
break;
case
'1':
write('1');
h();
break;
//
0
->
1
transition
}
}
void
h()
//
previous
input
1
{
switch(
read()
)
{
case
'0':
write('1');
g();
break;
//
1
->
0
transition
case
'1':
write('0');
h();
break;
}
}
[note
this
a
case
all
call
"tail
recursive",
i.e.
implemented
gotos
a
smart
compiler.]
the
same
task
accomplished
eliminating
the
function
using
a
single
variable
record
the
current
state,
shown
the
following
program.
before,
assume
read()
the
next
character
the
input
stream
write(c)
character
c
the
output
stream.
static
final
char
f
=
'f';
static
final
char
g
=
'g';
static
final
char
h
=
'h';
static
final
char
initial_state
=
f;
main()
{
char
current_state,
next_state;
char
c;
current_state
=
initial_state;
//
set
state

478
finite-state
machines
while(
(c
=
read())!
!=
eof
)
{
switch(
current_state
)
{
case
f:
//
initial
state
switch(
)
{
case
'0':
write('0');
next_state
=
g;
break;
case
'1':
write('0');
next_state
=
h;
break;
}
break;
case
g:
//
last
input
0
switch(
)
{
case
'0':
write('0');
next_state
=
g;
break;
case
'1':
write('1');
next_state
=
h;
break;
//
0
->
}
break;
case
h:
switch(
c
{
case
'0':
case
'1':
}
break;
}
current_state
}
//
last
input
1
)
write('1');
next_state
=
g;
break;
//
1
->
0
write('0');
next_state
=
h;
break;
=
next_state;
}
feedback
system
view
finite-state
machines
the
feedback
system
view
the
functionality
a
machine
two
functions,
the
next-state
state-transition
function
f,
the
output
function
g.
f:
states
x
→
states
state-transition
function
g:
states
x
→
symbol
output
function
the
meaning
these
function
as
follows:
f(q,
σ)
the
state
the
machine
currently
state
q
σ
read
g(q,
σ)
the
output
produced
the
machine
currently
state
q
σ
read
the
relationship
these
function
expressible
the
following
diagram.

finite-state
machines
479
output
function
output
g
next-state
function
f
input
∆
delay
memory
the
current
state
figure
195:
feedback
diagram
finite-state
machine
structure
f
g,
form
two
useful
function
f*:
states
x
symbols*
→
states
extended
state-transition
function
g*:
states
x
symbols*
→
symbol
extended
output
function
symbols*
the
set
all
sequence
symbols.
this
done
induction:
f*(q,
λ)
=
q
f*(q,
xσ)
=
f(f*(q,
x),
σ
)
g*(q,
λ)
=
λ
g*(q,
xσ)
=
g*(q,
x)
g(f*(q,
x),
σ
)
the
last
equation,
juxtaposition
cons’ing
the
right.
other
words,
f*(q,
x)
the
state
the
machine
all
symbol
the
sequence
x
processed,
g*(q,
x)
the
sequence
output
produced
the
way.
essence,
g*
regarded
the
function
computed
a
transducer.
these
definition
transcribed
rex
rule
representing
the
sequence
xσ
a
list
[σ
|
x]
λ
corresponding
[
].
tabular
description
finite-state
machines
this
description
similar
the
one
used
turing
machines,
the
motion
left
unspecified,
implicitly
one
direction.
lieu
the
two
function
f
g,
a

480
finite-state
machines
finite-state
machine
specified
a
single
function
combining
f
g
the
form:
states
x
→
states
x
analogous
the
case
a
turing
machine,
included
the
motion:
states
x
→
symbol
x
x
state
these
function
also
represented
succinctly
a
table
4-tuples,
similar
used
a
turing
machine,
again
called
a
state
transition
table:
state1,
symbol1,
state2,
symbol2
such
a
4-tuple
the
following:
the
machine's
control
state1
symbol1,
then
machine
write
symbol2
the
next
state
the
controller
state2.
the
state-transition
table
the
edge-detector
machine
is:
start
state
current
state
f
f
g
g
h
h
input
symbol
0
1
0
1
0
1
next
state
g
h
g
h
g
h
output
symbol
0
0
0
1
1
0
the
case
turing
no
particular
halting
convention.
instead,
the
machine
always
read
proceed
current
state
in.
this
not
stop
assigning
own
particular
meaning
a
symbol
designate,
example,
end-of-input.
classifiers,
acceptors,
transducers,
sequencer
some
problem
don't
care
generating
an
entire
sequence
output
symbol
as
do
the
transducer
discussed
previously.
instead,
only
interested
categorizing
each
input
sequence
one
a
finite
set
possibilities.
often
these
possibility
made
derive
the
current
state.
attach
the
result
the
computation
the
state,
rather
generate
a
sequence.
this
model,
an
output
function
c:
q
→
c

finite-state
machines
481
a
category
class
each
state.
call
this
type
machine
a
classifier
controller.
study
the
conrtoller
aspect
the
next
chapter.
now,
focus
the
classification
aspect.
the
simplest
non-trivial
case
classifier,
two
categories.
the
state
divided
the
"accepting"
state
(class
1,
say)
the
"rejecting"
(class
0).
the
machine
this
case
called
an
acceptor
recognizer.
the
sequence
those
given
c(f*(q0,
x))
=
1
the
sequence
x
such
that,
started
state
q0,
reading
x,
the
machine
a
state
q
that
c(q)
=
1.
the
set
all
such
x,
a
set
strings,
a
language
the
sense
already
discussed.
a
a
finite-state
acceptor,
then
l(a)
=
{
σ*
|
c(f*(q0,
x))
=
1}
the
language
accepted
a.
the
structure
a
classifier
simpler
that
a
transducer,
the
output
only
a
function
the
state
not
the
state
input.
the
structure
shown
follows:
output
output
function
g
next-state
function
f
input
∆
delay
memory
the
current
state
figure
196:
feedback
diagram
classifier
finite-state
machine
structure
a
final
class
machine,
called
a
sequencer
generator,
a
special
case
a
transducer
classifier
a
single-letter
input
alphabet.
the
input
symbol
unchanging,
this
machine
a
fixed
sequence,
interpreted
the
output
sequence
a
transducer
the
sequence
classifier
outputs.
an
example
a
sequencer
a
midi
(musical
instrument
digital
interface)
sequencer,
used
drive
electronic
musical
instruments.
the
output
alphabet
a
midi
sequencer
a
set
16-bit
words,
each
a
special
interpretation
pitch,
note
start
stop,
amplitude,
etc.

482
finite-state
machines
midi
sequencer
programmable,
the
program
typically
the
nature
an
initial
setup
rather
a
sequential
input.
description
finite-state
machines
using
graph
any
finite-state
machine
shown
a
graph
a
finite
set
nodes.
the
node
correspond
the
states.
no
other
memory
implied
other
the
state
shown.
the
start
state
designated
an
arrow
directed
the
corresponding
node,
otherwise
unconnected.
figure
197:
an
unconnected
in-going
arc
the
node
the
start
state
the
arc
node
labeled
differently,
depending
representing
a
transducer,
a
classifier,
an
acceptor.
the
case
a
transducer,
the
arc
labeled
σ/δ
shown
below,
σ
the
input
symbol
δ
the
output
symbol.
the
statetransition
designated
virtue
the
arrow
going
one
node
another.
q
σ/δ
1
q
2
figure
198:
transducer
transition
q1
q2,
based
input
σ,
giving
output
δ
the
case
a
classifier,
the
arrow
labeled
only
the
input
symbol.
the
category
attached
the
name
the
state
/.
q
/c
1
σ
1
q2
/
c2
figure
199:
classifier
transition
q1
q2,
based
input
σ
the
case
a
acceptor,
instead
labeling
the
state
category
0
1,
sometimes
use
a
double-lined
node
an
accepting
state
a
single-lined
node
a
rejecting
state.

finite-state
machines
483
q
a
figure
200:
acceptor,
an
accepting
state
transducer
example
the
edge
detector
an
example
a
transducer.
here
graph:
0/0
f
1/0
g
0/0
0/1
1/1
h
1/0
figure
201:
directed
labeled
graph
the
edge
detector
let
also
give
example
classifier
acceptors,
building
this
example.
classifier
example
suppose
wish
categorize
the
input
the
input
so
far
0,
1,
more
1
"edges"
(transitions
0
1,
1
0).
the
appropriate
machine
type
classifier,
the
output
the
set
{0,
1,
more}.
the
name
"more"
chosen
arbitrarily.
sketch
this
classifier
the
aid
a
graph.
the
construction
the
start
state.
don't
know
many
state
initially.
let
use
a,
b,
c,
...
the
name
the
states,
a
the
start
state.
each
state
labeled
the
corresponding
class
the
idea
achieve
a
finite
closure
some
number
state
added.
the
result
shown
below:

484
finite-state
machines
1
0
1
d/1
b/0
0
0
a/0
0,
1
f
/
more
1
0
1
1
0
e/1
c/0
figure
202:
classifier
counting
0,
1,
more
1
edge
acceptor
example
let
give
an
acceptor
those
string
exactly
one
edge.
use
the
state
transition
the
previous
classifier.
need
only
designate
those
state
categorize
there
one
edge
accepting
state
the
other
rejecting
states.
1
0
1
d
b
0
0
a
0,
1
f
1
0
1
1
0
c
e
figure
203:
acceptor
string
exactly
one
edge.
accepting
state
d
e.

finite-state
machines
485
sequencer
example
the
following
sequencer,
the
sequence
the
output
associated
each
state,
a
naive
traffic
light:
q0
/
green
q1
/
yellow
q2
/
red
figure
204:
a
traffic
light
sequencer
1
••
consider
a
program
an
input
sequence
character
determine
the
sequence
as
scanned
so
far
either
an
integer
a
floating-point
numeral,
unknown,
neither.
each
character,
output
the
corresponding
assessment
the
input.
example,
input
scanned
1
+
+1
+1.
1.5
1e
1e-1
1e.
assessment
integer
unknown
integer
floating-point
floating-point
unknown
floating-point
describe
the
scanner
a
finite-state
transducer
using
the
various
method
presented
the
text.
2
••
some
organization
automated
telephone
system
so
message
sent
pushing
the
button
the
telephone.
the
button
labeled
both
numeral
letter
shown:

486
finite-state
machines
1
2
abc
3
def
4
ghi
5
jkl
6
mno
7
prs
8
tuv
9
wxy
*
0
#
notice
certain
letter
omitted,
presumably
historical
reasons.
however,
common
use
*
represent
letter
q
#
represent
letter
z.
common
scheme
do
not
use
a
one-to-one
encoding
each
letter.
however,
wanted
an
encoding,
one
method
use
two
digit
each
letter:
the
first
digit
the
key
containing
the
letter.
the
second
digit
the
index,
1,
2,
3,
the
letter
the
key.
example,
send
the
word
"cat",
we'd
punch:
2
3
c
2
1
a
8
1
t
an
exception
made
'q'
'z',
the
only
letter
the
key
'*'
'#'
respectively.
give
the
state-transition
table
communicating
a
series
any
the
twenty-six
letters,
the
input
alphabet
the
set
digit
{1,
....,
9,
*,
#}
the
output
alphabet
the
set
available
letters.
note
output
occur
only
every
other
input.
need
a
convention
output
shown
the
transducer
case
no
output.
use
λ
this
output.
3
••
the
device
sketched
below
capable
partially
sensing
the
direction
(clockwise,
counterclockwise,
stopped)
a
rotating
disk,
sector
painted
alternating
gray
white.
the
two
sensors,
spaced
so
as
fit
well
a
single
sector,
regularly
transmit
one
four
input
possibilities:
wg
(white-gray),
ww
(white-white),
gw
(gray-white),
gg
(gray-gray).
the
sampling
rate
fast
enough,
compared
the
speed
the
disk,
artifact
reading
do
not
take
place.
other
words,
least
one
sample
taken
every
time
the
disk
one
the
four
input
combination
another.
the
transmitted
input
the
device
the
directional

finite-state
machines
487
information.
example,
the
sensor
received
wg
(as
shown),
then
ww
awhile,
then
gw,
inferred
the
disk
rotating
clockwise.
the
other
hand,
sensed
gw
once
a
row,
conclude
the
disk
stopped.
make
no
other
definitive
inference,
the
device
indicate
previous
assessment.
describe
the
device
a
finite-state
transducer,
using
the
various
method
presented
the
text.
sensor
output
figure
205:
a
rotational
direction
detector
4
••
decide
the
wrist-watch
described
below
represented
a
classifier
a
transducer,
then
present
a
state-transition
diagram
it.
the
watch
a
chronograph
feature
controlled
three
buttons,
a,
b,
c.
three
display
modes:
the
time
day,
the
chronograph
time,
"split"
time,
a
saved
version
the
chronograph
time.
assume
the
initial
state,
the
watch
time
day.
button
c
pressed,
chronograph
time.
c
pressed
again,
displaying
time
day.
the
watch
displaying
chronograph
time
split
time,
pressing
a
start
the
chronograph.
pressing
b
the
chronograph
running
cause
the
chronograph
time
recorded
the
split
time
displayed.
pressing
b
again
displaying
the
chronograph.
pressing
b
the
chronograph
stopped
the
chronograph
time
0.
5
•••
a
certain
vending
machine
soft
drink
cost
$0.40.
the
machine
coin
denomination
$0.05,
$0.10,
$0.25.
sufficient
coin
deposited,
the
machine
a
drink
selected
the
appropriate
change.
considering
each
coin
deposit
the
depression
the
drink
button
inputs,
construct
a
state-transition
diagram
the
machine.
the
output
signal
vend
a
drink
return
coin
selected
denominations.
assume
once
the
machine
received
enough
coin
vend
a
drink,
the
vend
button
still
not
depressed,
any
additional
coin
just
returned
kind.
machine
handle
case
such
the
sequence
coin
10,
10,
10,
5,
25?

488
6
•••
finite-state
machines
consider
the
problem
controlling
traffic
an
intersection
such
shown
below.
legend
traffic
flow
direction
presence
sensor
traffic
traffic
light
cross
traffic
figure
206:
a
traffic
intersection
time
divided
equal-length
intervals,
sensor
sampling
the
presence
traffic
just
the
end
an
interval.
the
following
priority
rule
apply:
1.
no
traffic
present,
through-traffic
the
right-of-way.
2.
through-traffic
still
present
the
end
the
first
interval
through-traffic
the
right-of-way,
through-traffic
given
the
right-of-way
one
additional
interval.
3.
cross-traffic
present
the
end
the
second
consecutive
interval
through-traffic
the
right-of-way,
then
cross-traffic
given
the
right-of-way
one
interval.
4.
cross-traffic
present
through-traffic
absent,
cross-traffic
the
right-of-way
an
interval
through-traffic
appears,
then
through-traffic
given
the
right-of-way.
describe
the
traffic
controller
a
classifier
traffic
the
right-of-way.
7
•••
a
bar
code
bit
alternating
light
dark
bands.
the
light
band
uniform
width,
the
dark
band
width
equal
to,
double,
the
width
the
light
bands.
below
an
example
a
code-word
using
the
bar
code.
the
tick
mark
top
show
the
single
widths.

finite-state
machines
489
figure
207:
a
bar
code
scheme
assume
a
bar-code
reader
the
band
symbols,
l
light,
d
dark,
one
symbol
single
width.
thus
the
symbol
sequence
the
code-word
above
l
d
l
d
d
l
d
d
l
d
l
d
d
l
d
l
a
bar
pattern
a
binary
sequence
follows:
a
0
encoded
ld,
a
1
encoded
ldd.
a
finite-state
transducer
m
translate
a
code
binary.
the
output
alphabet
the
transducer
{0,
1,
_,
end}.
started
initial
state,
the
transducer
"idle"
as
long
only
l's.
first
d,
the
code
started.
the
transducer
give
output
0
1
soon
determined
the
next
bit
the
bar
pattern.
the
bit
not
known
yet,
give
output
_.
thus
the
input
sequence
above,
m
produce
_
_
0
_
1
_
_
1
_
_
0
_
1
_
_
0
l
d
l
d
d
l
d
d
l
d
l
d
d
l
d
l
repeated
the
input
the
output
convenience.
the
transducer
output
the
symbol
end
subsequently
two
l's
a
row,
point
return
initial
state.
a.
give
the
state
diagram
transducer
m,
assuming
only
sequence
the
indicated
form
occur
input.
b.
certain
input
sequence
not
occur,
e.g.
l
d
d
d.
give
a
state-transition
diagram
an
acceptor
a
only
the
sequence
corresponding
a
valid
bar
code.
8
••
a
gasoline
pump
gas
based
credit
card
other
input
the
customer.
the
general
sequence
events,
a
single
customer
is:
customer
credit
card
the
slot.
customer
pin
(personal
identification
number)
keypad,
appropriate
provision
canceling
an
error
made.
customer
grade
gasoline.

490
finite-state
machines
customer
nozzle.
customer
lift
pump
lever.
customer
squeeze
release
lever
nozzle
any
number
times.
customer
pump
lever
nozzle.
customer
not
a
receipt
wanted.
sketch
a
state
diagram
modeling
such
system
a
finite-state
machine.
inter-convertibility
transducer
classifier
(advanced)
describe
a
mathematical
relationship
classifier
transducers,
so
most
the
theory
developed
one
applicable
the
other.
one
possible
connection
is,
given
an
input
sequence
x,
record
the
output
corresponding
the
state
a
classifier
processing
x.
those
output
the
output
an
appropriately-defined
transducer.
however,
classifier
a
little
general
this
sense,
give
output
even
the
empty
sequence
λ,
the
output
a
transducer
input
λ
always
just
λ
.
let
work
term
the
following
equivalence:
a
transducer
t
started
state
q0
equivalent
a
classifier
c
started
state
q0
if,
any
non-empty
sequence
x,
the
sequence
output
emitted
t
the
same
the
sequence
output
the
state
c
passes.
this
definition
mind,
the
following
a
classifier
equivalent
the
edgedetector
transducer
presented
earlier.
0
f/arb
0
g0/0
1
1
1
h0/0
1
0
0
g1/1
0
1
h1/1
figure
208:
a
classifier
formally
equivalent
the
edge-detector
transducer

finite-state
machines
491
see
constructed
this
classifier,
observe
the
output
emitted
a
transducer
going
a
state
q
a
state
q',
given
an
input
symbol
σ,
the
same
the
output
attached
state
q'
the
classifier.
however,
can't
sure
all
transition
a
state
q'
a
transducer
produce
the
same
output.
example,
two
transition
state
g
the
edge-detector
produce
0
one
1,
similarly
state
h.
this
impossible
attach
a
fixed
input
either
g
h.
therefore
need
"split"
the
state
g
h
two,
a
version
0
output
a
version
1
output.
call
these
resulting
state
g0,
g1,
h0,
h1.
now
construct
an
output-consistent
classifier
the
transducer.
don't
need
split
f,
a
very
transient
character.
output
assigned
arbitrarily
spoiling
the
equivalence
the
two
machines.
the
procedure
converting
a
classifier
a
transducer
simpler.
the
classifier
state
q
q',
assign
the
output
transition
the
state
output
value
c(q').
the
following
diagram
a
transducer
equivalent
the
classifier
0,
1,
more
edges.
0/0
1/1
1/1
b
d
0/more
0/0
0,1/more
a
f
1/0
1/0
c
0/1
1/more
0/1
e
figure
209:
a
transducer
formally
equivalent
the
edge-counting
classifier
1
••
transducer
classifier,
chose
the
wrist-watch
problem
the
previous
exercises,
do
a
formal
conversion
the
other
model.
give
a
state-transition
graph
other
equivalent
representation
the
following
machines.
2
••
mb2
(multipy-by-two)
this
machine
a
transducer
binary
input
outputs,
least-significant
bit
first,
producing
a
numeral
twice
the
input.
that
is,
the
input
...x2x1x0
x0
input
first,
then
the
output
...
x2x1x00
0
output
first,
then
x0,
etc.
example:

492
finite-state
machines
input
0
01
011
01011
101011
0101011
first
bit
input
^
output
0
10
110
10110
010110
1010110
input
decimal
0
1
3
11
43
43
output
decimal
0
2
6
22
incomplete
86
notice
the
full
output
not
occur
a
step
the
input.
thus
need
input
a
0
wish
see
the
full
product.
this
machine
reproduce
the
input
delayed
one
step,
invariably
producing
a
0
the
first
step.
thus
this
machine
also
called
a
unit
delay
machine.
answer:
this
machine
"buffers"
one
bit
all
times,
anticipate
that
two
state
sufficient:
r0
"remembers"
the
last
input
0
r1
the
last
input
1.
the
output
always
the
state
the
transition,
i.e.
output
arc
r0
0
output
arc
r1
1.
the
input
always
the
machine
the
state
the
input
appropriately.
1/0
r1
r0
1/1
0/1
0/0
figure
210:
a
multiply-by-2
machine
3
••
mb2n
(multiply-by-2n,
n
a
fixed
natural
number)
(this
a
separate
problem
each
n.)
this
machine
a
transducer
binary
input
outputs,
least-significant
bit
first,
producing
a
numeral
2n
as
large
the
input.
that
is,
the
input
...x2x1x0
x0
input
first,
then
the
output
...
x2x1x00
0
output
first,
then
x0,
etc.
4
••
add1
this
machine
a
transducer
binary
input
outputs,
leastsignificant
bit
first,
producing
a
numeral
1
+
the
input.
answer:
the
state
this
machine
represent
the
value
"carried"
the
next
bit
position.
initially
1
"carried".
the
carry
"propagated"
as
long
the
input
bit
1.
an
input
bit
0
encountered,
the
carry
"absorbed"
1
output.
that
point,
the
input
just
replicated.

finite-state
machines
493
0/1
c0
c1
0/0
1/1
1/0
figure
211:
an
add-1
machine
5
••
w2
(within
2)
this
an
acceptor
input
alphabet
{0,
1}.
those
string
that
every
prefix
the
string,
the
difference
the
number
0's
the
number
1's
always
2.
example,
100110101
accepted
111000
not.
6
•••
add3
this
machine
a
transducer
binary
input
outputs,
leastsignificant
bit
first,
producing
a
numeral
3
+
the
input.
7
•••
add-n,
n
a
fixed
natural
number
(this
a
separate
problem
each
n.)
this
machine
a
transducer
binary
input
outputs,
leastsignificant
bit
first,
producing
a
numeral
n
+
the
input.
8
••
binary
adder
this
a
transducer
binary
input
occurring
pairs.
that
is,
the
input
alphabet
all
pairs
{0,
1}:
{(0,
0),
(0,
1),
(1,
0),
(1,
1)}.
the
input
interpreted
bit
two
binary
numerals,
least-significant
bit
first
as
the
previous
problem.
the
output
a
numeral
representing
the
sum
the
inputs,
also
least-significant
bit
first.
before,
need
input
a
final
(0,
0)
wish
see
the
final
answer.
input
(0,
0)
(0,
1)
(0,
0)(1,
1)
(0,
0)(1,
1)(0,
0)
(0,
0)(1,
1)(1,
1)
first
input
pair
^
output
0
1
10
100
110
decimal
value
input
output
0,
0
0
0,
1
1
1,
1
2
2,
2
4
3,
3
6
answer:
apparently
only
the
value
the
"carry"
remembered
one
state
the
next.
only
two
value
carry
possible,
this
two
state
adequate.

494
finite-state
machines
(1,
1)
/
0
c0
c1
(0,
0)
/
1
(0,
1)
/
0
(1,
0)
/
0
(1,
1)
/
1
(0,
0)
/
0
(0,
1)
/
1
(1,
0)
/
1
figure
212:
serial
binary
adder,
least-significant
bit
first
9
•••
mb3
(multiply-by-three)
similar
mb2,
the
input
multiplied
3.
example
decimal
value
input
output
input
output
0
0
0
0
01
11
1
3
010
110
2
6
001011
100001
11
33
note
two
final
0's
necessary
get
the
full
output.
why?
10
••••
mbn
(multiply-by-n,
n
a
fixed
natural
number)
(this
a
separate
problem
each
n.)
this
machine
a
transducer
binary
input
outputs,
least-significant
bit
first,
producing
a
numeral
n
the
input.
11
•••
binary
maximum
this
similar
the
adder,
the
input
occur
mostsignificant
digit
first
both
input
assumed
the
same
length
numeral.
decimal
value
input
output
input
output
(0,
0)
0
0,
0
0
(0,
1)
1
0,
1
1
(0,
1)(1,
1)
11
1,
3
3
(0,
1)(1,
1)(1,
0)110
3,
6
6
(1,
1)(1,
0)(0,
1)110
6,
5
6
^
first
input
pair
12
••
maximum
classifier
this
a
classifier
version
the
preceding.
three
possible
output
assigned
a
state:
{tie,
1,
2},
1
the
first
input
sequence
greater,
2
the
second
greater,
'tie'
the
two
input
equal
far.

finite-state
machines
495
input
(1,
1)
(1,
1)(0,
1)
(1,
1)(0,
1)(1,
1)
2
(1,
0)(0,
1)(1,
1)
1
class
tie
2
13
••
1db3
(unary
divisible
3)
this
an
acceptor
input
alphabet
{1}.
exactly
those
string
a
multiple
three
1's
(including
λ).
14
•••
2db3
(binary
divisible
3)
this
an
acceptor
input
alphabet
{0,
1}.
exactly
those
string
a
numeral
representing
a
multiple
3
binary,
least-significant
digit
first.
(hint:
simulate
the
division
algorithm.)
thus
the
accepted
string
include:
0,
11,
110,
1001,
1100,
1111,
10010,
...
15
•••
sequential
combination
(an
infinite
family
problems):
a
single
string
the
alphabet
called
the
"combination".
any
string
containing
this
combination
accepted
the
automaton
the
lock").
example,
the
combination
01101,
the
acceptor
is:
0,
1
1
1
0
a
0
b
1
c
1
1
0
d
0
e
f
0
figure
213:
a
combination
lock
state
diagram
the
tricky
thing
such
problem
the
construction
the
backward
arcs;
do
not
necessarily
go
back
the
initial
state
a
"wrong"
digit
entered,
only
back
the
state
result
the
longest
usable
suffix
the
digit
entered
so
far.
the
construction
achieved
the
"subset"
principle,
devising
an
algorithm
produce
the
state
diagram
any
given
combination
lock
this
done
a
string
matching
algorithm
known
the
"knuth-morris-pratt"
algorithm.
construct
the
state-diagram
the
lock
the
following
different
combinations:
1011;
111010;
010010001.
16
•••
assume
three
different
people
different
combination
the
same
lock.
each
combination
the
user
a
different
security
class.
construct
a
classifier
the
three
combination
the
previous
problem.

496
17
•••
finite-state
machines
the
preceding
lock
problem
assume
the
lock
open
the
combination
entered.
rework
the
example
the
problem
assuming
the
lock
more
digit
entered
the
correct
combination,
the
combination
again
entered.
12.2
finite-state
grammar
non-deterministic
machine
an
alternate
way
define
the
language
accepted
a
finite-state
acceptor
a
grammar.
this
case,
the
grammar
restricted
a
particular
form
production.
each
production
either
the
form:
n
→
σm
n
m
auxiliary
σ
a
terminal
symbol,
the
form
n→λ
recalling
λ
the
empty
string.
the
idea
auxiliary
symbol
identified
states.
the
start
state
the
start
symbol.
each
transition
an
acceptor
the
language,
the
form
q1
σ
q2
figure
214:
state
transition
corresponding
a
grammar
production
there
a
corresponding
production
the
form
q1
→
σq2
addition,
q2
an
accepting
state,
also
a
production
the
form.
q2
→
λ
example:
grammar
acceptor
acceptor
exactly
one
edge,
apply
these
two
rule
get
the
following
grammar
generating
all
string
one
edge:

finite-state
machines
497
the
start
state
a.
the
auxiliary
{a,
b,
c,
d,
e,
f}.
the
terminal
{0,
1}.
the
production
are:
a
→
0b
a
→
1c
b
→
0b
b
→
1d
d
→
0f
d
→
1d
d→λ
c
→
0e
c
→
1c
e
→
0e
e
→
1f
e→λ
f
→
0f
f
→
1f
see
the
grammar
the
1-edged
string
0011
example,
the
derivation
tree
is:
a
b
0
b
0
d
1
1
d
λ
figure
215:
derivation
tree
the
previous
finite-state
grammar,
deriving
the
1-edged
string
0011
easy
see
a
finite-state
grammar
derived
any
finite-state
the
converse
not
obvious.
difficulty
arise
production
the
same
lefthand-side
the
same
terminal
symbol
produced
the
right,
e.g.
a
grammar,
nothing
using
the
two
production
a
→
0b
a
→
0c
this
introduce
an
anomaly
the
state-transition
diagram,
given
input
symbol
0
state
a,
the
machine
not
know
state
go
next:

498
finite-state
machines
b
0
a
0
c
figure
216:
a
non-deterministic
transition
this
automaton
regarded
non-deterministic,
the
next
state
given
input
0
not
determined.
fortunately,
a
way
this
problem.
order
show
it,
first
define
the
notion
"acceptance"
a
non-deterministic
acceptor.
a
non-deterministic
acceptor
a
string
some
path
a
starting
state
an
accepting
state
a
sequence
arc
label
equal
that
string.
say
a
starting
state,
rather
the
starting
state,
a
non-deterministic
acceptor
allowed
multiple
starting
states.
useful
also
include
λ
transition
nondeterministic
acceptors.
these
arc
λ
label.
λ
the
empty
string,
these
arc
used
a
path
do
not
contributed
any
symbol
the
sequence.
example:
non-deterministic
deterministic
conversion
recall
a
string
the
language
generated
a
grammar
only
terminal
symbols.
suppose
the
production
a
grammar
(with
start
symbol
a,
terminal
alphabet
{0,
1}):
a
→
0d
b
→
1c
a
→
0b
b→1
d
→
0d
a→1
c
→
0b
d→1
the
language
defined
this
grammar
the
set
all
string
ending
1
either
exactly
one
1
consist
alternating
01.
the
corresponding
(non-deterministic)
automaton
is:

finite-state
machines
499
0
d
0
1
1
e
a
0
1
1
c
b
0
figure
217:
a
non-deterministic
automaton
the
set
all
string
ending
1that
exactly
one
1
consist
an
alternating
01's.
two
instance
non-determinism
identifiable
this
diagram:
the
two
0transitions
leaving
a
the
two
1-transitions
leaving
b.
nonetheless,
derive
this
diagram
a
corresponding
deterministic
finite-automaton.
the
derivation
result
the
deterministic
automaton
shown
below.
b
1
0
0
0
a
1
0
d
0
f
c
1
0
1
1
0
e
0,
1
o
0,
1
figure
218:
a
deterministic
automaton
the
set
all
string
ending
1
exactly
one
1
consist
an
alternating
01's.
derive
a
deterministic
automaton
d
the
non-deterministic
one
n
using
subset
the
state
n
state
d.
this
particular
example,
the
subset
association
follows:
a
~
{a}
b
~
{b,
d}
c
~
{c,
e}
d
~
{d}
e
~
{e}
f
~
{b}
o
~
{}

500
finite-state
machines
general
method
deriving
a
deterministic
acceptor
d
a
non-deterministic
one
n:
the
state
set
d
the
set
all
subset
n.
the
initial
state
d
the
set
all
initial
state
n,
together
state
reachable
initial
state
n
using
only
λ
transitions.
a
transition
a
set
s
a
set
t
d
label
σ
(where
σ
a
single
input
symbol).
t
=
{q'
|
a
q
s
a
sequence
transition
q
q'
corresponding
a
one
symbol
string
σ}
the
reason
say
sequence
due
the
possibility
λ
transitions;
these
do
not
add
any
new
symbol
the
string.
note
λ
not
regarded
an
input
symbol.
the
accepting
state
the
derived
acceptor
those
contain
least
one
accepting
state
the
original
acceptor.
essence,
this
method
"compile"
a
breadth-first
search
the
nondeterministic
state
graph
a
deterministic
finite-state
system.
the
reason
this
work
the
set
all
subset
a
finite
set
finite.
construct
deterministic
acceptor
corresponding
the
following
non-deterministic
acceptors,
the
alphabet
{0,
1}.
1•
a
0
b
2•
1
a
0
b
3
••
0
a
0
1
b
1
c

finite-state
machines
501
4
••
a
1
b
0
0
c
1
12.3
meaning
regular
expression
the
chapter
grammars,
already
a
good
idea
regular
expression
mean
already.
a
grammar
regular
expression
given
that
chapter,
purpose
giving
a
meaning
regular
expressions,
convenient
use
a
grammar
intentionally
ambiguous,
expressing
construct
pair
rather
sequences:
r
→
'λ'
r→∅
r
→
σ,
each
letter
σ
a
r→rr
//
juxtaposition
r→(r|r)
//
alternation
r
→
(r)*
//
iteration
resolve
the
ambiguity
the
grammar,
simply
"overlay"
the
grammar
some
convention
precedence.
the
standard
precedence
rule
are:
*
tightly
either
juxtaposition
|
juxtaposition
bind
tightly
|
now
wish
use
this
ambiguous
grammar
assign
a
meaning
regular
expressions.
each
expression
e,
the
meaning
e
a
language,
i.e.
set
strings,
the
alphabet
a.
define
this
meaning
recursively,
according
the
structure
the
grammar:
basis:
•
•
•
l(λ)
{λ},
the
set
consisting
one
string,
the
empty
string
λ.
l(∅)
∅,
the
empty
set.
each
letter
σ
a,
l(σ)
{
σ
},
the
set
consisting
one
string
one
letter,
σ.

502
finite-state
machines
induction
rules:
•
l(rs)
=
l(r)l(s),
the
latter
mean
the
set
all
string
the
form
the
concatenation
rs,
r
∈
l(r)
s
∈
l(s).
•
l(r
|
s)
=
l(r)
∪
l(s).
•
l(r*)
=
l(r)*
clarify
the
first
bullet,
any
two
language
l
m,
the
"set
concatenation"
lm
defined
{rs
|
r
∈
l
s
∈
m}.
is,
the
"concatenation”
two
set
string
the
set
all
possible
concatenations,
one
string
taken
the
first
set
another
taken
the
second.
example,
{0}{1}
defined
{01}.
{0,
01}{1,
10}
defined
{01,
010,
011,
0110}.
{01}{0,
00,
000,
...}
defined
{010,
0100,
01000,
...}.
explain
the
third
bullet,
need
define
the
*
operator
an
arbitrary
language.
l
a
language,
the
l*
defined
(using
the
definition
concatenation
above)
{λ}
∪
l
∪
ll
∪
lll
∪
...
is,
l*
all
string
formed
concatenating
zero
more
strings,
each
l.
regular
expression
example
alphabet
{a,
b,
c}
expression
a|b|c
λ
|
(a
|
b
|
c)
|
(a
|
b
|
c)(a
|
b
|
c)
set
denoted
the
set
1-symbol
string
{"a",
"b",
"c"}
the
set
string
two
fewer
symbol
a*
the
set
string
using
only
symbol
a
a*b*c*
the
set
string
no
a
a
b
no
a
b
a
c
(a
|
b)*
the
set
string
using
only
a
b.
a*
|
b*
the
set
string
using
only
a
only
b
(a
|
b
|
c)(a
|
b
|
c)(a
|
b
|
c)*
the
set
string
least
two
symbols.
((b
|
c)*
ab
(b
|
c)*)*
the
set
string
each
a
immediately
followed
a
b.
(b
|
c)*
|
((b
|
c)*
a
(b
|
c)
(b
|
c)*)*
(λ
|
a)
the
set
string
no
two
consecutive
a's.

finite-state
machines
503
regular
expression
finite
symbol
strings,
the
set
denote
finite
infinite.
infinite
set
arise
only
virtue
the
*
operator
(also
sometimes
called
the
kleene-star
operator).
identity
regular
expression
one
good
way
becoming
familiar
regular
expression
consider
some
identities,
equality
the
set
described
the
expressions.
here
some
examples.
the
reader
invited
discover
more.
any
regular
expression
r
s:
r|s=s|r
r
|∅=r
rλ
=
r
r∅=∅
λ*
=
λ
∅*
=
λ
r*
=
λ
|
rr*
(r
|
λ)*
=
r*
(r*)*
=
r*
∅|r=r
λr
=
r
∅r=∅
1
••
determine
not
the
following
valid
regular
expression
identities:
λ∅
=
λ
r
(s
|
t)
=
rs
|
rt
r*
=
λ
|
r*r
rs
=
sr
(r
|
s)*
=
r*
|
s*
r*r
=
rr*
(r*
|
s*)*
=
(r
|
s)*
(r*s*)
=
(r
|
s)*
any
n,
r*
=
λ
|
r
|
rr
|
rrr
|
....
|
rn-1
|
rnr*,
rn
an
abbreviation
rr....r.
n
2
•••
equation
involving
language
a
language
an
unknown
sometimes
solved
using
regular
operators.
example,
s
=
rs
|
t
solved
unknown
s
the
solution
s
=
r*t.
justify
this
solution.

504
finite-state
machines
3
•••
suppose
grammar
respectively
generate
l
m
languages.
show
use
these
grammar
form
a
grammar
each
the
following
language
l
∪
mlm
l*
regular
language
the
regular
operator
(|,
*,
concatenation)
applicable
any
languages.
however,
a
special
name
given
language
constructed
using
only
these
operator
language
consisting
a
single
string,
the
empty
set.
definition:
a
language
(set
string
a
given
alphabet)
called
regular
a
set
string
denoted
some
regular
expression.
(a
regular
language
also
called
a
regular
set.)
let
informally
explore
the
relation
regular
language
finite-state
acceptors.
the
general
idea
the
regular
language
exactly
characterize
set
path
the
initial
state
some
accepting
state.
illustrate
this
giving
an
acceptor
each
the
examples.
a,
b,
c
a,
b,
c
a,
b,
c
figure
219:
acceptor
a
|
b
|
c
a,
b,
c
a,
b,
c
a,
b,
c
a,
b,
c
figure
220:
acceptor
λ
|
(a
|
b
|
c)
|
(a
|
b
|
c)(a
|
b
|
c)
a
a,
b,
c
b,
c
figure
221:
acceptor
a*

finite-state
machines
505
a
c
b
b
a,
b,
c
a,b
c
a
c
figure
222:
acceptor
a*b*c*
a,
b
a,
b,
c
c
figure
223:
acceptor
(a
|
b)*
a
b,
c
a
a,
b,
c
c
b
b
a,
c
figure
224:
acceptor
a*
|
b*
a,
b,
c
a,
b,
c
a,
b,
c
figure
225:
acceptor
(a
|
b
|
c)(a
|
b
|
c)(a
|
b
|
c)*

506
finite-state
machines
a,
b,
c
b,c
a
a,c
b
a
b,c
figure
226:
acceptor
((b
|
c)*
ab
(b
|
c))*
see,
the
connection
regular
expression
finite-state
acceptor
rather
close
natural.
the
following
result
precise
the
nature
this
relationship.
kleene's
theorem
(kleene,
1956)
a
language
regular
iff
accepted
some
finite-state
acceptor.
the
"if"
part
kleene's
theorem
shown
an
algorithm
similar
floyd's
algorithm.
the
"only
if"
part
the
non-deterministic
deterministic
transformation.
the
language
accepted
a
finite-state
acceptor
regular
the
proof
the
following
constructive
method:
augment
the
graph
the
acceptor
a
single
distinguished
starting
node
accepting
node,
connected
λ-transitions
the
original
initial
state
accepting
state
the
manner
shown
below.
the
reason
this
step
isolate
the
property
initial
accepting
so
easily
apply
the
transformation
the
second
step.
original
finite-state
acceptor
λ
new
initial
state
λ
λ
original
initial
state
new
accepting
state
λ
original
accepting
state
figure
227:
modifying
acceptor
preparation
deriving
the
regular
expression

finite-state
machines
507
one
a
time,
eliminate
the
node
the
original
acceptor,
preserving
the
set
path
each
node
recording
an
appropriate
regular
expression
each
pair
other
nodes.
this
process
complete,
the
regular
expression
connecting
the
initial
state
the
accepting
state
the
regular
expression
the
language
accepted
the
original
finite-state
machine.
make
the
proof
complete,
describe
the
node
elimination
step.
suppose
prior
the
elimination,
the
situation
as
shown
below.
r
xz
x
r
z
r
yz
xy
y
r
yy
figure
228:
a
situation
the
graph
elimination
node
y
here
x
z
represent
arbitrary
node
y
the
node
eliminated.
a
variable
the
form
rij
the
regular
expression
path
i
j
using
node
previously
eliminated.
eliminating
y,
replace
the
previous
expression
rxz
a
new
expression
rxz
|
rxy
ryy*
ryz
the
rationale
here
rxz
the
path
there
before,
rxy
ryy*
ryz
the
path
went
the
eliminated
node
y.
x
r
|
r
r
*
r
xz
xy
yy
yz
z
figure
229:
the
replacement
situation
eliminating
node
y
the
catch
here
perform
this
updating
every
pair
node
x,
z,
including
the
case
x
z
the
same.
other
words,
m
node
left,
then
m2
regular
expression
update
done.
eliminating
each
n
node
then
o(n3
)
steps.
the
entire
elimination
process
very
similar
the
floyd
warshall
algorithm
discussed
the
chapter
complexity.
the
only
difference
here
dealing
the
domain
regular
expressions,
those
algorithm
dealt
the
domain
non-negative
real
number
bit
respectively.

508
finite-state
machines
prior
the
start
the
process,
perform
the
following
simplification:
any
state
no
accepting
state
reachable
eliminated,
arc
connecting
them.
example:
regular
expression
derivation
derive
a
regular
expression
the
following
finite-state
acceptor:
a
a,
b
b
b
b
1
2
a
3
4
a
figure
230:
a
finite-state
acceptor
a
regular
expression
derived
first
simplify
removing
node
4,
no
accepting
state
reachable.
then
augment
the
graph
two
new
nodes,
0
5,
connected
λ-transitions.
notice
some
pair
node
no
connection.
this
equivalent
the
corresponding
regular
expression
∅
.
∅
juxtaposed
another
regular
expression,
the
result
equivalent
∅.
similarly,
λ
juxtaposed
another
regular
expression
r,
the
result
equivalent
r
itself.
a
0
λ
1
b
λ
2
5
a
b
λ
3
b
figure
231:
the
first
step
deriving
a
regular
expression.
node
0
5
added.
now
eliminate
one
the
node
1
3,
say
node
1.
here
use
the
identity
λa*b
=
a*b.

finite-state
machines
509
aa*b
a
*b
λ
2
0
b
5
λ
3
b
figure
232:
removal
node
1
next
eliminate
node
2.
0
a
*b
(
aa*b
)*
a∗
b
(
aa∗b
)∗
b
5
λ
3
b
figure
233:
removal
node
2
finally
eliminate
node
3.
a
*
b
(aa
*b
)
*
0
|
a
*
b
(aa*
b)*
b
b*
5
figure
234:
removal
node
1
the
derived
regular
expression
a*b(aa*b)*
|
a*b(aa*b)*bb*

510
finite-state
machines
every
regular
language
accepted
a
finite-state
acceptor
already
know
construct
a
deterministic
finite-state
acceptor
equivalent
any
non-deterministic
one.
hence
adequate
show
derive
a
nondeterministic
finite-state
acceptor
a
regular
expression.
the
path
initial
node
accepting
node
the
acceptor
correspond
an
obvious
way
the
string
represented
the
regular
expression.
regular
expression
defined
inductively,
very
natural
this
proof
proceed
the
same
line
the
definition.
expect
a
basis,
corresponding
the
base
λ,
∅,
σ
(for
σ
each
a).
then
assume
an
acceptor
constructable
regular
expression
r
s
demonstrate
an
acceptor
the
case
rs,
r
|
s,
r*.
the
only
thing
slightly
tricky
connecting
the
acceptor
the
inductive
cases.
necessary
introduce
additional
state
order
properly
isolate
the
path
the
constituent
acceptors.
this
end,
stipulate
(i)
the
acceptor
constructed
always
a
single
initial
state
single
accepting
state.
(ii)
no
arc
directed
some
state
the
initial
state
call
these
property
p.
basis:
the
acceptor
λ,
∅,
σ
(for
σ
each
a)
as
shown
below:
figure
235:
acceptor
∅
property
p
λ
figure
236:
acceptor
λ
(the
empty
sequence)
property
p
σ
figure
237:
acceptor
σ
(where
σ
∈a)
property
p

finite-state
machines
511
induction
step:
assume
acceptor
r
s,
property
p
above,
constructed,
single
initial
accepting
state
as
indicated
the
left
right,
respectively.
r
s
figure
238:
acceptor
assumed
exist
r
s
respectively,
property
p
then
each
the
case
above,
construct
new
acceptor
accept
the
same
language
property
p,
now
shown:
r
s
λ
formerly
now
non-accepting
figure
239:
acceptor
rs,
property
p
r
λ
λ
s
λ
λ
figure
240:
acceptor
r
|
s,
property
p

512
finite-state
machines
λ
r
λ
λ
λ
figure
241:
acceptor
r*,
property
p
regular
expression
unix
program
egrep
one
several
unix
tool
use
some
form
regular
expression
pattern
matching.
other
such
tool
ed,
ex,
sed,
awk,
archie.
the
notation
appropriate
each
tool
differ
slightly.
possible
usage:
egrep
regular-expression
filename
the
file
line-by-line
line
containing
string
matching
the
regular-expression
print
those
lines.
the
scan
anew
each
line.
the
following
description,
'character'
excluding
the
newline
character:
a
single
character
not
otherwise
endowed
special
meaning
that
character.
example,
'x'
the
character
x.
the
character
'.'
any
character.
a
regular
expression
followed
an
*
(asterisk)
a
sequence
0
more
match
the
regular
expression.
effectively
a
regular
expression
used
searching
preceded
followed
an
implied
.*,
meaning
any
sequence
character
the
string
interest
exist
the
line.
exclude
such
sequences,
use
^
$:
the
character
^
the
beginning
a
line.
the
character
$
the
end
a
line.
a
regular
expression
followed
a
+
(plus)
a
sequence
1
more
match
the
regular
expression.
a
regular
expression
followed
a
?
(question
mark)
a
sequence
0
1
match
the
regular
expression.

finite-state
machines
513
a
\
followed
a
single
character
other
newline
character.
this
used
escape
the
special
meaning
given
some
characters.
a
string
enclosed
bracket
[]
any
single
character
the
string.
range
ascii
character
code
abbreviated
as
a-z0-9,
all
character
the
range
a-z
0-9.
a
literal
-
a
context
placed
after
\
can't
mistaken
a
range
indicator.
two
regular
expression
concatenated
match
a
match
the
first
followed
a
match
the
second.
two
regular
expression
separated
by
|
newline
match
a
match
the
first
a
match
the
second.
a
regular
expression
enclosed
parenthesis
a
match
the
regular
expression.
the
order
precedence
operator
the
same
parenthesis
level
[]
then
*+?
then
concatenation
then
|
newline.
care
taken
using
the
character
$
*
[
]
^
|
(
)
\
the
expression
also
meaningful
the
various
shells.
safest
enclose
the
entire
expression
argument
single
quotes.
examples:
unix
regular
expression
description
line
selected
regular
expression
qu
containing
the
letter
qu
combination
^qu
beginning
qu
az$
ending
az
^qu.*az$
beginning
qu
ending
az
uq|qu
containing
the
letter
qu
uq
a.*a
containing
two
more
a's
a
row
i.*i.*i.*i
containing
four
more
i's
[ai].*[ai].*[ai].*[ai].*[ai]
containing
five
more
a's
i's
(ai).*(ai)
containing
ai
least
twice
(uq|qu).*(uq|qu)
containing
uq
qu
least
twice
construct
deterministic
finite-state
acceptor
the
following
regular
expressions:
1•
0*1*
2•
(0*1*)*

514
finite-state
machines
3
••
(01
|
011)*
4
••
(0*
|
(01)*)*
5
••
(0
|
1)*(10110)(0
|
1)*
6
•••
the
regular
operator
concatenation,
union
(
|
),
the
*
operator.
any
combination
regular
language
using
these
operator
a
regular
language,
say
the
regular
language
closed
the
regular
operators.
intersection
complementation
(relative
the
set
all
strings,
σ
*)
not
included
the
regular
languages,
the
regular
language
closed
these
operator
well.
show
this
true,
using
the
connection
regular
language
finite-state
acceptors.
7
•••
devise
a
method
determining
not
two
regular
expression
denote
the
same
language.
8
••••
construct
a
program
input
a
regular
expression
output
a
program
the
language
denoted
that
regular
expression.
9
•••
give
a
unix
regular
expression
line
containing
floating-point
numerals.
12.4
synthesizing
finite-state
machines
logical
element
now
wish
extend
technique
the
implementation
function
finite
domain
term
logical
element
implementing
finite-state
machines.
one
reason
this
important
digital
computer
constructed
collection
finite-state
machine
interconnected
together.as
already
stated,
the
input
sequence
finite-state
machine
element
an
infinite
set
σ*,
σ
the
input
alphabet.
the
output
the
propositional
function
studied
simply
a
combination
the
input
those
function
called
combinational,
distinguish
the
more
general
function
σ*,
called
sequential.
show
the
implementation
machine
decomposed
combinational
function
memory
elements,
as
suggested
the
equation
sequential
function
=
combinational
function
+
memory
recall
the
structural
diagram
transducer
classifiers,
shown
"feedback"
systems.
note
these
two
diagram
share
a
common
essence,
namely
the
next-state
portion.
initially,
focus
just
this
portion
implemented.
the
rest
the
machine
relatively
simple
add.

finite-state
machines
515
next-state
function
f
input
∆
delay
memory
figure
242:
the
essence
finite-state
machine
structure
implementation
using
logic
element
"implement"
a
diagram,
clearer
item
correspond
change
input,
output,
state.
the
combinational
logical
elements,
such
andgates
or-gates,
as
discussed
abstraction
physical
devices.
those
devices,
the
logical
value
0
1
interpretation
physical
states.
the
output
a
device
a
function
inputs,
some
qualification.
no
device
change
state
instantaneously.
the
input
value
first
presented,
the
device's
output
a
different
state
indicated
the
function.
some
delay
time
switching
time
associated
the
device
elapse
the
output
the
value
prescribed
the
function.
thus,
each
device
an
inherent
sequential
behavior,
even
choose
think
a
combinational
device.
example
consider
a
2-input
and-gate.
suppose
a
device
this
gate
due
able
give
logical
value
two
voltages,
say
lo
hi,
correspond
0
1
respectively.
then,
observed
time,
see
the
following
behavior
the
gate
response
changing
inputs.
the
arrow
the
diagram
indicate
a
causal
relationship
the
input
change
output
changes.
note
always
some
delay
associated
these
changes.
hi
input
a
lo
hi
input
b
lo
hi
output
lo
time
figure
243:
sequential
behavior
an
and-gate

516
finite-state
machines
modeling
the
sequential
behavior
a
device
complex.
computer
designer
deal
an
abstraction
the
behavior
the
output
only
change
specific
instants.
this
reasoning
behaviors.
the
abstract
view
the
and-gate
shown
above
obtained
straightening
all
the
change
the
input
outputs,
make
appear
as
instantaneous.
hi
input
a
lo
hi
input
b
lo
hi
output
lo
time
figure
244:
an
abstraction
the
sequential
behavior
an
and-gate
quantization
clock
order
implement
a
sequential
machine
logic
necessary
select
a
scheme
quantizing
the
value
the
signal.
suggested
the
preceding
diagram,
the
signal
change
continuously.
the
other
hand,
the
finite-state
machine
abstraction
a
series
discrete
input
output
values.
example,
look
input
a
the
preceding
diagram,
do
say
the
corresponding
sequence
0101
based
just
the
input
changes?
the
case,
the
input
corresponding
sequence
00110011?
other
words,
do
know
a
value
high
some
time
a
single
1
a
series
1's?
the
common
mean
resolving
this
issue
use
a
system-wide
clock
a
timing
standard.
the
clock
"ticks"
regular
intervals,
the
value
a
signal
sampled
this
tick
occurs.

finite-state
machines
517
the
effect
using
a
clock
superimpose
a
series
tick
mark
the
signal
agree
the
discrete
valued
signal
correspond
the
value
the
tick
marks.
obviously
this
the
discrete
interpretation
the
signal
the
clock
interval.
example,
one
quantization
the
above
signal
shown
follows:
hi
01001
input
a
lo
hi
01101
input
b
lo
hi
01101
output
lo
time
figure
245:
and-gate
behavior
one
possible
clock
quantization
corresponding
the
five
ticks,
the
first
input
sequence
01001,
the
second
01101,
the
output
sequence
01101.
notice
the
output
not
quite
the
and
function
the
two
inputs,
expected.
this
due
the
fact
the
second
output
change
about
take
place
the
clock
ticked
the
previous
output
value
carried
over.
generally
avoid
this
kind
phenomenon
designing
such
the
change
take
place
tick
each
tick
the
signal
are,
the
moment,
stable.
the
next
figure
the
same
signal
a
slightly
wider
clock
interval
superimposed.
this
instance,
no
change
straddle
the
clock
ticks,
the
input
output
sequence
appear
predicted
the
definition
the
function.

518
finite-state
machines
0101
hi
input
a
lo
hi
0101
input
b
lo
hi
0101
output
lo
time
figure
246:
and-gate
behavior
wider
quantization
flip-flop
clock
stated
above,
order
maintain
the
effect
instantaneous
change
really
no
such
thing,
the
input
gate
only
sampled
specific
instants.
using
the
value
the
sample,
rather
the
true
signal,
approach
the
effect
desired.
order
hold
the
value
the
sample
one
instant
the
next,
a
memory
device
known
a
d
flip-flop
used.
the
d
flip-flop
two
different
kind
inputs:
a
signal
input
a
clock
input.
the
clock
"ticks",
represented,
say,
the
rising
edge
a
square
wave,
the
signal
input
sampled
held
the
next
tick.
other
words,
the
flip-flop
"remembers"
the
input
value
the
next
tick;
then
the
value
that
time.

finite-state
machines
519
hi
signal
input
lo
hi
clock
lo
output
time
figure
247:
d
flip-flop
behavior:
the
output
the
flip-flop
change
only
response
the
rising
edge
the
clock,
reflect
the
value
the
signal
input
that
time.
note
the
signal
input
change
clock
ticks,
not
changing
the
same
time.
a
phenomenon
known
"meta-stability"
result,
upset
the
abstraction
presented.
say
more
this
later.
clock-based
design
called
synchronous
design.
this
not
the
only
form
design,
certainly
the
most
prevalent,
least
99%
computer
design
based
this
model.
indicate
more
the
reason
this
later,
now,
synchronous
design
the
mode
concentrate.
synchronous
design,
the
input
a
device
output
flip-flops,
change
the
clock
ticks.
example,
the
following
diagram
an
andgate
the
context
d
flip-flop
controlled
a
common
clock.
the
input
a
b
not
shown.
however,
assume
change
clock
tick
thus
the
output
a
b
change
right
the
clock
tick,
as
the
output
c.
a
c
b
clock
figure
248:
an
and-gate
a
synchronous
system.
input
the
flip-flop
output
a
b
not
shown.

520
finite-state
machines
the
next
diagram
a
sample
behavior
the
and-gate
a
synchronous
system.
this
compared
the
abstracted
and-gate
presented
earlier,
verify
that
synchronous
design
the
abstract
behavior.
input
a
input
b
output
clock
output
time
figure
249:
example
behavior
the
and-gate
a
synchronous
system.
note
the
output
only
right
the
rising
edge
the
clock.
the
assumption
synchronous
design
the
input
a
device
held
constant
each
clock
interval.
the
interval
the
device
an
opportunity
change
the
value
represented
logical
function.
fact,
the
length
the
interval
chosen
a
way
the
device
achieve
this
value
the
end
the
interval.
the
end
the
interval,
the
output
the
device
thus
stabilized.
then
used
the
input
some
other
device.
closing
the
loop
the
previous
example
an
and-gate
the
context
three
flip-flop
thought
a
simple
sequential
machine.
the
state
the
machine
held
the
output
flip-flop
c.
thus,
the
current
state
always
the
logical
the
input
the
previous
clock
tick.
general,
the
state
a
function
not
just
the
inputs,
also
the
previous
state.
this
accomplished
using
the
output
the
state
flip-flop
drive
the
next

finite-state
machines
521
state.
an
example
obtained
modifying
the
previous
example
shown
below.
here
connect
the
output
c
the
place
the
input
a
was.
initially
1
c
b
clock
figure
250:
a
sequential
machine
b
ever
0
suppose
observe
this
machine
a
point
the
output
flip-flop
c
1.
the
next
clock
tick,
b
1,
then
the
flip-flop
stay
1.
however,
b
0,
then
the
flip-flop
switched
0.
flip-flop
c
0,
stay
there
forever,
no
input
value
anded
0
ever
give
1.
the
following
diagram
a
possible
behavior.
input
b
hi
lo
output
and
hi
lo
clock
hi
output
lo
figure
251:
example
behavior
the
previous
sequential
machine
the
timing
diagram
above
only
one
possible
behavior.
capture
all
possible
behaviors,
need
use
the
state-transition
diagram,
shown
below.
again,
the
state
this
case
the
output
flip-flop
c.

522
finite-state
machines
0
0
1
0
1
1
figure
252:
the
state
diagram
a
machine
ever
saw
0
the
state-transition
structure
this
machine
the
same
as
a
transducer
1
a
binary
representation,
least-significant-bit-first:
0/1
c1
c0
0/0
1/1
1/0
figure
253:
the
add-1
transducer
giving
the
general
method
synthesizing
the
logic
a
state-transition
give
a
couple
more
example
structure
function.
sequential
binary
adder
example
this
the
essence
the
sequential
binary
adder
a
pair
numeral
together,
least-significant
bit
first.
state
the
carry.
present
the
full
transducer
the
abstracted
state-transition
behavior.
(1,
1)
/
0
c0
(0,
1)
/
0
(1,
0)
/
0
(1,
1)
/
1
c1
(0,
0)
/
1
(0,
0)
/
0
(0,
1)
/
1
(1,
0)
/
1
(1,
1)
c0
c1
(0,
0)
(0,
1)
(1,
0)
(1,
1)
(0,
0)
(0,
1)
(1,
0)
figure
254:
transducer
state-transition
behavior
the
binary
adder

finite-state
machines
523
the
machine
2
input
used
parallel,
one
each
bit
the
two
addends.
assuming
represent
the
carry
the
1
0
value
the
output
the
structure
the
adder
realized
follows:
a
c
c
m
b
clock
figure
255:
state-transition
implementation
the
binary
adder
the
box
marked
m
the
majority
combination
function,
as
given
the
following
table:
a
0
0
0
0
1
1
1
1
b
0
0
1
1
0
0
1
1
c
0
1
0
1
0
1
0
1
f
0
0
0
1
0
1
1
1
see,
the
output
function
m
1
iff
least
two
three
input
1.
these
combinations
described
giving
the
minterm
form,
the
simplified
form:
f(a,
b,
c)
=
ab
+
ac
+
bc

524
finite-state
machines
implement
this
m
using
and-
or-
gates,
the
result
appear
as:
a
b
c
c
clock
figure
256:
the
binary
adder
state-transition
behavior
implemented
using
combinational
gate
a
flip-flop
combination
lock
example
this
example,
a
combination
lock
combination
01101,
given
earlier:
0,
1
1
1
0
a
0
b
1
c
1
0
d
0
e
1
0
figure
257:
combination
lock
state
transition
suppose
encode
the
state
using
three
flip-flops,
u,
v,
w,
follows:
state
name
a
b
c
d
e
f
u
0
0
0
0
1
1
flip-flop
v
0
0
1
1
0
1
w
0
1
0
1
0
1
f

finite-state
machines
525
the
tabular
form
the
state-transition
function:
current
state
a
b
c
d
e
f
next
state
a
function
input
0
1
b
a
b
c
b
d
e
a
b
f
f
f
transcribe
the
table
substituting
(e.g.
using
a
text
editor)
flip-flop
value
each
state.
this
the
same
process
used
implementing
combinational
logic
functions.
current
uvw
000
001
010
011
100
111
next
uvw
a
function
input
0
1
001
000
001
010
001
011
100
000
001
111
111
111
each
flip-flop,
derive
the
next-state
term
the
current
one
simply
separating
this
table:
current
uvw
000
001
010
011
100
111
next
u
a
function
input
0
1
0
0
0
0
0
0
1
0
0
1
1
1
letting
x
represent
the
input,
this
table,
see
that
next
u
=
u'vwx'
+
uv'w'x
+
uvwx'
+
uvwx
(using
the
minterm
form),but
a
simpler
version
derived
considering
"don't
cares"
is:
next
u
=
vwx'
+
ux

526
finite-state
machines
next
v
a
function
input
0
1
0
0
0
1
0
1
0
0
0
1
1
1
current
uvw
000
001
010
011
100
111
this
table,
derive:
next
v
=
u'v'wx
+
u'vw'x
+
uv'w'x
+
uvw
current
uvw
000
001
010
011
100
111
next
w
a
function
input
0
1
1
0
1
0
1
1
0
0
1
1
1
1
this
table,
derive
the
simplified
form:
next
w
=v'x'
+
vw'
+
u
putting
these
together,
realize
the
combination
lock
shown
the
next
page.
12.5
procedure
implementing
a
state-transition
function
implement
a
state-transition
function
a
finite-state
machine
term
combinational
logic
flip-flops:
1.
choose
encodings
the
input
alphabet
σ
the
state
set
q.
2.
transcribe
the
table
the
state-transition
function
f:
q
x
σ
→
q
propositional
logic
function
using
the
selected
encodings.
3.
implement
the
transcribed
f
function
logical
element
4.
the
function
thus
implemented
used
input
a
bank
d
flip-flops,
one
bit
the
state
encoding.

finite-state
machines
527
inclusion
output
function
order
synthesize
a
finite-state
machine
output,
need
augment
the
statetransition
implementation
an
output
function
implementation.
fortunately,
the
output
function
simply
a
combinational
function
the
state
(in
the
case
a
classifier
acceptor)
the
state
input
(in
the
case
a
transducer).
example:
inclusion
output
the
combination
lock
example
see
the
lock
only
state
f.
equating
acceptance
an
output
1,
see
the
lock
a
1
output
only
uvw
=
1.
therefore,
need
only
add
an
and-gate
input
all
three
flip-flop
get
the
acceptor
output.
the
complete
lock
shown
below.
x
w
v
u
next
u
=
vw
+
ux
u
next
v
=
u'v'wx
+
u'vw'x
+
uv'w'x
+
uvwx
v
next
w
=
v'x'
+
vw'
+
u
w
figure
258:
implementation
a
combination
lock
using
flip-flop
gate

528
finite-state
machines
example:
binary
adder
output
the
binary
adder
an
example
a
transducer.
the
output
value
1
the
one
three
the
two
input
the
carry
1.
none
two
those
value
1,
the
output
0.
this
functionality
represented
a
3-input
exclusive-or
gate,
as
shown
the
figure,
this
gate
also
implemented
using
and-,
or-,
not-
gate
always.
typically
the
output
used
input
a
system
this
machine
embedded.
a
b
c
c
clock
output
figure
259:
implementation
a
sequential
binary
adder
12.6
flip-flop
keeping
desire
show
a
relatively
complete
vertical
picture
computer
structure,
briefly
go
the
construction
flip-flop
themselves.
flip-flop
constructed
combinational
logic,
assuming
that
such
logic
a
delay
input
change
output
changes,
all
physical
device
do.
flip-flop
constructed
a
component
the
memory
aspect,
coupled
additional
logic
handle
clocking.
the
memory
aspect
alone
often
referred
a
latch
"latches"
the
last
value
appropriately
signaled
it.

finite-state
machines
529
a
first
approximation,
a
latch
constructed
two
gates,
shown
below.
s
r
q'
q
figure
260:
an
electronic
latch
opposing
nor-gates
order
the
latch
function
properly,
the
input
controlled
a
specific
discipline;
this
level,
no
clock
help
out.
let
the
state
the
latch
represented
srqq'.
normally
q
q'
complementary,
time
not.
consider
the
state
srqq'
=
0010.
here
say
the
latch
"set".
the
similar
state
0001,
the
latch
"reset".
the
function
the
input
s
r
put
the
latch
one
these
two
states.
specifically,
s
raised
1,
the
latch
change
the
set
state,
stay
the
set
state
already
there.
similarly,
r
raised
1,
the
latch
change
the
reset
state.
the
input
raised
lowered
again,
the
latch
supposed
stay
current
state.
first
verify
the
set
reset
state
stable,
i.e.
not
tending
change
own.
0010,
the
input
the
top
gate
01,
making
the
output
0.
this
the
value
q'
0010.
likewise,
the
input
the
bottom
gate
00,
making
the
output
1.
this
the
value
q
0010.
therefore
0010
stable.
similarly,
see
that
0001
also
stable.
now
consider
the
latch
0010
(set)
r
raised.
then
state
0110.
the
upper
gate's
output
not
tend
change
this
point.
however,
the
lower
gate's
output
driven
0,
i.e.
q
change
1
0.
following
this,
the
upper
gate's
output
driven
1,
so
q'
change
0
1.
now
the
latch
state
0101.
see
this
stable.
r
now
lowered,
state
0001,
already
observed
stable.
summary,
raising
r
sufficiently
long,
then
lowering
it,
result
the
reset
state.
also,
the
latch
state
0001
r
raised,
then
no
change
take
place
the
latch
stay
state
0001
r
lowered.
similarly,
see
raising
s
momentarily
the
latch
state
0010.
s
r
identified
the
function
setting
resetting
the
latch,
respectively.
thus
the
latch
called
a
set-reset
sr
latch.
the
following
state
diagram
the
behavior
discussed,
stable
state
circled
transient
state
left
uncircled.

530
finite-state
machines
srqq'
s
0010
q
r:
0
→
1
s:
0
→
1
s:
1
→
0
0110
1010
q'
r
0100
1000
output
1001
r:
0
→
1
0101
r:
1
→
0
s:
0
→
1
0001
figure
261:
state-transition
behavior
the
electronic
latch.
states
not
outlined
(1000,
0100)
unstable
tend
make
autonomous
transition
stable
state
shown.
describing
the
latch
behavior,
dealt
the
case
only
one
r
s
changing
a
time.
this
a
constraint
the
latch
assumed
operate.
this
condition
not
maintained,
then
the
latch
not
necessarily
behave
a
predictable
fashion.
invite
explore
this
the
exercises.
next
show
a
latch
a
flip-flop
adding
the
clock
element.
a
first
approximation,
a
flip-flop
a
latch
some
added
gate
one
s
r
only
activated
the
clock
raised.
this
approximation
shown
below.
however,
do
not
yet
a
true
flip-flop,
only
a
clocked
latch,
also
called
a
transparent
latch.
the
reason
this
hedging
the
input
the
unit
changed
the
clock
high,
the
latch
change.
contrast,
assumption
a
d
flip-flop,
the
flipflop
supposed
only
change
depending
the
value
the
input
the
leading
edge
the
clock,
i.e.
the
flip-flop
supposed
edge-triggered.

finite-state
machines
531
clocking
component
latching
component
d
_
q
clk
q
figure
262:
a
"transparent"
d
latch
order
get
edge
triggering,
need
latch
the
input
the
time
the
clock
rises,
then
desensitize
the
latch
further
change
the
clock
high.
this
typically
done
using
a
circuit
a
more
complex
clocking
component,
such
the
one
below.
the
assumption
made
here
the
d
input
held
constant
long
enough
the
clock
high
the
flip-flop
the
left-hand
side
stabilize.
clk
q
_
q
d
figure
263:
edge-triggered
d
flip-flop
using
nand
gate
1•
explain
own
word
raising
lowering
s
change
the
latch
0010.
2
••
explore
the
state
transition
behavior
state
not
shown
the
diagram,
particular
the
state
1100.
3
•••
using
a
state
diagram,
verify
the
edge-triggered
d
flip-flop
indeed
edgetriggered.

532
finite-state
machines
12.7
the
progression
computer
already
seen
hint
the
relationship
finite-state
machine
computers.
example,
the
control
unit
a
turing
machine
very
much
a
finite-state
transducer.
these
notes,
use
the
"classifier"
variety
finite-state
machine
act
controller
computers,
introducing
a
type
design
known
register-transfer
level
(rtl).
there,
easy
explain
the
working
a
stored-program
computer,
the
primary
medium
program
commonly
run.
representing
state
computer
explicitly,
as
called
state
diagram
tables,
yield
state
set
too
large
practically
manageable.
not
only
the
number
state
too
big
fit
the
memory
a
computer
usable
a
tool
analyzing
such
finite-state
also
impossible
a
human
understand
the
working
a
machine
based
explicit
representation
states.
therefore
turn
method
combine
finite-state
machine
data
operation
a
higher
level.
a
larger
sequential
adder
a
machine
up,
modulo
16,
a
sequence
number
the
range
0
15,
each
represented
binary.
a
machine
depicted
below.
input
sequence
1
5
3
7
8
...
state
sequence
0
1
6
9
0
8
...
figure
264:
sequence
adding
machine,
modulo
16
show
the
state
transition
function
this
machine
explicitly.
look
the
following
large
addition
table:

finite-state
machines
533
next
state
current
state
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
0
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
1
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
0
2
2
3
4
5
6
7
8
9
10
11
12
13
14
15
0
1
3
3
4
5
6
7
8
9
10
11
12
13
14
15
0
1
2
4
4
5
6
7
8
9
10
11
12
13
14
15
0
1
2
3
5
5
6
7
8
9
10
11
12
13
14
15
0
1
2
3
4
6
6
7
8
9
10
11
12
13
14
15
0
1
2
3
4
5
input
7
8
7
8
8
9
9
10
10
11
11
12
12
13
13
14
14
15
15
0
0
1
1
2
2
3
3
4
4
5
5
6
6
7
9
9
10
11
12
13
14
15
0
1
2
3
4
5
6
7
8
10
10
11
12
13
14
15
0
1
2
3
4
5
6
7
8
9
11
11
12
13
14
15
0
1
2
3
4
5
6
7
8
9
10
12
12
13
14
15
0
1
2
3
4
5
6
7
8
9
10
11
13
13
14
15
0
1
2
3
4
5
6
7
8
9
10
11
12
14
14
15
0
1
2
3
4
5
6
7
8
9
10
11
12
13
15
15
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
chose
a
much
larger
modulus
16
the
state
table
correspondingly
larger,
growing
the
square
the
modulus.
however,
the
basic
principle
remain
the
same.
show
this
principle
using
a
diagram
the
finite-state
machine
diagram:
adder
input
∆
state
=
accumulated
value
figure
265:
diagram
the
sequence
adder.
the
adder
box
two
number
together
before,
implement
the
adder
term
combinational
logic
the
state
term
a
bank
d
flip-flops.
the
combination
logic
this
recognized
the
adder
module
introduced
proposition
logic.

534
finite-state
machines
input
adder
d
flip-flop
clock
figure
266:
the
sequence
adder
the
next
level
detail
now
return
diagram
the
sequence
adder.
computer
common
group
flip-flop
holding
an
encoded
value
together
call
a
register,
as
suggested
the
following
figure.

finite-state
machines
535
d
flip-flop
register
input
=
input
clock
clock
figure
267:
expansion
a
4-bit
register
every
time
the
clock
the
current
logical
value
the
input
side
stored
(or
"gated
into")
the
flip-flops.
this
a
register
minimum
functionality.
usually
other
function
present.
example,
often
want
selectively
gate
information
the
register.
this
accomplished
controlling
not
the
flip-flop
"see"
the
clock
tick.
this
done
simply
using
an
and-gate.
the
control
line
known
a
"strobe":
the
strobe
1
the
clock
the
external
value
gated
the
register.
the
strobe
0,
the
register
previous
state.
note
a
register
essentially
a
(classifier)
finite-state
machine
just
last
datum
input.
example,
suppose
a
register
constructed
two
flipflops.
then
the
state
diagram
this
machine
is:
00
00
01
01
00
00
10
00
10
10
01
10
11
01
11
01
11
11
10
11
figure
268:
state-transition
diagram
a
2-bit
register.
each
input
the
machine
a
state
matching
the
input.
a
typical
use
this
selective
gating
selective
transfer
one
register
another.
the
situation
shown
below.

536
finite-state
machines
register
a
register
b
d
flip-flop
strobe
input
transfer
clock
clock
don't
transfer
clock
figure
269:
transferring
one
register
another
using
a
strobe
a
similar
fashion,
the
output
any
combinational
unit
gated
selectively
a
register.
typically,
the
gate
the
strobe
considered
part
the
register
itself.
this
case,
the
view
the
register
a
finite
state-machine
the
strobe
one
the
inputs.
the
strobe
value
1,
the
transition
as
shown
the
previous
state
diagram.
the
strobe
value
0,
the
transition
the
current
state.
ultra-highspeed
designs,
strobing
the
clock
this
way
not
desirable,
an
extra
gate
delay.
possible
avoid
this
defect
the
expense
a
complicated
register
design.
not
go
the
detail
here.
composition
finite-state
machines
a
computer
the
kind
buy,
rather
an
abstract
computer
a
turing
machine,
essentially
a
very
large
finite-state
machine.
order
understand
the
behavior
a
machine,
resort
a
modular
decomposition.
hope
enumerate
the
state
even
a
simple
computer,
even
use
the
resource
the
universe.

finite-state
machine
537
several
fundamental
way
compose
finite-state
machines.
each
case,
the
overall
machine
state
set
a
subset
the
cartesian
product
the
state
the
individual
machines.
consider
first
the
parallel
composition
two
machines,
shown
below.
m
c
n
figure
270:
parallel
composition
machine
m
n
the
two
machine
share
a
common
input.
go
transition
"lock
step"
according
the
clock.
unit
c
combinational
logic
the
output
produced
the
machine
not
memory
own.
the
structure
this
machine
the
individual
machines,
let's
show
something
interesting:
the
intersection
two
regular
language
regular.
the
union
two
regular
languages,
statement
not
follow
directly
the
definition
regular
expressions.
show
using
the
parallel
composition
notion.
let
m
n
the
machine
accepting
the
two
language
question.
see
a
parallel
composition
made
accept
the
intersection.
unit
c
this
case
form
the
logic
product
the
output
the
machines,
so
the
overall
machine
a
string
when,
only
when,
component
machine
accept.
this
is,
all,
the
definition
intersection.
example:
parallel
composition
consider
two
acceptor
used
example
earlier.
a,
b
1
a,
b
a,
b
2
figure
271:
acceptor
a
|
b
3

538
finite-state
machines
a
4
a,
b
5
b
figure
272:
acceptor
a*
make
an
acceptor
the
intersection
these
two
regular
languages,
construct
a
machine
state
set
the
product
{1,
2,
3}
x
{4,
5}
=
{(1,
4),
(1,
5),
(2,
4),
(2,
5),
(3,
4),
(3,
5)}.
not
actually
use
all
these
states,
some
not
reachable
the
initial
state,
(1,
4)
(the
pair
initial
state
each
machine).
just
accepting
state,
(2,
4),
the
only
one
both
component
accepting.
the
following
transition
occur
the
product
machine:
state
(1,
4)
(2,
4)
(2,
5)
(3,
4)
(3,
5)
input
a
b
(2,
4)
(2,
5)
(3,
4)
(3,
5)
(3,
5)
(3,
5)
(3,
4)
(3,
5)
(3,
5)
(3,
5)
see
one
state
the
product,
namely
(1,
5),
not
reachable.
this
once
leave
1,
never
return.
the
diagram
the
product
machine
thus
shown
the
following
figure.
a
1,4
a
2,4
a
3,4
b
b
a,
b
2,5
a,
b
3,5
figure
273:
state
diagram
the
product
the
preceding
two
acceptor
a
similar
vein,
construct
other
kind
composition,
such
one
one
machine
the
other,
cross-feeding
feedback.
these
suggested
the
following
structural
diagrams,
the
experimentation
the
state
construction
left
the
reader.

finite-state
machines
539
m
n
m
c
n
figure
274:
example
other
machine
composition
again,
claim
a
computer
just
one
large
composition
many
smaller
machines.
a
clear
example
this
seen
the
next
chapter.
additional
capability
register
saw
part
1
datum
transferred
one
register
another
an
array
bit
one
clock
tick.
this
known
a
parallel
transfer.
another
way
get
datum
a
register
a
serial
transfer,
i.e.
one
bit
a
time.
typically
this
done
the
bit
gated
one
flip-flop
shifting
the
bit
one
flip-flop
the
next.
a
register
this
capability
called
a
shift
register.
the
following
diagram
the
shift
register
functionality
implemented.
serial
datum
serial
datum
clock
figure
275:
shift
register
constructed
d
flip-flop
the
datum
shifted
serially,
transferred
parallel.
also,
datum
transferred
parallel
transferred
serial.
thus
the
shift
register
serve
a
serial-parallel
converter
both
directions.
a
shift
register
an
implementation
finite-state
machine,
the
same
model
discussed
earlier,
i.e.
a
bank
flip-flop
serve
memory
a
set
combinational
function
compute
the
next-state
function.
the
function
this
case
trivial:
just
copy
the

540
finite-state
machines
value
one
flip-flop
the
next.
the
4-flip-flop
machine
shown
above,
the
transition
table
be:
next
state
input
current
state
000_
001_
010_
011_
100_
101_
110_
111_
0
1
0000
0001
0010
0011
0100
0101
0110
0111
1000
1001
1010
1011
1100
1101
1110
1111
here
the
_
the
same
next
state
the
_
a
0
1.
this
the
right
end
bit
"shifted
off".
order
combine
functionality
shifting
parallel
input
a
register,
additional
combinational
logic
used
so
each
flip-flop's
input
select
either
function.
this
can
accomplished
the
simple
combinational
circuit
known
a
multiplexor,
as
introduced
the
proposition
logic
chapter.
using
such
multiplexors
select
a
parallel
input
the
adjacent
flip-flop's
output,
achieve
a
two-function
register.
the
address
line
each
multiplexor
tied
a
control
line
(which
called
a
"strobe")
the
function
the
register
a
given
clock.
serial
datum
control
(shift/load)
m
m
m
m
clock
parallel
datum
figure
276:
structure
a
shift
register
two
functions:
serial
datum
parallel
datum
a
commercial
shift-register
typically
constructed
a
different
type
flip-flop
the
d,
simplify
the
attendant
multiplexing
logic.
thus
the
above
diagram
regarded
conceptual
purposes.
multiplexors
(also
called
muxes)
more
often
found
used
other
applications,
as
discussed
subsequently.

finite-state
machines
541
bus
multiplexing
quite
often
computer
design
the
need
selectively
transfer
a
register
one
several
other
registers.
one
way
accomplish
this
put
a
multiplexor
one
input
register
wish
transfer
the
output
connected
the
register
wish
transfer.
the
address
line
then
select
the
input
registers.
before,
the
actual
transfer
place
a
clock
tick.
a
target
register
multiplexor
m
a
b
c
d
address
b
source
c
d
figure
277:
selective
transfer
using
a
multiplexor
(one
bit
shown)
this
approach
both
expensive
slow
(due
multiple
level
delay
the
multiplexor)
the
number
source
register
appreciable.
an
alternate
approach
use
a
bus
structure
achieve
the
multiplexing.
a
first
approximation,
a
bus
just
a
single
wire
bit.
the
understanding
most
one
source
register
providing
input
the
bus
any
one
time.
hence
the
bus
that
time
a
direct
connection
the
target
register.
the
problem
achieve
this
effect.
use
logic
gate
connect
the
source
the
bus,
definition
these
gate
always
output
either
0
1.
one
gate
output
0
the
other
1
connected
a
common
bus,
the
result
undefined
logically
(but
the
effect
similar
a
short-circuit
cause
damage
the
components).
a
rather
miraculous
device
known
a
three-state
buffer
used
achieve
the
bus
interconnection.
name
output
either
0,
1,
a
special
third
state
known
"high
impedance"
"unconnected".
the
effect
the
third
state
the
output
line
the
3-state
buffer
effectively
not
connected
the
bus
logically.
nonetheless,
the
three
state
the
device
controlled
electronically
two
logical
inputs:
one
input
the
output
the
unconnected
state
not,
the
other
input
the
value
transmitted
the
output
the
device
not
the
connected
state.
therefore
the
following
function
table
the
behavior
the
3-state
buffer:
control
datum
0
0
1
1
output
0
1
0
1
unconnected
unconnected
0
1

542
finite-state
machines
out
out
out
=
out
=
"no
connection"
"high
impedance"
0
1
figure
278:
three-state
buffer
behavior
the
following
figure
multiple
source
register
multiplexed
using
a
bus
one
3-state
buffer
source.
notice
the
selection
done
one
3-state
device
activated
a
time,
i.e.
a
"one-hot"
encoding,
contrast
the
binary
encoding
used
a
multiplexor.
often
the
control
strobe
the
form
a
one-hot
encoding
anyway,
not,
always
use
a
decoder
achieve
this
effect.
course,
multiple
bit
the
register,
multiple
bus
wire
one
3-state
buffer
bit
register.
bus
3-state
buffer
target
register
a
b
source
c
d
one-hot
selection
figure
279:
multiplexing
register
source
using
a
bus
3-state
buffer
multiple
target
as
well
sources,
then
control
the
input
the
target
selectively
enabling
the
clock
input
those
registers.
one
contrast
the
multiple-source
case,
however,
"broadcast"
the
same
input
multiple
target
a
single
clock
tick.
put
another
way,
the
selection
the
target
register(s)
done
a
subset
encoding
rather
a
one-hot
encoding.
this
shown
the
next
figure.

finite-state
machines
543
target
register
bus
3-state
buffer
a
b
source
c
d
one-hot
selection
subset
selection
clock
figure
280:
multiple
source
target
selection
a
bus
the
other
point
note
a
bus
input
need
not
come
a
register;
come
the
output
any
combinational
logic,
such
an
adder.
a
sufficiently
coarse
level
abstraction,
bus
shown
a
single
data
path,
suppressing
the
detail
3-state
devices,
selection
gates,
etc.
an
example
the
diagram
the
isc
(incredibly
simple
computer)
the
next
chapter.
1
••
show
construct
a
2-function
shift-register
the
function
shift-left
shift-right.
2
•••
show
construct
a
5-function
shift-register,
function
shift-left,
shiftright,
parallel
load,
clear
(set
all
bit
0),
no-operation
(all
bit
left
is).
3
•••
the
shift
register
described
convenient
converting
serial
datum
parallel
data,
too
slow
serve
an
implementation
the
shift
instruction
found
computers,
desired
shift
any
number
bit
one
clock
interval.
a
combinational
device
designed
this
type
shift
based
using
the
binary
representation
the
amount
shifted

544
finite-state
machines
shift
log
n
stages,
shifting
successive
power
two
position
each
stage.
sketch
the
design
a
device
based
2-input
multiplexors.
the
trade,
this
known
a
"barrel
shifter".
earlier,
referred
the
principle
the
barrel
shifter
based
the
radix
principle.
12.8
chapter
review
define
the
following
terms:
acceptor
bus
classifier
clock
d
flip-flop
edge-triggered
feedback
system
finite-state
machine
flip-flop
kleene's
theorem
latch
multiplexor
non-deterministic
finite-state
machine
parallel
composition
quantization
regular
expression
register
sequencer
shift
register
stable
state
synchronous
three-state
buffer
transducer
turing
machine
demonstrate
convert
a
non-deterministic
finite-state
acceptor
a
deterministic
one.
demonstrate
derive
a
non-deterministic
finite-state
acceptor
a
regular
expression.
demonstrate
derive
a
regular
expression
a
finite-state
machine.
demonstrate
synthesize
a
switching
circuit
a
finite-state
machine
specification.

finite-state
machines
545
12.9
further
reading
frederick
c.
hennie,
finite-state
models
logical
machines,
wiley,
new
york,
1968.
[further
example
finite-state
machine
regular
expressions.
moderate.]
s.c.
kleene,
representation
event
nerve
net
finite
automata,
pp
3-41
shannon
mccarthy
(eds.),
automata
studies,
annals
mathematics
studies,
number
34,
princeton
university
press,
1956.
[the
original
presentation
regular
expression
connection
machines.
moderate.]
g.h.
mealy,
a
method
synthesizing
sequential
circuits,
the
bell
system
technical
journal,
34,
5,
page
1045-1079,
september
1955.
the
mealy
model
finitestate
machine.
moderate.]
edward
f.
moore,
gedanken-experiments
sequential
machines,
pp
129-153
shannon
mccarthy
(eds.),
automata
studies,
annals
mathematics
studies,
number
34,
princeton
university
press,
1956.
the
moore
model
finite-state
machine.
moderate
difficult.]



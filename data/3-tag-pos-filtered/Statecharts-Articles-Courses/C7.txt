finite-state
machine
a
finite-state
machine
(fsm)
finite-state
automaton
(fsa,
plural:
automata),
finite
automaton,
simply
a
state
machine,
a
mathematical
model
computation.
an
abstract
machine
exactly
one
a
finite
number
state
any
given
time.
the
fsm
change
one
state
another
response
some
external
input
a
condition
satisfied;
the
change
one
state
another
called
a
transition.[1]
an
fsm
defined
a
list
states,
initial
state,
the
condition
each
transition.
finite
state
machine
two
type
–
deterministic
finite
state
machine
non-deterministic
finite
state
machines.[2]
a
deterministic
finite-state
machine
constructed
equivalent
any
non-deterministic
one.
classes
automata
the
behavior
state
machine
observed
many
device
modern
society
perform
a
predetermined
sequence
action
depending
a
sequence
event
presented.
simple
example
vending
machines,
dispense
product
the
proper
combination
coin
deposited,
elevators,
sequence
stop
determined
the
floor
requested
riders,
traffic
lights,
change
sequence
car
waiting,
combination
locks,
require
the
input
a
sequence
number
the
proper
order.
the
finite
state
machine
computational
power
some
other
model
computation
such
the
turing
machine.[3]
the
computational
power
distinction
computational
task
a
turing
machine
do
a
fsm
cannot.
this
a
fsm's
memory
limited
the
number
state
fsms
studied
the
general
field
automata
theory.
example:
coin-operated
turnstile
concept
terminology
representation
state/event
table
uml
state
machine
sdl
state
machine
other
state
usage
classification
acceptor
(recognizers)
classifier
transducer
generator
determinism
alternative
semantics
mathematical
model

optimization
implementation
hardware
application
software
application
finite
state
machine
compiler
see
also
reference
reading
general
finite
state
machine
(automata
theory)
theoretical
computer
science
abstract
state
machine
theoretical
computer
science
machine
learning
using
finite-state
algorithm
hardware
engineering:
state
minimization
synthesis
sequential
circuit
finite
markov
chain
external
example:
coin-operated
turnstile
an
example
a
simple
mechanism
modeled
a
state
machine
a
turnstile.[4][5]
a
turnstile,
used
control
access
subway
amusement
park
rides,
a
gate
three
rotating
arm
waist
height,
one
the
entryway.
initially
the
arm
locked,
blocking
the
entry,
preventing
patron
passing
through.
depositing
a
coin
token
a
slot
the
turnstile
the
arms,
allowing
a
single
customer
push
through.
the
customer
through,
the
arm
locked
again
another
coin
state
diagram
a
turnstile
inserted.
considered
a
state
the
turnstile
two
possible
states:
locked
unlocked.[4]
two
possible
input
affect
state:
putting
a
coin
the
slot
(coin)
pushing
the
arm
(push).
the
locked
state,
pushing
the
arm
no
effect;
no
matter
many
time
the
input
push
given,
the
locked
state.
putting
a
coin
–
is,
giving
the
machine
a
coin
input
–
the
state
locked
unlocked.
the
unlocked
state,
putting
additional
coin
in
no
effect;
is,
giving
additional
coin
input
not
change
the
state.
however,
a
customer
pushing
the
arms,
giving
a
push
input,
the
state
back
locked.
the
turnstile
state
machine
represented
a
state
transition
table,
showing
each
possible
a
turnstile
the
transition
(based
the
input
given
the
machine)
the
output
resulting
each
input:
current
state
locked
unlocked
input
next
state
output
coin
unlocked
the
turnstile
so
the
customer
push
through.
push
locked
none
coin
unlocked
none
push
locked
the
customer
pushed
through,
the
turnstile.

the
turnstile
state
machine
also
represented
a
directed
graph
called
a
state
diagram
each
state
represented
a
node
(circle).
edge
(arrows)
show
the
transition
one
state
another.
each
arrow
labeled
the
input
that
transition.
an
input
doesn't
cause
a
change
state
(such
a
coin
input
the
unlocked
state)
represented
a
circular
arrow
returning
the
original
state.
the
arrow
the
locked
node
the
black
dot
the
initial
state.
concept
terminology
a
state
a
description
the
status
a
system
waiting
execute
a
transition.
a
transition
a
set
action
executed
a
condition
fulfilled
an
event
received.
example,
using
an
audio
system
listen
the
radio
(the
system
the
"radio"
state),
receiving
a
"next"
stimulus
result
moving
the
next
station.
the
system
the
"cd"
the
"next"
stimulus
result
moving
the
next
track.
identical
stimulus
trigger
different
action
depending
the
current
state.
some
finite-state
machine
also
possible
associate
action
a
state:
an
entry
action:
performed
entering
the
state,
an
exit
action:
performed
exiting
the
state.
representation
state/event
table
several
state
transition
table
type
used.
the
common
representation
shown
below:
the
combination
current
state
(e.g.
b)
input
(e.g.
y)
the
next
state
(e.g.
c).
the
complete
action's
information
not
directly
described
the
table
only
added
using
footnotes.
a
fsm
definition
fig.
1
uml
state
chart
example
(a
toaster
oven)
including
the
full
action
information
possible
using
state
table
(see
also
virtual
finite-state
machine).
state
transition
table
current
state
state
a
state
b
state
c
input
x
…
…
…
input
y
…
state
c
…
input
z
…
…
…
input
uml
state
machine
the
unified
modeling
language
a
notation
describing
state
machines.
uml
state
machine
overcome
the
limitation
traditional
finite
state
machine
retaining
main
benefits.
uml
state
machine
introduce
the
new
concept
hierarchically
nested
state
orthogonal
regions,
extending
the
notion
actions.
uml
state
machine
the
characteristic
both
fig.
2
sdl
state
machine
example
mealy
machine
moore
machines.
support
action
depend
the
state
the
system
the
triggering
event,
mealy
machines,
as
well
entry
exit
actions,
associated
state
rather
transitions,
moore
machines.

sdl
state
machine
the
specification
description
language
a
standard
itu
graphical
symbol
describe
action
the
transition:
send
an
event
receive
an
event
start
a
timer
cancel
a
timer
start
another
concurrent
state
machine
decision
sdl
basic
datum
type
called
"abstract
data
types",
an
action
language,
an
execution
semantic
order
make
the
finite
state
machine
executable.
other
state
a
large
number
variant
represent
an
fsm
such
the
one
figure
3.
fig.
3
example
a
simple
finite
state
machine
usage
addition
use
modeling
reactive
system
presented
here,
finite
state
machine
significant
many
different
areas,
including
electrical
engineering,
linguistics,
computer
science,
philosophy,
biology,
mathematics,
logic.
finite
state
machine
a
class
automata
studied
automata
theory
the
theory
computation.
computer
science,
finite
state
machine
widely
used
modeling
application
behavior,
design
hardware
digital
systems,
software
engineering,
compilers,
network
protocols,
the
study
computation
languages.
classification
finite
state
machine
subdivided
transducers,
acceptors,
classifier
sequencers.[6]
acceptor
(recognizers)
acceptor
(also
called
recognizer
sequence
detectors),
produce
binary
output,
indicating
not
the
received
input
accepted.
each
state
an
fsm
either
"accepting"
"not
accepting".
all
input
received,
the
current
state
an
accepting
state,
the
input
accepted;
otherwise
rejected.
a
rule,
input
a
sequence
symbol
(characters);
action
not
used.
the
example
figure
4
show
a
finite
state
machine
the
string
"nice".
this
fsm,
the
only
accepting
state
state
7.
a
(possibly
infinite)
set
symbol
sequences,
aka.
formal
language,
called
a
fig.
4
acceptor
fsm:
parsing
the
string
"nice"
regular
language
some
finite
state
machine
exactly
set.
example,
the
set
binary
string
an
even
number
a
regular
language
(cf.
fig.
5),
the
set
all
string
length
a
prime
number
not.[7]:18,71
a
machine
also
described
defining
a
language,
contain
every
string
accepted
the
machine
none
the
rejected
ones;
language
"accepted"
the
machine.
definition,
the
language
accepted
fsms
the
regular
languages—;
a
language
regular
some
fsm
it.

the
problem
determining
the
language
accepted
a
given
finite
state
acceptor
an
instance
the
algebraic
path
problem—
a
generalization
the
shortest
path
problem
graph
edge
weighted
the
element
an
(arbitrary)
semiring.[8][9]
the
start
state
also
an
accepting
state,
case
the
automaton
the
empty
string.
an
example
an
accepting
state
fig.5:
a
deterministic
finite
automaton
(dfa)
the
binary
input
string
an
even
number
0s.
s1
(which
also
the
start
state)
the
state
an
even
number
0s
input.
s1
therefore
an
accepting
state.
this
machine
finish
an
accept
state,
the
binary
string
an
even
number
0s
(including
any
binary
string
containing
no
0s).
example
string
accepted
this
dfa
ε
(the
empty
string),
1,
11,
11…,
00,
010,
1010,
10110,
etc.
fig.
5:
representation
a
finitestate
machine;
this
example
one
a
binary
number
an
even
number
0s,
an
accepting
state.
classifier
a
classifier
a
generalization
a
finite
state
machine
that,
similar
an
acceptor,
a
single
output
termination
more
two
terminal
states.
transducer
transducer
generate
output
based
a
given
input
a
state
using
actions.
used
control
application
the
field
computational
linguistics.
control
applications,
two
type
distinguished:
moore
machine
the
fsm
only
entry
actions,
i.e.,
output
only
the
state.
the
advantage
the
moore
model
a
simplification
the
behaviour.
consider
an
elevator
door.
the
state
machine
two
commands:
"command_open"
"command_close",
trigger
state
changes.
the
entry
action
(e:)
fig.
6
transducer
fsm:
moore
model
state
"opening"
a
motor
opening
the
door,
the
example
entry
action
state
"closing"
a
motor
the
other
direction
closing
the
door.
states
"opened"
"closed"
stop
the
motor
fully
opened
closed.
signal
the
outside
world
(e.g.,
other
state
machines)
the
situation:
"door
open"
"door
closed".
mealy
machine
the
fsm
also
input
actions,
i.e.,
output
input
state.
the
use
a
mealy
fsm
often
a
reduction
the
number
states.
the
example
figure
7
a
mealy
fsm
fig.
7
transducer
fsm:
mealy
model
implementing
the
same
behaviour
the
moore
example
example
(the
behaviour
the
implemented
fsm
execution
model
work,
e.g.,
virtual
fsm
not
event-driven
fsm).
two
input
action
(i:):
"start
motor
close
the
door
command_close
arrives"
"start
motor

in
the
other
direction
open
the
door
command_open
arrives".
the
"opening"
"closing"
intermediate
state
not
shown.
generator
sequencers,
generators,
a
subclass
the
acceptor
transducer
type
a
single-letter
input
alphabet.
produce
only
one
sequence
seen
an
output
sequence
acceptor
transducer
outputs.
determinism
a
further
distinction
deterministic
(dfa)
non-deterministic
(nfa,
gnfa)
automata.
a
deterministic
automaton,
every
state
exactly
one
transition
each
possible
input.
a
non-deterministic
automaton,
an
input
lead
one,
one,
no
transition
a
given
state.
the
powerset
construction
algorithm
transform
any
nondeterministic
automaton
a
(usually
complex)
deterministic
automaton
identical
functionality.
a
finite
state
machine
only
one
state
called
a
"combinatorial
fsm".
only
action
transition
a
state.
this
concept
useful
case
a
number
finite
state
machine
required
work
together,
convenient
consider
a
purely
combinatorial
part
a
form
fsm
suit
the
design
tools.[10]
alternative
semantics
there
other
set
semantics
available
represent
state
machines.
example,
tool
modeling
designing
logic
embedded
controllers.[11]
combine
hierarchical
state
machine
(which
usually
more
one
current
state),
flow
graphs,
truth
table
one
language,
resulting
a
different
formalism
set
semantics.[12]
these
charts,
harel's
original
state
machines,[13]
support
hierarchically
nested
states,
orthogonal
regions,
state
actions,
transition
actions.[14]
mathematical
model
accordance
the
general
classification,
the
following
formal
definition
found:
a
deterministic
finite
state
machine
acceptor
deterministic
finite
state
machine
a
quintuple
where:
,
the
input
alphabet
(a
finite,
non-empty
set
symbols).
a
finite,
non-empty
set
states.
an
initial
state,
an
element
.
the
state-transition
function:
(in
a
nondeterministic
finite
automaton
,
i.e.,
return
a
set
states).
the
set
final
states,
a
(possibly
empty)
subset
.
both
deterministic
non-deterministic
fsms,
conventional
allow
defined
every
combination
not
defined,
then
.
an
fsm
a
partial
function,
i.e.
a
state
,
the
next
symbol
not
announce
an
error
(i.e.
reject
the
input).
this
useful
definition
general
state
machines,
useful
transforming
the
machine.
some
algorithm
default
form
require
total
functions.
a
finite
state
machine
the
same
computational
power
a
turing
machine
restricted
such
head
only
perform
"read"
operations,
always
move
left
right.
that
is,
each
formal
language
accepted
a
finite
state
machine
accepted
a
kind
restricted
turing
machine,
vice
versa.[15]
a
finite-state
transducer
a
sextuple
,
where:

is
the
input
alphabet
(a
finite
non-empty
set
symbols).
the
output
alphabet
(a
finite,
non-empty
set
symbols).
a
finite,
non-empty
set
states.
the
initial
state,
an
element
.
a
nondeterministic
finite
automaton,
the
state-transition
function:
the
output
function.
a
set
initial
states.
.
the
output
function
a
function
a
state
input
alphabet
(
)
that
definition
the
mealy
model,
modelled
a
mealy
machine.
the
output
function
only
a
state
(
)
that
definition
the
moore
model,
modelled
a
moore
machine.
a
finite-state
machine
no
output
function
all
known
a
semiautomaton
transition
system.
disregard
the
first
output
symbol
a
moore
machine,
,
then
readily
converted
an
output-equivalent
mealy
machine
setting
the
output
function
every
mealy
transition
(i.e.
labeling
every
edge)
the
output
symbol
given
the
destination
moore
state.
the
converse
transformation
straightforward
a
mealy
machine
state
different
output
label
incoming
transition
(edges).
every
such
state
split
multiple
moore
machine
states,
one
every
incident
output
symbol.[16]
optimization
optimizing
an
fsm
finding
a
machine
the
minimum
number
state
the
same
function.
the
fastest
known
algorithm
doing
this
the
hopcroft
minimization
algorithm.[17][18]
other
technique
include
using
an
implication
table,
the
moore
reduction
procedure.
additionally,
acyclic
fsa
minimized
linear
time.[19]
implementation
hardware
application
a
digital
circuit,
an
fsm
built
using
a
programmable
logic
a
programmable
logic
controller,
logic
gate
flip
flop
relays.
more
specifically,
a
hardware
implementation
a
register
store
state
variables,
a
block
combinational
logic
the
state
transition,
a
second
block
combinational
logic
the
output
an
fsm.
one
the
classic
hardware
implementation
the
richards
controller.
a
medvedev
machine,
the
output
directly
connected
the
state
flip-flop
minimizing
the
time
delay
flip-flop
output.[20][21]
fig.
9
the
circuit
diagram
a
4-bit
ttl
counter,
a
type
state
machine
state
encoding
low
power
state
machine
optimized
minimize
power
consumption.
software
application
the
following
concept
commonly
used
build
software
application
finite
state
machines:
automata-based
programming
event-driven
finite-state
machine
virtual
finite-state
machine
state
design
pattern

finite
state
machine
compiler
finite
automata
often
used
the
frontend
programming
language
compilers.
a
frontend
comprise
several
finite
state
machine
implement
a
lexical
analyzer
a
parser.
starting
a
sequence
characters,
the
lexical
analyzer
a
sequence
language
token
(such
reserved
words,
literals,
identifiers)
the
parser
a
syntax
tree.
the
lexical
analyzer
the
parser
handle
the
regular
context-free
part
the
programming
language's
grammar.[22]
see
also
abstract
state
machine
(asm)
artificial
intelligence
(ai)
abstract
state
machine
language
(asml)
behavior
model
communicating
finite-state
machine
control
system
control
table
decision
devs:
discrete
event
system
specification
extended
finite-state
machine
(efsm)
finite
state
machine
datapath
hidden
markov
model
low-power
fsm
synthesis
petri
net
pushdown
automaton
quantum
finite
automata
(qfa)
recognizable
language
sequential
logic
specification
description
language
state
diagram
state
pattern
scxml
transition
system
tree
automaton
turing
machine
uml
state
machine
yakindu
statechart
tools
1.
wang,
jiacun
(2019).
formal
method
computer
science.
crc
press.
page
34.
isbn
978-1-4987-7532-8.
2.
"finite
state
machines
-
brilliant
math
science
wiki"
(https://brilliant.org/wiki/finite-state-machines/).
brilliant.org.
retrieved
2018-04-14.
3.
belzer,
jack;
holzman,
albert
george;
kent,
allen
(1975).
encyclopedia
computer
science
technology
(ht
tps://books.google.com/?id=w2ylbideliec&printsec=frontcover).
25.
usa:
crc
press.
page
73.
isbn
978-08247-2275-3.
4.
koshy,
thomas
(2004).
discrete
mathematics
applications
(https://books.google.com/?id=90kapidk5nwc&
pg=pa762).
academic
press.
page
762.
isbn
978-0-12-421180-3.
5.
wright,
david
r.
(2005).
"finite
state
machines"
(https://web.archive.org/web/20140327131120/http://www4.ncs
u.edu/~drwrigh3/docs/courses/csc216/fsm-notes.pdf)
(pdf).
csc215
class
notes.
david
r.
wright
website,
n.
carolina
state
univ.
archived
the
original
(http://www4.ncsu.edu/~drwrigh3/docs/courses/csc216/fsm-notes.
pdf)
(pdf)
2014-03-27.
retrieved
2012-07-14.

6.
keller,
robert
m.
(2001).
"classifiers,
acceptors,
transducers,
sequencers"
(http://www.cs.hmc.edu/~keller/c
s60book/12%20finite-state%20machines.pdf)
(pdf).
computer
science:
abstraction
implementation
(http://w
ww.cs.hmc.edu/~keller/cs60book/%20%20%20all.pdf)
(pdf).
harvey
mudd
college.
page
480.
7.
john
e.
hopcroft
jeffrey
d.
ullman
(1979).
introduction
automata
theory,
languages,
computation
(h
ttps://archive.org/details/introductiontoau00hopc).
reading/ma:
addison-wesley.
isbn
978-0-201-02988-8.
8.
pouly,
marc;
kohlas,
jürg
(2011).
generic
inference:
a
unifying
theory
automated
reasoning.
john
wiley
sons.
chapter
6.
valuation
algebra
path
problems,
page
223
particular.
isbn
978-1-118-01086-0.
9.
jacek
jonczy
(june
2008).
"algebraic
path
problems"
(https://web.archive.org/web/20140821054702/http://www.i
am.unibe.ch/~run/talks/2008-06-05-bern-jonczy.pdf)
(pdf).
archived
the
original
(http://www.iam.unibe.ch/
~run/talks/2008-06-05-bern-jonczy.pdf)
(pdf)
21
august
2014.
retrieved
20
august
2014.,
page
34
10.
brutscheck,
m.,
berger,
s.,
franke,
m.,
schwarzbacher,
a.,
becker,
s.:
structural
division
procedure
efficient
ic
analysis.
iet
irish
signal
systems
conference,
(issc
2008),
pp.18-23.
galway,
ireland,
18–19
june
2008.
[1]
(http://arrow.dit.ie/engschececon/2/)
11.
"tiwari,
a.
(2002).
formal
semantics
analysis
method
simulink
stateflow
models"
(http://www.csl.sri.co
m/users/tiwari/papers/stateflow.pdf)
(pdf).
sri.com.
retrieved
2018-04-14.
12.
hamon,
g.
(2005).
a
denotational
semantics
stateflow.
international
conference
on
embedded
software.
jersey
city,
nj:
acm.
page
164–172.
citeseerx
10.1.1.89.8817
(https://citeseerx.ist.psu.edu/viewdoc/summary?d
oi=10.1.1.89.8817).
13.
harel,
d.
(1987).
a
visual
formalism
complex
systems.
science
computer
programming,
231–274.
(http://
www.fceia.unr.edu.ar/asist/harel01.pdf)
14.
alur,
r.,
kanade,
a.,
ramesh,
s.,
shashidhar,
k.
c.
(2008).
symbolic
analysis
improving
simulation
coverage
simulink/stateflow
models.
international
conference
on
embedded
software
(pp.
89–98).
atlanta,
ga:
acm.
(https://web.archive.org/web/20110715110405/http://drona.csa.iisc.ernet.in/~kanade/publications/sym
bolic_analysis_for_improving_simulation_coverage_of_simulink_stateflow_models.pdf)
15.
black,
paul
e
(12
may
2008).
"finite
state
machine"
(https://web.archive.org/web/20181013023517/https://xlinux.
nist.gov/dads/html/finitestatemachine.html).
dictionary
algorithm
data
structures.
u.s.
national
institute
standards
technology.
archived
the
original
(https://xlinux.nist.gov/dads/html/finitestatema
chine.html)
13
october
2018.
retrieved
2
november
2016.
16.
anderson,
james
andrew;
head,
thomas
j.
(2006).
automata
theory
modern
application
(https://books.go
ogle.com/books?id=iks8bldldxic&pg=pa105).
cambridge
university
press.
page
105–108.
isbn
978-0-52184887-9.
17.
hopcroft,
john
e.
(1971).
an
n
log
n
algorithm
minimizing
state
a
finite
automaton
(ftp://reports.stanford.ed
u/pub/cstr/reports/cs/tr/71/190/cs-tr-71-190.pdf)
(pdf)
(technical
report).
cs-tr-71-190.
stanford
univ.
18.
almeida,
marco;
moreira,
nelma;
reis,
rogerio
(2007).
the
performance
automata
minimization
algorithm
(https://web.archive.org/web/20090117201637/http://www.dcc.fc.up.pt/dcc/pubs/treports/tr07/dcc-2007-03.pd
f)
(pdf)
(technical
report).
dcc-2007-03.
porto
univ.
archived
the
original
(http://www.dcc.fc.up.pt/dcc/pu
bs/treports/tr07/dcc-2007-03.pdf)
(pdf)
17
january
2009.
retrieved
25
june
2008.
19.
revuz,
d.
(1992).
"minimization
acyclic
automata
linear
time".
theoretical
computer
science.
92:
181–
189.
doi:10.1016/0304-3975(92)90142-3
(https://doi.org/10.1016%2f0304-3975%2892%2990142-3).
20.
kaeslin,
hubert
(2008).
"mealy,
moore,
medvedev-type
combinatorial
output
bits"
(https://books.google.com/
books?id=gdrstcygf2oc&pg=pa787&dq=medvedev+fsm#v=onepage&q=medvedev%20fsm&f=false).
digital
integrated
circuit
design:
vlsi
architecture
cmos
fabrication.
cambridge
university
press.
page
787.
isbn
978-0-521-88267-5.
21.
slide
(http://users.etech.haw-hamburg.de/users/schwarz/en/lecture/ds/notes/digsys1.pdf)
archived
(https://w
eb.archive.org/web/20170118123034/http://users.etech.haw-hamburg.de/users/schwarz/en/lecture/ds/notes/di
gsys1.pdf)
18
january
2017
the
wayback
machine,
synchronous
finite
state
machines;
design
behaviour,
university
applied
sciences
hamburg,
p.18
22.
aho,
alfred
v.;
sethi,
ravi;
ullman,
jeffrey
d.
(1986).
compilers:
principles,
techniques,
tools
(1st
ed.).
addison-wesley.
isbn
978-0-201-10088-4.
further
reading

general
sakarovitch,
jacques
(2009).
element
automata
theory.
translated
the
french
reuben
thomas.
cambridge
university
press.
isbn
978-0-521-84425-3.
zbl
1188.68177
(https://zbmath.org/?format=complete&q
=an:1188.68177)
wagner,
f.,
"modeling
software
finite
state
machines:
a
practical
approach",
auerbach
publications,
2006,
isbn
0-8493-8086-3.
itu-t,
recommendation
z.100
specification
description
language
(sdl)
(http://www.itu.int/rec/t-rec-z.10
0-200711-i/en)
samek,
m.,
practical
statecharts
c/c++
(http://www.state-machine.com/psicc/index.php),
cmp
books,
2002,
isbn
1-57820-110-1.
samek,
m.,
practical
uml
statecharts
c/c++,
2nd
edition
(http://www.state-machine.com/psicc2/index.php),
newnes,
2008,
isbn
0-7506-8706-1.
gardner,
t.,
advanced
state
management
(http://www.troyworks.com/cogs/),
2007
cassandras,
c.,
lafortune,
s.,
"introduction
discrete
event
systems".
kluwer,
1999,
isbn
0-7923-8609-4.
timothy
kam,
synthesis
finite
state
machines:
functional
optimization.
kluwer
academic
publishers,
boston
1997,
isbn
0-7923-9842-4
tiziano
villa,
synthesis
finite
state
machines:
logic
optimization.
kluwer
academic
publishers,
boston
1997,
isbn
0-7923-9892-0
carroll,
j.,
long,
d.,
theory
finite
automata
an
introduction
formal
language
(https://philpapers.org/
archive/cartof.pdf).
prentice
hall,
englewood
cliffs,
1989.
kohavi,
z.,
switching
finite
automata
theory.
mcgraw-hill,
1978.
gill,
a.,
introduction
the
theory
finite-state
machines.
mcgraw-hill,
1962.
ginsburg,
s.,
an
introduction
mathematical
machine
theory.
addison-wesley,
1962.
finite
state
machine
(automata
theory)
theoretical
computer
science
arbib,
michael
a.
(1969).
theory
abstract
automata
(1st
ed.).
englewood
cliffs,
n.j.:
prentice-hall,
inc.
isbn
978-0-13-913368-8.
bobrow,
leonard
s.;
arbib,
michael
a.
(1974).
discrete
mathematics:
applied
algebra
computer
information
science
(1st
ed.).
philadelphia:
w.
b.
saunders
company,
inc.
isbn
978-0-7216-1768-8.
booth,
taylor
l.
(1967).
sequential
machines
automata
theory
(1st
ed.).
new
york:
john
wiley
sons,
inc.
library
congress
card
catalog
number
67-25924.
boolos,
george;
jeffrey,
richard
(1999)
[1989].
computability
logic
(3rd
ed.).
cambridge,
england:
cambridge
university
press.
isbn
978-0-521-20402-6.
brookshear,
j.
glenn
(1989).
theory
computation:
formal
languages,
automata,
complexity.
redwood
city,
california:
benjamin/cummings
publish
company,
inc.
isbn
978-0-8053-0143-4.
davis,
martin;
sigal,
ron;
weyuker,
elaine
j.
(1994).
computability,
complexity,
language
logic:
fundamental
theoretical
computer
science
(2nd
ed.).
san
diego:
academic
press,
harcourt,
brace
company.
isbn
978-0-12-206382-4.
hopcroft,
john;
ullman,
jeffrey
(1979).
introduction
automata
theory,
languages,
computation
(1st
ed.).
reading
mass:
addison-wesley.
isbn
978-0-201-02988-8.
hopcroft,
john
e.;
motwani,
rajeev;
ullman,
jeffrey
d.
(2001).
introduction
automata
theory,
languages,
computation
(2nd
ed.).
reading
mass:
addison-wesley.
isbn
978-0-201-44124-6.
hopkin,
david;
moss,
barbara
(1976).
automata.
new
york:
elsevier
north-holland.
isbn
978-0-444-00249-5.
kozen,
dexter
c.
(1997).
automata
computability
(1st
ed.).
new
york:
springer-verlag.
isbn
978-0-38794907-9.
lewis,
harry
r.;
papadimitriou,
christos
h.
(1998).
element
the
theory
computation
(2nd
ed.).
upper
saddle
river,
new
jersey:
prentice-hall.
isbn
978-0-13-262478-7.
linz,
peter
(2006).
formal
language
automata
(4th
ed.).
sudbury,
ma:
jones
bartlett.
isbn
978-07637-3798-6.
minsky,
marvin
(1967).
computation:
finite
infinite
machines
(1st
ed.).
new
jersey:
prentice-hall.
papadimitriou,
christos
(1993).
computational
complexity
(1st
ed.).
addison
wesley.
isbn
978-0-201-53082-7.
pippenger,
nicholas
(1997).
theory
computability
(1st
ed.).
cambridge,
england:
cambridge
university
press.
isbn
978-0-521-55380-3.

rodger,
susan;
finley,
thomas
(2006).
jflap:
an
interactive
formal
language
automata
package
(1st
ed.).
sudbury,
ma:
jones
bartlett.
isbn
978-0-7637-3834-1.
sipser,
michael
(2006).
introduction
the
theory
computation
(2nd
ed.).
boston
mass:
thomson
course
technology.
isbn
978-0-534-95097-2.
wood,
derick
(1987).
theory
computation
(1st
ed.).
new
york:
harper
row,
publishers,
inc.
isbn
978-0-06047208-5.
abstract
state
machine
theoretical
computer
science
gurevich,
yuri
(july
2000).
"sequential
abstract
state
machines
capture
sequential
algorithms"
(http://research.
microsoft.com/~gurevich/opera/141.pdf)
(pdf).
acm
transaction
computational
logic.
1
(1):
77–111.
citeseerx
10.1.1.146.3017
(https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.146.3017).
doi:10.1145/343369.343384
(https://doi.org/10.1145%2f343369.343384).
machine
learning
using
finite-state
algorithm
mitchell,
tom
m.
(1997).
machine
learning
(1st
ed.).
new
york:
wcb/mcgraw-hill
corporation.
isbn
978-0-07042807-2.
hardware
engineering:
state
minimization
synthesis
sequential
circuit
booth,
taylor
l.
(1967).
sequential
machines
automata
theory
(1st
ed.).
new
york:
john
wiley
sons,
inc.
library
congress
card
catalog
number
67-25924.
booth,
taylor
l.
(1971).
digital
networks
computer
systems
(https://archive.org/details/digitalnetworksc00bo
ot)
(1st
ed.).
new
york:
john
wiley
sons,
inc.
isbn
978-0-471-08840-0.
mccluskey,
e.
j.
(1965).
introduction
the
theory
switching
circuit
(1st
ed.).
new
york:
mcgraw-hill
book
company,
inc.
library
congress
card
catalog
number
65-17394.
hill,
fredrick
j.;
peterson,
gerald
r.
(1965).
introduction
the
theory
switching
circuit
(1st
ed.).
new
york:
mcgraw-hill
book
company.
library
congress
card
catalog
number
65-17394.
finite
markov
chain
"we
think
a
markov
chain
a
process
successively
a
set
state
s1,
s2,
…,
sr.
…
state
si
the
next
stop
state
sj
probability
pij.
these
probability
exhibited
the
form
a
transition
matrix"
(kemeny
(1959),
page
384)
finite
markov-chain
process
also
known
subshifts
finite
type.
booth,
taylor
l.
(1967).
sequential
machines
automata
theory
(1st
ed.).
new
york:
john
wiley
sons,
inc.
library
congress
card
catalog
number
67-25924.
kemeny,
john
g.;
mirkil,
hazleton;
snell,
j.
laurie;
thompson,
gerald
l.
(1959).
finite
mathematical
structure
(1st
ed.).
englewood
cliffs,
n.j.:
prentice-hall,
inc.
library
congress
card
catalog
number
59-12841.
chapter
6
"finite
markov
chains".
external
finite
state
automata
(https://curlie.org/computers/computer_science/theoretical/automata_theory/finite_stat
e_automata/)
curlie
modeling
a
simple
ai
behavior
using
a
finite
state
machine
(https://archive.is/20121202054532/http://blog.manu
vra.com/modeling-a-simple-ai-behavior-using-a-finite-state-machine/)
example
usage
video
games
free
on-line
dictionary
computing
(https://web.archive.org/web/20171211180457/http://foldoc.org/finite+state
+machine)
description
finite
state
machines

nist
dictionary
algorithm
data
structure
(https://web.archive.org/web/20181013023517/https://xlinux.ni
st.gov/dads/html/finitestatemachine.html)
description
finite
state
machines
a
brief
overview
state
machine
type
(https://blogs.itemis.com/en/a-brief-overview-of-state-machine-types),
comparing
theoretical
aspect
mealy,
moore,
harel
uml
state
machines.
retrieved
"https://en.wikipedia.org/w/index.php?title=finite-state_machine&oldid=919370156"
this
page
last
edited
3
october
2019,
10:36
(utc).
text
available
the
creative
commons
attribution-sharealike
license;
additional
term
apply.
using
this
site,
agree
the
term
use
privacy
policy.
wikipedia®
a
registered
trademark
the
wikimedia
foundation,
inc.,
a
non-profit
organization.



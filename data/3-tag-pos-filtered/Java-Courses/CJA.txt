langage
java
petit
mémento
de
syntaxe
&
élément
de
programmation
site
de
reference
site
officiel
de
java
être
:
java.sun.com
.
pouvoir
consulter
avec
intérêt
:
-
tutoriels
:
java.sun.com/docs/books/tutorial/
-
grande
collection
de
petits
exemple
de
programme
:
java.sun.com/developer/codesamples/examplets/
-
recommandation
de
style
:
java.sun.com/docs/codeconv/html/codeconvtoc.doc.html
-
descriptif
de
paquetages,
classe
méthode
standard
:
java.sun.com/javase/6/docs/api/
-
mode
d'emploi
générateur
de
documentation
javadoc
:
java.sun.com/j2se/javadoc/index.jsp
-
préparation
à
certification
de
programmeur
java
:
java.sun.com/docs/books/tutorial/extra/certification/
sommaire
1
langage
programmation
orienter
objets...
7
2
programme
java...
....
8
2.1
style
de
programmation
8
2.2
identificateurs
...
8
2.3
commentaires...
...8
2.3.1
commentaire
de
documentation
...
...
8
2.3.2
commentaire
d'implémentation
...
9
2.4
fichier
java
...
9
24.1
nom
contenir
d'un
fichier
java...
...
9
24.2
compilation,
exécution,
génération
de
documentation
10
2.5
paquetage
...
10
2.5.1
paquetage
standard...
...
10
2.5.2
affectation
d'une
classe
à
paquetage
...
...
10
2.5.3
importation
d'une
classer
d'un
paquetage
11
3
classe
interfaces......
12
3.1
classe
standard...
...
12
3.2
classe
abstraites
sous-classe
...
13
3.2.1
classe
abstraites
.
13
3.2.2
sous-classe
...
14
3.3
interfaces...
...
15
3.3.1
interface
...
16
3.3.2
classe
implanter
interface
...
16
3.4
enumération...............
...
16
3.5
classe
imbriquer
(nested
classes)...
17
3.6
contrôle
d'accès
par
modificateur
...
18
4
instance
de
classe...
...
20
5
type
de
donnees
....
21
5.1
type
primitifs...
21
5.2
type
objet
(ou
type
référence).
..22
5.2.1
classe
enveloppes...
..
22
5.2.2
chaîne
de
caractère
modifiable
(string)
...
23
5.2.3
chaîne
de
caractère
modifiable
(stringbuffer)..........................
23
5.2.4
tableau...
...
23
5.2.5
collection...
...
25
5.3
transtypage
...
...
27
6
operateurs
expression
...
...
29
6.1
opérateur
expression
arithmétiques
...
29
6.2
opérateur
expression
booléennes
...
30
6.3
opérateur
relationnels
...
30
7
methodes
...
31
7.1
définition
appel
d'une
méthode
ordinaire...
31
7.2
constructeur
...
...
32
7.3
méthode
main
................
33
8
instruction
...
...
34
8.1
instruction
d'affectation...
...
34
8.2
instruction
de
contrôle...
34
8.2.1
instruction
de
sélection
...
...
34
8.2.2
instruction
de
boucle
...
...
36
8.3
instruction
d'entrée
/
sortie
...
38
8.3.1
notion
de
flux
...
38
8.3.2
entrée
/
sortie
terminal...
...
38
8.3.3
entrée
/
sortir
fichier...
...
39
8.3.4
lecture
d'une
chaîne
de
caractère
formater
...
40
9
heritage.......
42
9.1
notion
d'héritage
...
42
9.2
qu'hérite
sous-classe
?
...
...
43
9.3
redéfinir
un
méthode...
43
9.4
type
statique
/
dynamique
-
liaison
statique
/
dynamique...
46
9.4.1
type
statique
/
dynamique
-
transtypage.....................
46
9.4.2
liaison
statique
/
dynamique
...
47
9.5
polymorphisme...
...
48
9.6
classe
méthode
particulières
...
49
9.7
interfaces...
...
49
10
exception
...
...
50
10.1
exception
contrôler
contrôlées...
50
10.2
classe
d'exception
standard...
...
51
10.2.1
hiérarchie
error
...
...
...
51
10.2.2
hiérarchie
exception
...
51
10.23
hiérarchie
runtimeexception..........
...
51
10.3
lancement
d'une
exception...
...
51
10.4
capture
d'une
exception.........
52
10.4.1
clause
throws
...
52
10.4.2
instruction
try
..
catch
..............
iii
52
10.5
définir
nouvelle
classe
d'exception...
54
11
annexe
1
-
programmation
graphique
...
55
111
swing
..
...
...
55
11.2
conteneur
composants
...
...
56
11.3
gestion
de
mise
en
page...
...
57
11.4
gestion
événement
...
58
11.4.1
notion
d'événement
...
58
11.4.2
réaliser
gestionnaire
d'événement............
...
59
11.5
affichage
/
fermeture
d'une
fenêtrer
graphique
...
60
11.6
architecture
composants
swing
......
60
11.7
applets
...
...
61
12
annexe
2
-
threads
...
...
63
12.1
créer
thread
par
extension
de
classe
thread...
63
12.2
créer
thread
par
implémentation
de
l'interface
runnable.......................
64
12.3
synchronisation
communication
entre
threads
...
64
12.3.1
section
critiques
synchronisation
...
64
12.3.2
communication
entre
threads
...
...
64
13
annexe
3
-
conception
developpement
en
java...
66
13.1
conseil
généraux
pour
bonne
conception
classes...
66
13.2
architecture
d'une
application
interactive
:
modèle
mvc...
67
13.3
test
unitaires
...
...
70
13.3.1
définition
...
70
13.32
junit
..........
71
13.4
java
beans
...
...
72
13.5
design
pattern
...
...
74
13.5.1
exemple
:
modèle
singleton
...
...
75
13.5.2
exemple
:
modèle
decorator.................
...
75
14
annexe
4
-
machine
virtuelle
java
(jvm)
...
77
15
annexe
5
-
communication
entre
java
c
(jni)..................
79
15.1
appel
d'une
procédure
c
...
80
15.1.1
déclaration
appel
java.
...
80
15.1.2
prototype
c
...
81
15.1.3
implémentation
c
...
...
81
15.2
echange
de
donnée
entre
java
c
...
82
15.2.1
déclaration
appel
java
...
...
82
15.2.2
prototype
c
...
83
15.2.3
implémentation
c
...
...
83
16
annexe
6
-
plates-formes
java...
...
84
17
annexe
7
-
glossaire
...
...
85
1
langage
programmation
orienter
objet
java
[1]
être
langage
de
programmation
orienter
objets.
objet
être
représentation
simplifier
d'une
entité
monde
réel
:
entité
concrète
(ex
:
voiture)
(ex
:
date
d'aujourd'hui).
objet
caractériser
par
état
comportement.
objet
stocker
état
dans
variables
appelées
champ
(ou
attributs)
présenter
comportement
travers
de
fonctionnalité
appeler
méthodes.
exemple
d'objet
:
mavoiture
=
{
valeur
attribut
:
fiat,
grise,
6
/100km,
....;
méthode
:
démarrer,
arrêter,
accélérer,
....}
typiquement,
l'état
être
encapsuler
cur
de
l'objet
n'est
accessible
depuis
l'extérieur
de
l'objet,
en
consultation
modification,
via
méthode
offrir
par
objet.
exemple
:
l'objet
mavoiture
getcouleur
setcouleur
démarrer
arrêter
accélérer
...
fiat
griser
6
interagir
avec
objet
en
envoyer
message
de
demande
d'activation
d'une
de
méthodes.
exemple
d'envoi
d'un
message
à
objet
:
mavoiture.accélérer(
);
méthode
particulière,
appeler
constructeur,
permettre
d'initialiser
l'état
de
l'objet
à
création.
classe
servir
à
regrouper
sous
même
catégorie
même
nom
générique
objet
partager
même
type
d'état
même
comportement.
classe
être
type
d'objet
;
dire
qu'un
objet
être
instance
de
classe.
exemple
de
classe
:
automobile
=
{
attribut
:
marque,
couleur,
consommation,
....;
méthode
:
démarrer,
arrêter,
accélérer,
....}
classe
pouvoir
être
organiser
en
hiérarchies.
classe
hériter
attribut
méthode
classe
situer
sur
ligne
hiérarchique
ascendante.
réaliser
programme
dans
langage
orienter
objets,
c'est
:
-
modéliser
par
classe
objet
l'on
avoir
à
manipuler
-
écrire
classe
dans
langage
de
programmation
orienter
objet
-
créer
objet
instance
de
classe
-
communiquer
avec
objet
invoquer
méthodes.
[1]
java
être
naître
en
1995
dans
l'entreprise
californienne
sun
microsystems.
avoir
être
concevoir
par
james
gosling
&
al.
2
programme
java
2.1
style
de
programmation
être
admettre
respect
de
syntaxe
programme
fonctionner
être
critère
de
qualité
suffisants
pour
programme.
l'expérience
de
programmation
avoir
conduire
à
établir
recommandation
de
style.
respecter
n'est
obligatoire
contribuer
à
améliorer
lisibilité
programmes.
convention
viser
en
fait
finalité
économique
:
contribuer
à
produire
programme
maintenables
pendant
durée
de
vie.
dans
chapitre
suivants,
exemple
respecter
convention
de
style
préconiser
par
java.sun.com
2.2
identificateurs
règles
recommandation
pour
nommer
identificateurs
:
+
caractère
minuscule-majuscule
caractère
être
discriminant
(règle
langage
java)
+
identificateurs
d'objets,
de
champ
de
méthode
commencer
par
minuscule
(par
convention)
+
identificateurs
de
classe
(et
d'interface)
commencer
par
majuscule
(par
convention)
+
identificateurs
de
constante
être
en
majuscules
(par
convention)
+
identificateurs
de
méthode
commencer
par
verbe
(recommandation)
2.3
commentaire
2.3.1
commentaire
de
documentation
commentaire
de
documentation
viser
à
décrire
spécification
code,
sans
considération
d'implémentation.
être
destiner
à
développeurs
utilisateur
n'auraient
code
source
sous
main.
commentaire
pouvoir
être
extraire
par
l'utilitaire
javadoc
en
constituer
fichier
de
documentation
en
html.
documentation
d'une
classe
devoir
inclure
avoir
minima
:
-
nom
de
classe,
fonctionnalité
grandes
caractéristiques,
auteur,
version
-
documentation
pour
constructeur
méthode
documentation
d'une
méthode
devoir
inclure
avoir
minima
:
-
nom
de
méthode,
fonctionnalité,
description
de
paramètre
de
valeur
retournée,
exception
susceptibles
d'être
lancer
par
méthode
syntaxe
:
/**
*
commentaire
*/
/**
commentaire
*/
principales
balise
de
commentaire
prédéfinies
:
@author
@version
@param
@return
@see
@throws
2.3.2
commentaire
d'implémentation
commentaire
d'implémentation
viser
à
expliciter
(sans
paraphraser)
code
choix
d'implémentation.
choix
identificateurs
clarté
de
programmation
devoir
permettre
de
minimiser
nombre
de
commentaires.
syntaxe
:
/*
*
commentaire
*/
/*
commentaire
*/
//
commentaire
2.4
fichier
java
2.4.1
nom
contenir
d'un
fichier
java
+
fichier
source
java
contenir
seule
classe
publique.
l'organisation
recommander
être
suivante
:
1)
commentaire
de
début.
c'est
commentaire
de
documentation
comprendre
:
l'intitulé
de
classe
descriptif
sommaire
de
fonction,
l'auteur,
version
2)
instruction
de
paquetage
3)
instruction
d'import
4)
déclaration
classe
+
fichier
devoir
contenir
de
2000
ligne
ligne
de
de
80
caractères,
70
pour
commentaire
de
documentation
(recommandation)
+
fichier
java
porter
nom
de
classe
publique
qu'il
contenir
;
fichier
source
java
avoir
pour
suffixe
.java
;
fichier
java
compiler
avoir
pour
suffixe
.class
(par
convention).
suffixe
.java
.class
être
imposer
par
outils.
2.4.2
compilation,
exécution,
génération
de
documentation
depuis
ligne
de
commande
:
+
compilation
:
javac
filename.java
+
exécution
:
java
filename
//
fichier
main
+
génération
de
documentation
:
javadoc
*.
java
pour
avoir
documentation
"
programmeur
"
complète
(y
comprendre
membre
privés)
de
classe
de
interaction,
falloir
lancer
commande
avec
l'option
-
private.
2.5
paquetage
paquetage
(package
en
anglais)
être
bibliothèque
de
classe
organiser
de
façon
hiérarchique.
nom
d'un
paquetage
être
nom
de
répertoire.
nom
d'un
paquetage
être
en
lettre
minuscules
(par
convention).
différents
paquetage
pouvoir
être
rassembler
compacter
dans
fichier
d'archive
.zip
.jar
2.5.1
paquetage
standard
variable
d'environnement
classpath
indiquer
à
machine
virtuelle
java
trouver
classe
bibliothèque
de
classe
avoir
besoin.
hiérarchie
partielle
paquetage
standard
:
java
applet
awt
io
lang
util
event
paquetage
utiles
paquetage
contenir
java.io
classe
relatives
entrées/sorties
java.lang
classe
fondamentales
:
type
basiques
(classes
enveloppes,
string,
stringbuffer,
......),
classe
math,
...
java.util
classe
utilitaires
diverses
:
collection
(arraylist,
vector,
...),
classer
random,
gestion
date
heures,
...
2.5.2
affectation
d'une
classe
à
paquetage
pour
qu'une
classe
appartenir
à
paquetage,
falloir
déclarer
paquetage
d'appartenance
en
tête
de
fichier
source.
syntaxe
:
package
packagename
;
2.5.3
importation
d'une
classer
d'un
paquetage
pour
utiliser
classe
définir
dans
paquetage
autre
de
classe
d'utilisation,
classe
devoir
être
importer
en
tête
de
fichier
source.
syntaxe
:
import
packagename.ctassname
;
import
packagename.*;
//
former
déconseiller
informative
exemple
:
import
java.util.arraylist;
import
java.util.lterator;
import
java.io.*;
//
former
déconseiller
informative
paquetage
java.lang
être
importer
automatiquement.
3
classe
interface
3.1
classe
standard
syntaxe
:
public
classname
{
fields
constructors
methods
//
accessor
methods
...
//
mutator
methods
...
}
exemple
:
/**
*
class
rationalnumber
-
represents
avoir
rational
number
num
/
den
*
*
@author
am
*
@version
1.0
*
*/
public
class
rationalnumber
{
//
fields
private
int
numerator
;
private
int
denominator
;
private
boolean
reduced
;
//
constructors
/**
construct
avoir
rational
number
initialized
to
0/1
*/
public
rationalnumber(
)
{
numerator
=
0
;
denominator
=
1
;
reduced
=
true
;
}
//
methods
-
accessors
/**
get
the
numerator
of
this
rational
number
*/
public
int
getnumerator(
)
{
return
numerator
;
}
/**
get
the
denominator
of
this
rational
number
*/
public
int
getdenominator(
)
{
return
denominator
;
}
/**
return
true
iff
the
numerator/denominator
form
is
irreducible
*/
public
boolean
isreduced(
)
{
return
reduced
;
}
//
methods
-
mutators
/**
set
this
rational
number
to
_numerator/_denominator
*/
public
void
setnumber(int
_numerator,
int
_denominator)
{
numerator
=
_numerator
;
denominator
=
_denominator
;
reduced
=
false
;
}
/**
set
this
rational
number
to
avoir
irreducible
*
numerator/denominator
form
*/
public
void
reduce(
)
{
int
divisor
=
greatestcommondivisor(numerator,
denominator
j);
numerator
=
numerator
/
divisor
;
denominator
=
denominator
/
divisor
;
reduced
=
true
;
}
//
methods
-
utilities
/**
return
the
greatest
common
divisor
of
the
two
integers
*
x
and
*/
private
int
greatestcommondivisor(int
x,
int
y)
{
int
divisor
;
//
...
à
implémenter
...
return
divisor
;
}
}
//
end
rationalnumber
3.2
classe
abstraites
sous-classe
classe
posséder
méthode
abstraite
(i.e.
sans
corps)
être
abstraire
devoir
être
déclarer
avec
modificateur
abstract.
classe
abstraites
pouvoir
être
instanciées.
pour
pouvoir
créer
objets,
falloir
créer
sous-classe
dans
méthode
abstraites
être
définir
:
sous-
classe,
abstraite,
pouvoir
être
instanciée.
3.2.1
classe
abstraire
syntaxe
:
public
abstract
classname
{
fields
constructors
methods
}
exemple
:
/**
*
abstract
progression
*
*
represents
avoir
real
linear
progression
of
order
1
with
constant
*
coefficient
*
*
@author
am
*
@version
1.0
*/
public
abstract
progression
{
//
fields
private
double
u0;
//
the
first
term
of
the
progression
//
constructors
/**
define
avoir
progression,
the
first
term
of
which
is
u0
*/
public
progression(double
u0)
{
this.u0
=
u0
;
}
//
methods
/**
get
the
first
term
of
this
progression
*/
public
double
getu0()
{
return
u0
;
}
/**
given
à
current
term
u(n),
return
the
next
term
u(n+1)
*/
public
abstract
double
nextterm(double
un)
;
/**
return
the
term
of
rank
n
*/
public
double
termofrank(int
n)
{
doubler
u
=
u0
;
//
u(n)
double
v
;
//
u(n+1)
for(int
i
=
1;
i
<=
n;
i++)
{
v
=
nextterm(u)
;
u
=
v
;
}
return
u
;
}
}
//
end
class
progression
3.2.2
sous-classe
syntaxe
:
public
subclassname
extends
superclassname
{
fields
constructors
methods
}
exemple
:
/**
*
class
arithgeomprogression
*
*
represents
avoir
real
arithmetic-geometric
progression
with
constant
*
coefficient
:
u(n+1)
=
a*u(n)
+
b
*
*
@author
am
*
@version
1.0
*/
public
class
arithgeomprogression
extends
progression
{
//
fields
private
double
a;
//
multiplying
coefficient
private
double
b;
//
additive
coefficient
//
constructors
/**
define
an
arithmetic-geometric
progression
*
@param
u0o
first
term
of
the
progression
*
@param
avoir
multiplying
coefficient
*
@param
b
additive
coefficient
*/
public
arithgeomprogression
(double
u0,
double
a,
double
b)
{
super
(u0)
;
this.a
=
a;
this.b
=
b;
}
//
methods
/**
given
à
current
term
u(n),
return
the
next
term
u(n+1)
*/
public
double
nextterm(double
u)
{
return
a*u
+
b
;
}
}
//
end
arithgeomprogression
3.3
interface
remarquer
liminaire.
terme
"
interface
"
avoir
sémantique
multiple.
dans
cadre
de
programmation
en
java,
pouvoir
prendre,
selon
contexte,
trois
sens
distincts
(même
conceptuellement
apparentés)
:
-
sens
informatique
commun
:
interface
être
"
jonction
entre
deux
élément
(matériels
logiciels)
permettre
l'échange
d'information
"
;
par
exemple,
l'interface
homme-machine.
-
sens
programmation
objet
:
l'interface
d'une
classe
être
partie
visible
publique
de
classe
;
définir
par
liste
membre
(attributs,
constructeurs,
méthodes)
priver
associer
à
commentaire
de
documentation
-
sens
spécifique
langage
java
:
interface
être
sorte
de
classe
abstraite
posséder
caractéristique
particulières
définir
protocole
de
comportement
;
c'est
sens
être
définir
dans
section.
c'est
contexte
d'utilisation
donner
sens
mot
interface.
interface
(au
sens
langage
java)
être
sorte
de
classe
abstraire
sans
détail
d'implémentation
posséder
degré
d'abstraction
supérieur
à
classe
abstraites.
interface
:
-
avoir
méthode
être
abstraire
(elles
n'ont
de
corps)
-
à
noter
qu'il
n'est
recommander
d'ajouter
modificateur
abstract
puisqu'il
être
implicite
;
-
posséder
de
champs,
à
l'exception
éventuelle
de
constante
de
classe
(implicitement
static
final)
assigner
;
-
membre
être
publics
l'interface
être
publique.
interface
spécifier
signature
minimale
d'une
classe
l'implémente.
interface
être
contrat
à
respecter.
classe
implémente
interface,
s'engage
à
conformer
à
interface.
classe
pouvoir
implémenter
interfaces.
classe
définir
type
implémentation
;
interface
définir
type
sans
implémentation.
3.3.1
interface
syntaxe
:
public
interface
interfacename
{
constantattributes
abstractmethods
}
exemple
:
public
interface
measurable
{
double
size()
;
/**
@return
-1,
0,
1
if
this
is
<,
=
>
than
x
*/
int
islargerthan(measurable
x)
;
}
3.3.2
classe
implanter
interface
syntaxe
:
public
classname
implements
interfacenamel,
interfacename2,
...
{
...
}
exemple
:
public
class
square
implements
measurable
{
private
double
width
;
public
square(double
_width)
{
width
=
_width
;
}
public
double
size()
{
return
width*width
;
}
public
int
islargerthan(measurable
x)
{
if
(this.size()
<
x.size())
{
return
-1
;
}
if
(this.size()
>
x.size())
{
return
1
;
}
return
0
;
}
}
3.4
enumération
classe
enum
permettre
de
représenter
ensemble
de
constante
nommer
type
être
classe
elle-même.
classe
contribuer
à
accroître
lisibilité
programmes.
syntaxe
:
public
enum
enumname
{
//
list
of
named
constants.
//
possibility
of
other
fields
and
methods.
}
exemple
:
public
enum
direction
{
north,
south,
east,
west;
}
public
class
test
{
private
direction
dir
;
public
setdir(direction
d){
dir
=
d;
}
public
boolean
isnorthsouth()
{
return
(dir
==
direction.north)
||
(dir
==
direction.south)
;
}
}
sous
forme
simple,
classe
enum
être
utiliser
sous
forme
d'une
classe
interner
(inner
class).
exemple
:
public
class
myclass
{
private
direction
dir
;
...
private
enum
direction
{
north,
south,
east,
west
;
}
public
void
setnorth()
{
dir
=
direction.north
;
}
...
}
-
être
possible
d'associer
à
constante
énumérer
valeur
d'un
type
quelconque
-
être
possible
d'utiliser
type
énumérer
dans
instruction
switch
3.5
classe
imbriquer
(nested
classes)
concept
n'est
vital
pour
un
débutant.
classe
pouvoir
être
définir
à
l'intérieur
d'une
autre
classe.
parler
de
classe
imbriquée.
distinguer
quatre
catégorie
:
-
classe
membrer
déclarer
static
(static
nested
classes)
:
membre
statiques
de
classe
englobante
;
-
classe
internes
(inner
classes)
:
membre
statiques
de
classe
englobante
;
-
classe
locales
(local
classes)
:
classe
définir
à
l'intérieur
d'une
méthode
;
-
classe
anonymes
(anonymous
classes)
:
classe
locales
sans
nom.
exemple
:
public
outerclass
{
...
public
static
staticnestedclass
{
...
}
private
class
innerclass
{
...
}
}
//
exemple
de
référence
à
classe
staticnestedclass:
//
outerclass.staticnestedclass
intérêt
peut-il
avoir
à
déclarer
classe
imbriquées
?
regroupement
logique,
encapsulation
accrue,
code
lisible
maintenable.
en
pratique,
plupart
classe
imbriquées
être
classe
internes.
quant
classe
anonymes,
pouvoir
rendre
code
difficile
à
lire
devoir
être
limiter
à
classe
petites
(d'une
deux
méthodes)
:
voir
exemple
typique
en
section
11.4.2.
3.6
contrôle
d'accès
par
modificateur
contrôle
d'accès
à
membre
d'une
classe
pouvoir
être
préciser
dans
déclaration
par
mots-clés
appeler
modificateurs.
modificateur
permettre
de
spécifier
:
-
visibilité
champ
de
méthode
:
private,
protected
public
-
lieu
de
stockage
:
dans
classe
(modificateur
static)
dans
l'objet
(par
défaut)
-
caractère
modifiable
(par
défaut)
(modificateur
final)
modificateur*
commentaire
exemple
private
membre
déclarer
private
n'est
accessible
qu'à
l'intérieur
de
classe
de
définition.
modificateur
d'accès
recommander
pour
champs.
protected
membre
déclarer
protected
n'est
accessible
depuis
classe
de
déclaration,
sous-classe,
classe
même
paquetage.
modificateur
d'accès
recommander
pour
méthode
super-
classes.
public
membre
déclarer
public
être
accessible
depuis
n'importe
classe.
modificateur
d'accès
recommander
pour
méthode
static
champ
déclarer
static
être
variable
de
classe
n'est
dupliquer
dans
différentes
instance
;
champ
static
être
variable
d'instance
être
dupliquer
dans
instance.
méthode
déclarer
static
être
méthode
de
classe
être
invoquer
sans
référence
à
objet
particulier
faire
référence
à
classe
;
méthode
static
être
méthode
d'instance
être
invoquer
sur
objet
particulier
voir
chapitrer
final
variable
déclarer
final
pouvoir
être
modifier
après
qu'elle
avoir
être
initialisée.
permettre
en
particulier
de
déclarer
champ
constants.
exemple
:
final
int
size
=
10
;
méthode
déclarer
final
pouvoir
être
redéfinir
dans
un
sous-classe.
classe
déclarer
final
pouvoir
être
sous-classée.
*
nota
:
à
défaut
de
modificateur
private,
protected
public,
visibilité
être
dire
"
package
access
"
:
membre
de
classe
être
visible
depuis
classe
même
paquetage.
exemple
:
public
static
final
double
gravity
=
9.81
;
4
instance
de
classe
avant
de
pouvoir
être
utilisé,
objet
-
instance
de
classe
-
devoir
être
:
1)
déclarer
classname
objectname
;
2)
créer
initialiser
objectname
=
new
constructorcall
;
exemple
:
gregoriancalendar
cal
;
cal
=
gregoriancalendar()
;
timer
mytimer
=
new
timer(
)
;
déclaration
d'un
objet
créer
l'objet
variable
pointeur
destiner
à
mémoriser
l'adresse
future
de
l'objet!
!la
création
de
l'objet
en
(i.e.
l'instance
dite)
être
réaliser
par
l'opérateur
new.
l'appel
constructeur
suivre
l'opérateur
new
avoir
pour
rôle
d'initialiser
l'objet
créé.
in
fine,
l'adresse
de
l'objet
créer
initialisé,
adresse
renvoyer
par
l'opérateur
new,
être
stockée,
grâce
à
l'opérateur
d'affectation
=,
dans
variable
déclarée.
précision
importantes
:
*
déclaration.
déclaration
classname
objectname;
créer
variable
de
nom
objectname
de
type
référencer
(i.e.
pointeur)
l'initialise
à
null.
null
être
constante
littérale
prédéfinie
de
java
pouvoir
être
assigner
à
variable
de
type
référence
identifier
pointeur
nul.
variable
de
valeur
null
poindre
vers
objet.
tentative
de
référer
à
objet
à
partir
d'un
pointeur
null
engendrer
erreur
(de
compilation
d'exécution
selon
contexte).
*
gestion
dynamique
de
mémoire.
l'opérateur
new
créer
l'instance
de
classe
dans
zone
mémoire
générale
appeler
"
tas
"
contenir
donnée
allouer
à
l'exécution
n'ayant
de
portée
locale.
l'objet
créer
conserver
portée
globale
rester
"
vivant
"
qu'on
dispose
d'une
référence
(i.e.
pointeur)
permettre
d'y
accéder.
objet
n'est
référencé,
devenir
inaccessible
"
mourir
"
:
espace
mémoire
être
désalloué
(la
récupération
automatique
de
espace
mémoire
être
réaliser
par
processus
appeler
ramasse-miettes
(garbage
collector)).
façon
de
détruire
objet
être
d'assigner
valeur
null
variables
faire
référence
indirectement.
5
type
de
donnees
java
connaître
deux
type
de
donnée
:
-
type
primitifs.
donnée
de
type
primitif
être
stocker
dans
variables
avoir
sémantique
de
valeur
(i.e.
c'est
valeur
être
copier
variable
être
affecter
à
autre
variable).
-
type
objet
(ou
type
référence).
donnée
de
type
objet
être
stocker
sous
forme
de
référence
à
objet
(et
en
qu'objet
même).
variable
de
type
objet
être
affecter
à
autre
variable,
seule
référence
être
copiée,
l'objet
lui-même.
java
utiliser
système
unicode-4,
en
interne,
pour
coder
caractères,
chaîne
de
caractère
identificateurs.
caractère
unicode
être
coder
sur
16
bits,
permettre
de
représenter
de
nombreux
alphabet
(grec,
cyrillique,
hébreu,
arabe,
...)
symbole
mathématiques
techniques.
qu'unicode
utiliser
par
système
d'exploitation
(windows
nt
vista
par
exemple),
plupart
système
d'exploitation
utiliser
système
de
codage
8
bits,
de
sorte
transcodage
être
nécessaires
problème
d'incompatibilité
pouvoir
survenir
à
l'affichage.
5.1
type
primitifs
typer
description
exemple
de
littéraux
nombre
entiers
:
type
signés
:
byte
octet
(entier
8
bits)
127
-128
short
entier
courir
(16
bits)
32767
-32768
int
entier
(32
bits)
2147483647
-2147483648
long
entier
(64
bits)
5123456789l
-55l
nombre
réels
:
type
signés
:
float
réel
simple
précision
43.889f
341.159e-2f
double
réel
double
précision
45.63
-2.4e107
autres
type
:
type
signer
:
char
caractère
(un
seul
;
16
bits)
'?'
'\u00f6'
boolean
valeur
booléenne
false
true
+
nombre
sans
point
décimal
être
interpréter
entier
de
type
int
convertir
en
byte,
short
de
l'affection.
pouvoir
déclarer
littéral
de
type
long
en
l'affectant
suffixe
l.
+
nombre
avec
point
décimal
être
interpréter
réel
de
type
double.
pouvoir
déclarer
littéral
de
type
float
en
l'affectant
suffixe
f.
+
caractère
littéral
pouvoir
être
écrire
sous
forme
d'un
unique
caractère
unicode
entre
apostrophe
d'une
valeur
unicode
précéder
par
'\u'.
+
deux
littéraux
booléens
être
true
false.
+
variables
d'un
type
primitif
référer
à
objets,
n'ont
de
méthode
associées.
5.2
type
objet
(ou
type
référence)
type
autres
type
primitifs
être
type
objet.
inclure
classe
(non
abstraites)
bibliothèque
standard
java
(tels
type
string,
par
exemple)
classe
définir
par
l'utilisateur.
variable
d'un
typer
objet
contenir
référence
(ou
pointeur)
sur
objet.
affectation
passage
de
paramètre
avoir
sémantique
de
référence
(i.e.
c'est
référence
être
copier
l'objet
lui-même).
après
l'affectation
d'une
variable
à
autre,
deux
variables
référer
même
objet
:
s'agit
d'une
copier
de
surface
(par
opposition
à
copie
profonde
dupliquer
objets).
deux
variables
être
dire
pour
même
objet.
5.2.1
classe
envelopper
classe
enveloppe
permettre
de
transformer
type
simple
en
objet
(cette
opération
être
appelée,
en
anglais,
boxing).
classe
envelopper
type
primitif
boolean
boolean
byte
byte
character
char
double
double
float
float
integer
int
long
short
short
exemple
:
//
convert
primitive
type
>
wrapper
type
integer
k
=
new
integer(456);
//
convert
wrapper
type
>
primitive
type
double
x
=
k.doublevalue(
)
;
classe
enveloppe
être
utiles
méthode
n'accepte
type
simples
requérir
objets.
toutefois,
depuis
plate-forme
5.0
(voir
chapitrer
16),
valeur
de
type
primitif
sont,
en
cas
de
besoin,
convertir
en
l'objet
de
classe
envelopper
correspondante
(autoboxing),
(unboxing).
auparavant,
conversion
devoir
être
explicite.
objet
de
classe
être
immuables
(immutable),
modifiables
fois
créés.
en
conséquence,
méthode
pouvoir
avoir
de
paramètre
de
sortie
de
types.
classe
enveloppe
présenter
l'intérêt
d'offrir
méthode
de
conversion
typer
primitif
<->
string,
utilitaire
donnée
de
type
primitif.
exemple
:
//
convert
string
type
->
primitive
type
double
x
=
double.parsedouble("
3.14159
")
;
5.2.2
chaîne
de
caractère
modifiable
(string)
chaîne
de
caractère
de
type
string
être
objets,
n'est
nécessaire
d'avoir
recourir
à
l'opérateur
new
pour
créer.
caractère
d'une
chaîne
de
caractère
chaine
être
indicer
de
0
à
chaine.length()-1
chaîne
de
caractère
littérale
être
noter
entre
apostrophes.
l'opérateur
+
être
l'opérateur
de
concaténation
de
chaînes.
produire
nouvelle
chaîne
sans
élément
partager
avec
opérandes.
comparaison
de
deux
chaîne
(caractère
par
caractère)
nécessiter
de
faire
appel
à
fonction
equals(),
l'opérateur
==
donner
résultat
attendre
dans
cas
particulier.
objet
de
type
string
être
immuables
(immutable),
modifiables
fois
créés.
en
conséquence,
méthode
pouvoir
avoir
de
paramètre
de
sortie
de
type
string.
classe
string
appartenir
paquetage
java.lang
exemple
:
string
chainer
=
"exemple
n°"
+
1
+
"de
chainer
littérale"
;
system.out.println("longueur
de
\""
+
chainer
+
"\"
="
+
chaine.length()
)
;
5.2.3
chaîne
de
caractère
modifiable
(stringbuffer)
chaîne
de
caractères,
chaîne
de
type
string,
pouvoir
être
modifiées.
l'opérateur
new
être
indispensable
pour
créer
chaîne
de
type
stringbuffer.
classe
stringbuffer
appartenir
paquetage
java.lang
exemple
:
stringbuffer
chainer
;
chainer
=
new
stringbuffer
("meeting
at
6
pm!
!"
)
;
chaine.setcharat(11,
'5')
;
//
meeting
at
5
and
not
6!
!
system.out.println(chaine)
;
5.2.4
tableau
tableau
être
collection
de
taille
fixe
d'éléments
de
même
type.
élément
être
repérer
par
indice
permettre
accès
direct
à
l'élément.
a
tableau
être
associer
classe
dériver
d'object
partager
par
tableau
avoir
même
type
d'éléments.
l'attribut
d'instance
length
(qui
être
champ
public
méthode)
contenir
nombre
d'éléments
tableau.
élément
d'un
tableau
array
être
indicer
de
0
à
array.length
-
1
tenter
d'accéder
à
élément
l'indice
être
hors
de
plage
permise,
exception
de
type
indexoutofboundsexception
être
levée.
être
à
noter
qu'un
tableau
de
caractère
n'est
objet
de
type
siring
réciproquement.
syntaxe
(pour
cas
d'un
tableau
mono-dimensionnel)
:
//
declaring
an
array
variable
typeofelements[]
arrayvariable
;
//
creating
an
array
object
arrayvariable
=
new
typeofelements[numberofelements]
;
//
referring
to
an
element
arrayvariable[integerindex]
exemple
:
//
declaring
an
array
variable
private
double[]
mark
;
//
creating
an
array
object
static
final
int
nb_of_students
=
48
;
mark
=
new
double[nb_of_students];
//
using
an
array
object
for
(int
1
=
0;
1
<
marks.length;
i++)
{
marks[i]
=
math.random()
*
20.0
;
system.out.println("marks["
+
1
+
"]
=
"
+
marks[i]
)
;
}
exemple
:
static
final
int
nrow
10
;
static
final
int
ncol
=
20
;
string[][]
matrix
=
new
string[nrow][ncol]
;
être
possible
de
créer
d'initialiser
tableau
à
déclaration.
exemple
:
int[
]
t
=
{
150,
-300,
40,
500
}
;
system.out.println(t[0]
+
"
"
+
t[3])
;
//
150
500
string[
][
]
s
=
{
{"mr.
",
"mrs.
",
"ms.
"},
//
row
0
{"smith",
"jones"}
//
row
1
}
;
system.out.print(s[0][2]
+
s[1][1])
;
//
ms.
jones
classe
java.util.arrays
offrir
diverses
méthode
utilitaires
applicables
à
tableau
(comparaison,
tri,
......).
depuis
plate-forme
5.0
(voir
chapitrer
16),
java
offrir
boucle
for
simplifier
pour
parcourir
élément
d'un
tableau.
exemple
:
//
for
each
element
of
my
array
of
doubles,
print
this
element
for
(double
e
:
myarrayofdoubles)
{
system.out.println(e)
;
}
5.2.5
collection
collection
être
objet
représenter
groupe
d'objets.
collection
être
agrégat
regrouper
élément
multiples
en
seule
entité.
hypothèse
n'est
faire
avoir
sur
type
éléments,
sur
l'ordre
éléments,
sur
possibilité
d'éléments
dupliqués.
formellement,
en
java,
collection
d'éléments
de
type
e
être
classe
implémente
l'interface
collection<e>.
paquetage
standard
java.util
offrir
variété
de
collection
(collections
framework)
répondre
besoin
fréquents,
par
exemple
:
arraylist<e>,
vector<e>,
linkedlist<e>,
stack<e>,
hashtable<k,v>,
...
.
5.2.5.1
généricité
notion
n'existe
en
java
depuis
plate-forme
5.0
(voir
chapitrer
16).
version
5.0
introduire
révision
majeure
par
rapport
à
précédente,
en
matière
de
gestion
collections.
l'apparition
de
type
génériques
être
l'évolution
marquante.
généricité
permettre
de
communiquer
compilateur
type
élément
d'une
collection
moment
de
création
de
l'objet
en
fixer
avoir
dans
définition
de
classe.
exemple
de
classe
générique
:
//
defining
avoir
generic
collection.
//
the
formal
parameter
t
is
the
generic
type
of
the
elements.
public
mycollection<t>
implements
list<t>
{
...
//
t
can
be
used
here
avoir
any
type
...
}
//
creating
avoir
collection
of
integers
mycollection<integer>
collectionofintegers
;
collectionofintegers
=
new
mycollection<integer>();
//
creating
avoir
collection
of
string
mycollection<string>
collectionofstrings
;
collectionofstrings
=
new
mycollection<string>()
;
déclaration
de
type
pouvoir
être
génériques,
déclaration
de
méthode
pouvoir
être
génériques,
paramétrisées
par
paramètres.
exemple
de
méthode
générique
:
//
defining
public
static
<t>
void
fromarraytocollection(t[]
a,
collection<t>
c){
for
(t
o
:
a)
{
c.add(o);
}
}
//
using
it
string[]
a1
=
{"datal",
"data2",
"data3",
"data4",
"data5"}
;
collection<object>
c1
=
new
arraylist<string>();
fromarraytocollection(a1,
c1);
nota.
être
à
signaler
tableau
générique
faire
bon
ménage!
!
exemple
:
vector<integer>[]
sheets
=
new
vector<integer>[nbofsheets];
produire
l'erreur
classique
"generic
array
creation".
dans
exemple,
solution
pouvoir
consister
à
passer
par
classe
intermédiaire
définir
par
:
vectorofintegers
extends
vector<integer>
{
}
type
?
être
appeler
type
joker
(wildcard
type).
permettre
de
représenter
type.
exemple
:
public
void
printall(collection<?>
c)
{
for
(object
o
:
c)
{
system.out.println(o);
}
}
être
possible
de
borner
type
joker.
caractère
joker
avec
borne
supérieure
être
spécifier
:
<?
extends
type>
représenter
sous-types
de
type.
caractère
joker
avec
borne
inférieure
être
spécifier
:
<?
super
type>
représenter
type
être
super-types
de
type.
5.2.5.2
exemple
de
collection
:
arraylist
objet
de
type
arraylist<e>
être
collection
de
taille
variable
d'éléments
de
type
e.
élément
être
repérer
par
indice
permettre
accès
direct
à
l'élément.
liste-tableau
supporter
principales
fonctionnalité
suivantes
:
-
ajout
d'un
élément
en
fin
de
tableau
(méthode
add(e))
-
accès
à
élément
d'indice
donner
(méthodes
get(int)
add(int,
e))
-
suppression
d'un
élément
d'indice
donner
(méthode
remove
(int))
-
consultation
nombre
d'éléments
(méthode
size())
élément
d'un
objet
collection
de
type
arraylist<e>
être
indicer
de
0
à
collection.size(
)
-
1
classe
arraylist<e>
devoir
être
importer
paquetage
java.util
par
:
import
java.util.arraylist
;
exemple
:
arraylist<integer>
mycollectionofintegers
;
mycollectionofintegers
=
new
arraylist<integer>()
;
for
(int
1
=
0
;
1
<
10
;
i++)
{
listofintegers.add(i,
0)
;
}
5.2.5.3
parcours
d'une
collection
--
itérateur
parcours
d'une
collection
être
l'opération
consister
à
explorer
collection
élément
par
élément.
deux
façon
de
faire
pour
parcourir
collection
:
-
utiliser
itérateur.
itérateur
être
objet
de
type
iterator<e>.
trois
fonctionnalité
utiles
pour
créer
gérer
itérateur
être
méthode
:
iterator()
(de
classe
collection),
hasnext()
next()
(de
classe
iterator).
a
noter
suppression
d'éléments
de
collection
en
cours
de
parcours
relever
de
méthode
remove()
de
l'itérateur
de
de
collection.
classe
iterator<e>
devoir
être
importer
paquetage
java.util
par
:
import
java.util.iterator
;
itérateurs
être
façon
de
faire
historique
pour
parcourir
collection.
depuis
version
5.0
être
génériques.
-
utiliser
boucle
for
généralisée.
boucle
permettre
de
s'affranchir
itérateurs
de
parcourir
collection
quelconque.
n'est
offerte
depuis
version
5.0.
exemple
de
parcours
avec
itérateur
:
iterator<integer>
it
=
mycollectionofintegers.iterator()
;
while
(
it.hasnext()
)
{
//
call
it.next()
to
get
the
next
object
of
the
collection
//
and
do
something
with
that
object
}
exemple
de
parcours
sans
itérateur
:
//
for
each
element
of
my
collection
of
integers,
print
it
for
(integer
v
:
mycollectionofintegers)
{
system.out.println(v)
;
}
5.3
transtypage
transtypage
(en
anglais
:
cast
/
casting)
être
opération
consister
à
convertir
type
d'une
expression.
conversion
de
type
réaliser
en
faire
précéder
l'expression
par
type
cibler
entre
parenthèses.
proposition
s'applique
à
type
primitifs
type
objet
lier
par
relation
d'héritage.
conversion
incorrectes
provoquer
erreur
à
compilation
à
l'exécution.
a
noter
qu'un
transtypage
changer
type
variables
concerner
(le
type
d'une
variable
être
définir
fois
pour
dès
création)
:
l'opération
de
transtypage
être
changement
de
point
de
vue
qu'on
demander
compilateur.
syntaxe
:
(newtype)
expression
exemple
:
int
n
=
87
;
char
c
=
(char)
(n
/
2)
;
classe
offrir
méthode
spécifiques
adéquates,
:
°
pour
conversion
réel
->
entier
:
-
méthode
math.
round(realvalue)
permettre
de
convertir
réel
en
l'entier
proche
-
méthode
math.floor(realvalue)
associer
à
conversion
en
entier
fournir
grand
entier
inférieur
égal
à
l'argument.
exemple
:
(int)math.floor(15.7)
valoir
15
-
méthode
math.ceil(realvalue)
associer
à
conversion
en
entier
fournir
petit
entier
supérieur
égal
à
l'argument.
exemple
:
(int)math.cei1(15.7)
valoir
16
°
pour
conversion
en
à
partir
de
string:
-
méthode
tostring(),
hériter
objet,
permettre
de
convertir
objet
en
string
-
méthode
valueof(primitivetypeexpression),
de
classe
string,
renvoyer
représentation
string
de
valeur
de
argument
-
méthode
valueof(string),
disposer
classe
enveloppe,
renvoyer
instance
de
classe
enveloppe
contenir
valeur
représenter
par
l'argument
de
type
string
exemple
:
//
convert
string
type
->
primitive
type
double
x
=
double.parsedouble("3.14159")
;
//
convert
string
type
->
wrapped
type
double
pi
=
double.valueof("3.14159")
;
//
convert
wrapped
type
->
primitive
type
int
k
=
integer.valueof("1789").intvalue()
;
//
convert
primitive
type
->
string
typer
string
pistr
=
string.valueof(3.14159)
;
//
convert
primitive
type
->
string
typer
double
pi
=
new
double(3.14159)
;
string
s
=
pi.tostring()
;
autoboxing
/
unboxing.
depuis
plate-forme
5.0
(voir
chapitrer
16),
valeur
de
type
primitif
sont,
en
cas
de
besoin,
convertir
en
l'objet
de
classe
envelopper
correspondante
(autoboxing),
(unboxing).
auparavant,
conversion
devoir
être
explicite.
6
operateurs
expression
java
posséder
nombre
considérable
d'opérateurs
arithmétiques
logiques.
expression
être
constituer
d'opérandes
d'opérateurs.
opérande
pouvoir
être
de
différentes
nature
:
variable,
constante,
appel
de
fonction.
dans
expression,
opérateur
devoir
être
explicites.
d'un
opérateur
apparaître
dans
seule
expression,
règles
de
précédence
être
utiliser
pour
déterminer
l'ordre
d'application.
s'il
être
nécessaire
d'altérer
l'ordre
normal
d'évaluation,
parenthèse
pouvoir
être
utilisées.
à
précédences
égales,
l'expression
être
évaluer
de
gauche
à
droite.
recommandation
de
style
:
+
utiliser
parenthèse
pour
isoler
sous-expressions
d'éviter
problème
de
précédence
d'opérateur
rendre
code
lisible
programmeur.
+
insérer
espace
avant
après
opérateur
autre
point
6.1
opérateur
expression
arithmétiques
opérateur
arithmétiques
binaires
opérateur
fonction
champ
d'application
/
division
réelle
réels
/
division
entière
entiers
#
modulo
(reste
de
division
entière)*
entiers
*
noter
@ord@
en
java
dans
plupart
langage
de
programmation,
a
%
b
être
signe
de
a
(alors
qu'en
mathématiques
reste
de
division
euclidienne
être
positif,
quotient
calculer
en
conséquence).
pour
java
:
a/b
=
sgn(a)*sgn(b)*|a|/|b|
;
a%b
=
a-(a/b)*b
-7
%
5
-7
/
5
en
java
-2
-1
en
math
3
-2
*
noter
@ord@
en
java,
l'opérateur
modulo
%
pouvoir
être
appliquer
sur
réels.
résultat
être
reste
obtenir
après
soustraction
de
l'opérande
droit
à
l'opérande
gauche
nombre
entier
de
fois.
toutefois,
à
cause
arrondir
de
calculs,
résultat
n'est
qu'on
attendre
(par
exemple
:
64.5
%
6.45
donne
6.449999999999998
0.0).
grande
prudence,
donc,
avec
opérateur
appliquer
sur
réels.
opérateur
arithmétiques
unaires
opérateur
fonction
champ
d'application
++
incrémentation
entiers
réels
--
décrémentation
entiers
réel
6.2
opérateur
expression
booléennes
opérateur
booléens
binaires
opérateur
fonction
&&
logique
conditionnel
*
||
logique
conditionnel
*
^
logique
exclusif
*
avec
opérateurs,
l'évaluation
de
l'expression
logique
s'arrête
dès
qu'il
être
possible
d'inférer
valeur
finale
de
l'expression
;
opérande
être
évalués.
opérateur
booléen
unaire
opérateur
fonction
!
!négation
logique
6.3
opérateur
relationnels
opérateur
relationnels
(ou
de
comparaison)
opérateur
fonction
==
égal
à
!
!=
égal
à
<
inférieur
à
<=
inférieur
égal
à
>
supérieur
à
>=
supérieur
égal
à
7
methodes
7.1
définition
appel
d'une
méthode
ordinaire
définition
d'une
procédure
définition
d'une
fonction
public
void
procname(formalparams)
public
fctlype
fctname(formalparams)
{
{
declarations
declarations
statements
statements
}
return
expression
;
}
appel
d'une
procédure
appel
d'une
fonction
appel
interne
à
classe
de
définition
:
appel
interne
à
classe
de
définition
:
procname(actualparams)
;
variable
=
fctname(actualparams)
;
appel
externe
à
classe
de
définition
:
appel
externe
à
classe
de
définition
:
-
méthode
d'instance
-
méthode
d'instance
objectname.procname(actualparams)
;
variable
=
objectname.fctname(actualparams)
;
-
méthode
de
classe
-
méthode
de
classe
classname.procname(actualparams)
;
variable
=
classname.
fctname(actualparams)
;
déclaration
d'un
paramètre
formel
spécification
d'un
paramètre
effectif
(formal
parameter)
(actual
parameter)
paramètre
d'entrée
(type
primitif
objet)
:
paramètre
d'entrée
(type
primitif
objet)
:
parametertype
parametername
expression
paramètre
de
sortie
de
type
primitif
:
paramètre
de
sortie
de
type
primitif
:
impossible
(utiliser
fonction
passer
impossible
paramètre
de
type
objet)
paramètre
de
sortie
de
type
objet
:
paramètre
de
sortie
de
type
objet
:
parametertype
parametername
objectname
+
paramètre
spécifier
dans
définition
d'une
méthode
être
appeler
paramètre
formels
;
devoir
être
précéder
de
type.
paramètre
apparaître
dans
forme
d'appel
être
appeler
paramètre
effectifs.
s'il
avoir
paramètres,
être
séparer
par
virgules.
+
paramètre
de
type
primitif
être
passer
par
valeur
(c'est
copie
de
argument
être
transmettre
à
méthode,
disposer
de
l'original).
paramètre
de
type
objet
être
passer
par
référence
(c'est
un
référence,
i.e.
pointeur,
être
transmettre
à
méthode,
l'objet
lui-même).
+
par
défaut,
méthode
être
méthode
d'instance
:
être
invoquer
sur
instance
de
classe.
exister
méthode
de
classe
pouvoir
être
invoquer
sans
instance.
spécifier
méthode
de
classe
en
déclarant
static
+
signature
[1]
d'une
méthode
être
constituer
de
nom
de
liste
type
paramètres.
dans
même
classe,
deux
méthode
pouvoir
avoir
même
signature
;
pouvoir
porter
même
nom
(cela
s'appelle
surcharge).
+
dans
méthode
d'instance
constructeur,
pouvoir
référer
à
l'objet
courir
(i.e.
l'objet
méthode
constructeur
être
en
cours
d'appel)
par
mot
clé
this.
pouvoir
référer
à
membre
(champ
méthode)
de
l'objet
courir
par
identifier
de
forme
this.membre
7.2
constructeur
constructeur
être
méthode
particulière
l'invocation
être
associer
à
création
d'une
instance
de
classe
finalité
être
d'initialiser
l'état
de
objet
de
création.
définition
d'un
constructeur
suivre
règles
syntaxiques
spécifiques
:
nom
d'un
constructeur
être
nom
de
classe
d'appartenance
;
l'en-tête
de
définition
spécifier
de
type.
syntaxe
de
définition
d'un
constructeur
d'une
classe
de
nom
classname
:
public
classname(formalparameters)
{
//
...
fields
initializations
...
}
constructeur
être
utiliser
en
association
avec
l'opérateur
new.
exemple
de
syntaxe
d'utilisation
d'un
constructeur
d'une
classe
de
nom
classname
:
classname
object
=
new
classname(actualparameters)
;
même
classe
pouvoir
comporter
constructeur
sous
condition
qu'ils
n'aient
mêmes
paramètres.
dans
cas,
pour
éviter
de
duplication
de
code,
constructeur
pouvoir
en
appeler
autre
avec
syntaxe
:
this(actualparameters).
exemple
:
public
{
private
int
x,
y;
public
pointe
int
x,
int
)
{
//
a
first
constructor
this.x
=
x;
this.y
=
y;
}
public
point()
{
//
a
second
constructor
this(
0,
0
);
}
//
...
}
[1]
à
noter
définition,
adopter
par
java,
prendre
en
considération
type
de
méthode.
en
sens,
"
signature
"
correspondre
à
être
appeler
par
"
profil
"
de
méthode.
7.3
méthode
main
méthode
main,
en
c
c++,
être
point
d'entrée
d'une
application
lancement
de
l'exécution.
syntaxe
:
public
static
void
main(string[]
args)
{
...
}
l'argument
args
capter
éventuels
argument
de
ligne
de
commande,
premier
argument
de
ligne
de
commande
être
stocker
dans
args[0]
(et
dans
args[1]
en
c/c++)
exemple
:
considérer
application
classe
principale
-
contenant
méthode
main
-
s'appelle
game.
supposer
l'application
dépendre
de
deux
paramètre
valeur
devoir
être
fournir
lancement.
supposer
fichier
source
game.
java
avoir
être
compiler
en
fichier
exécutable
game.class.
lancement
de
l'application
par
commande
:
java
game
daniel
20
attribuer
à
args
tableau
{"daniel",
"20"}
8
instruction
sur
plan
syntaxique,
instruction
(statements)
pouvoir
être
regrouper
en
3
grandes
catégorie
:
-
instruction
simples
:
instruction
d'affectation,
instruction
d'entrée
/
sortie,
instruction
d'appel
à
un
procédure.
instruction
simple
terminer
par
un
point-virgule.
point-virgule
seul
définir
instruction
vide.
-
instruction
de
contrôle
:
instruction
de
sélection,
instruction
de
boucle,
instruction
de
rupture
de
séquence.
-
bloc
d'instructions.
bloc
d'instructions
-
appeler
instruction
composer
-
être
séquence
d'instructions
enserrer
entre
accolades.
bloc
{
}
définir
instruction
vide.
8.1
instruction
d'affectation
syntaxe
:
variable
=
expression
;
symbole
=
être
l'opérateur
d'affectation.
valeur
de
l'expression
situer
en
partie
droite
être
affecter
à
variable
spécifier
en
partie
gauche.
type
de
l'expression
devoir
s'apparier
type
de
variable.
l'impact
physique
être
différent
selon
l'expression
être
de
type
primitif
objet
(voir
chapitrer
5).
8.2
instruction
de
contrôle
8.2.1
instruction
de
sélection
8.2.1.1
if-else
premier
forme
:
deuxième
forme
:
if
(expression)
{
if
(expression)
{
statements
statements
}
}
else
{
statements
}
exemple
:
if
(field.size()
==
0)
{
system.out.println("the
field
is
empty.");
}
exemple
:
if
(number
<
0)
{
reporterror();
}
else
{
processnumber(number)
;
}
exemple
:
if
(n
<
0)
{
handlenegative();
}
else
if
(n
==
0)
{
handlezero();
}
else
{
handlepositive()
;
}
8.2.1.2
switch
premier
forme
:
deuxième
forme
:
switch
(expression)
{
switch
(expression)
{
caser
value1
:
caser
value1
:
statements
;
/*
falls
through
*/
break
;
caser
value2
:
caser
value2
:
/*
falls
through
*/
statements
;
caser
value3
:
break
;
statements
;
default
:
break
;
statements
;
caser
value4
:
break
;
/*
falls
through
*/
}
caser
value5
:
statements
;
break
;
default
:
statements
;
break
;
}
+
instruction
switch
pouvoir
avoir
nombre
quelconque
de
label
caser
+
l'instruction
break
mettre
fin
à
l'instruction
switch.
a
défaut
d'instruction
break,
l'exécution
poursuivre
sur
instruction
label
suivants.
deuxième
former
ci-
exploiter
comportement
:
trois
premier
valeur
conduire
à
l'exécution
de
partie
statements
associer
à
value3
;
deux
valeur
suivantes
conduire
à
l'exécution
de
partie
statements
associer
à
value5
;
+
clause
default
être
optionnelle,
recommandée.
a
défaut,
pouvoir
qu'aucun
cas
conduire
à
exécution.
exemple
:
switch
(day)
{
case
1
:
daystring
=
"monday"
;
break
;
case
2
:
daystring
=
"tuesday"
;
break
;
case
3
:
daystring
=
"wednesday"
;
break
;
case
4
:
daystring
=
"thursday"
;
break
;
case
5
:
daystring
=
"friday"
;
break
;
case
6
:
daystring
=
"saturday"
;
break
;
case
7
:
daystring
=
"sunday"
;
break
;
default
:
error();
break;
}
exemple
:
switch
(wintermonth)
{
case
11
:
numberofdays
=
30
;
break
;
case
12
:
/*
falls
through
*/
case
1
:
numberofdays
=
31
;
break
;
case
2
:
if
(isleapyear())
{
numberofdays
=
29
;
}
else
{
numberofdays
=
28
;
}
break
;
default
:
error();
break;
}
8.2.2
instruction
de
boucle
8.2.2.1
while
boucle
while
exécuter
bloc
d'instructions
valeur
d'une
expression
donner
être
true.
l'expression
être
tester
avant
exécution
corps
de
boucle,
corps
de
boucle
pouvoir
être
exécuter
0
fois.
syntaxe
:
while
(expression)
{
statements
}
exemple
:
int
i
=
0
;
while
(1
<
text.size())
{
system.out.printl(text.get());
i++;
}
exemple
:
while
(iter.hasnext())
{
processobject(iter.next();
}
8.2.2.2
do-while
boucle
do-while
exécuter
bloc
d'instructions
valeur
d'une
expression
donner
être
true.
l'expression
être
tester
après
exécution
corps
de
boucle,
corps
de
boucle
être
exécuter
1
fois.
syntaxe
:
do
{
statements
}
while
(expression);
exemple
:
do
{
input
=
readinput()
;
if
(input
==
null)
{
system.out.printl("try
again");
}
}
while
(input
==
null);
8.2.2.3
for
boucle
for
s'exécute
qu'une
condition
s'évalue
à
true.
avant
boucle
démarre,
instruction
d'initialisation
être
exécuter
1
fois.
condition
être
évaluer
avant
exécution
corps
de
boucle
(comme
pour
boucle
while).
instruction
de
mise
à
jour
variables
être
exécuter
après
exécution
corps
de
boucle.
syntaxe
:
for
(initialization;
condition;
update)
{
statements
}
exemple
:
for
(int
1
=
0;
1
<
text.size();
i++)
{
system.out.println(text.get())
;
}
8.2.2.4
foreach
depuis
plate-forme
5.0
(voir
chapitrer
16),
java
offrir
boucle
for
améliorer
pour
parcourir
élément
d'un
tableau
d'une
collection
(se
reporter
section
respectives).
syntaxe
:
//
for
each
element
of
the
collection,
process
element
for
(typeofelements
element
:
collectionofelements)
{
//
...
process
element
...
}
8.3
instruction
d'entrée
/
sortir
java
offrir
nombre
considérable
de
fonction
procédure
d'entrée
/
sortie,
en
mode
texte
graphique.
limiter
dans
section
principales
instruction
d'entrées/sorties
en
mode
texte
;
pour
entrées/sorties
en
mode
graphique,
voir
chapitre
11.
méthode
d'entrée
/
sortie
primaires
appartenir
classe
paquetage
java.
io.
depuis
plate-forme
5.0
(voir
chapitrer
16),
classe
scanner
paquetage
java.uti1
offrir
:
-
fonctionnalité
de
base
pour
lire
donnée
depuis
flux
d'entrée
;
-
sortie
formater
en
c.
en
complément,
classe
java.util.formatter
permettre
de
spécifier
format
d'entrée
de
sortie.
8.3.1
notion
de
flux
flux
flot
(streams
en
anglais)
généraliser
notion
de
périphérique
d'entrée
/
sortie.
flux
pouvoir
être
voir
interface
intelligente
unidirectionnelle
relier
machine
java
périphérique,
permet,
en
lecture
qu'en
écriture,
de
s'affranchir
spécificité
périphérique
concerné.
réaliser
entrée
/
sortie
consister
à
:
1)
créer
flux
type
approprié
(sauf
s'il
exister
déjà,
être
prédéfini
(system.in,
system.out
system.err))
2)
lire
écrire,
selon
cas,
dans
flux
3)
souvent,
dans
cas
d'une
lecture,
convertir
donnée
lire
dans
type
cibler
souhaiter
pour
premier
approche,
limiter
à
flux
à
accès
séquentiel.
8.3.2
entrée
/
sortie
terminal
solution
suivantes
s'affranchissent
erreur
de
saisie.
pour
gérer
type
d'erreur,
reporter
chapitre
excepter
(chapitre
10).
8.3.2.1
affichage
écran
syntaxe
d'un
affichage
écran
en
mode
texte
:
system.out.print(string);
system.out.println(string);
system.out.print(primitivetypeexpression)
;
system.out.println(primitivetypeexpresstion)
;
8.3.2.2
affichage
formater
depuis
plate-forme
5.0,
java
offrir
méthode
printf
permettre
sortie
formater
en
c
(voir
classer
java.util.formatter
pour
spécification
formats).
exemple
:
system.out.println("count
=
"
+
count);
system.out.printf("%s
%5d
\n",
user,
total);
fonctionnement
printf
code
de
formatage
:
printf
réclamer
chaîne
de
caractère
en
premier
paramètre.
chaîne
pouvoir
être
suivre
de
n
variables,
n>0.
c'est
chaîne,
pouvoir
contenir
code
de
formatage,
être
imprimée.
code
de
formatage
commencer
par
caractère
%.
a
fois
qu'un
coder
de
formatage
être
rencontré,
printf
imprimer
variable
suivante
dans
liste
de
paramètres.
principaux
code
de
formatage
commander
l'affichage
d'une
valeur
de
type
:
%c
caractère
%d
entier
%e
réel
(en
notation
avec
exposant)
%f
réel
#s
chaîne
de
caractère
code
de
formatage
pouvoir
inclure
spécification
de
format
champ
d'affichage.
exemple
de
code
de
formatage
champ
d'affichage
spécifier
pour
paramètre
type
considérer
:
%6d
champ
de
6
caractère
%-6d
champ
de
6
caractère
avec
justification
à
gauche
%8.2f
champ
de
8
caractère
2
à
droite
de
virgule
8.3.2.3
lecture
clavier
exemple
:
scanner
input
=
new
scanner(system.in);
string
s1
=
input.next()
;
//
read
avoir
string
(a
word)
string
s2
=
input.nextline();
//
read
the
rest
of
the
line
int
n
=
input.nextint();
//
read
an
integer
doubler
r
=
input.nextdouble();
//
read
avoir
double
input.close();
8.3.3
entrée
/
sortir
fichier
opérer
sur
fichier
consister
à
:
1)
créer
flux
approprier
opération
souhaiter
2)
lire
écrire
dans
fichier
3)
fermer
fichier
solution
suivantes
s'affranchissent
erreur
d'entrée
/
sortie.
pour
gérer
type
d'erreur,
reporter
chapitre
excepter
(chapitre
10).
8.3.3.1
ecriture
fichier
depuis
plate-forme
5.0,
java
offrir
méthode
printf
permettre
sortie
formater
en
c
(voir
classer
java.util.formatter
pour
spécification
formats).
exemple
d'écriture
dans
fichier
texte
:
printwriter
=
new
printwriter(outputfilename)
;
for
(int
i=0;
i<10;
i++)
out.printf("%c%d",'\t',i);
out.close();
8.3.3.2
lecture
fichier
exemple
de
lecture
d'un
fichier
texte
mot
à
mot
:
scanner
in
=
new
scanner(new
file(inputfilename))
;
string
s
;
while
(in.hasnext())
{
s
=
in.next();
//
read
avoir
string
(a
word)
system.out.println(s);
}
in.close();
8.3.3.3
contexte
particulier
cas1.
ouverture
en
lecture
d'un
fichier
texte
stocker
dans
fichier
.jar
exécuter
import
java.io.inputstream
;
import
java.util.scanner
;
classloader
cl
=
classloader.getsystemclassloader()
;
inputstream
is
=
cl.getresourceasstream(inputfilename)
;
scanner
in
=
new
scanner(is);
cas2.
ouverture
en
lecture
d'un
fichier
texte
distant
identifier
par
url
import
java.net.url;
import
java.util.scanner;
url
url
=
new
url("http://www.esiee.fr/.../inputfilename")
;
scanner
in
=
new
scanner
(url.openstream());
nota.
solution
applicable
depuis
applet.
en
outre,
s'assurer
condition
d'accessibilité
fichier
être
levée
(pas
d'interdiction
par
pare-feu
local
notamment!
!)
cas3.
ouverture
d'une
nouvelle
page
html
depuis
applet
(de
répertoire)
import
java.net.url;
import
javax.swing.japplet;
url
url
=
new
url(getdocumentbase(),
"myfile.html");
getappletcontext().showdocument(url,
"_blank");
repaint()
;
8.3.4
lecture
d'une
chaîne
de
caractère
formater
être
fréquent
d'avoir
à
lire
chaîne
de
caractère
connaître
format,
flux
d'entrée
(terminal
fichier).
depuis
plate-forme
5.0,
classe
scanner
paquetage
java.util
offrir
fonctionnalité
pratiques.
exemple
de
lecture
d'une
chaîne
de
caractère
formater
:
string
str
=
"1
xxx
2
xxx
yellow
xxx
blue
xxx'"';
scanner
in
=
new
scanner(str).usedelimiter("\\s*xxx\\s*")
;
system.out.println(in.nextint());
system.out.println(in.nextint());
system.out.println(in.next());
system.out.println(in.next());
in.close();
//
will
display
:
//
1
//
2
//
yellow
//
blue
9
heritage
9.1
notion
d'héritage
l'héritage
être
technique
offrir
de
nombreux
avantage
:
-
éviter
duplication
de
code
-
permettre
réutilisation
de
code
dans
autre
contexte
-
faciliter
maintenance
programme
-
faciliter
l'extension
d'applications
existantes.
l'héritage
(inheritance)
être
relation
"
est_un
"
(non
"
a_un
"!!!
!!!)
permettre
de
définir
classe
l'extension
d'une
autre.
exemple
:
classe
astre
est_un
est_un
classe
etoile
classer
planète
étoile
être
astre
;
planète
être
astre.
classe
etoile
étendre
classe
astre
=
classe
etoile
hériter
de
classe
astre.
super-classe
être
classe
être
étendre
par
d'autres
classes.
sous-classe
être
classe
étendre
(hérite
de)
autre
classe.
hériter
l'état
comportement
de
ancêtres,
pouvoir
redéfinir.
classe
être
lier
par
relation
d'héritage
former
hiérarchie
d'héritage.
exemple
de
hiérarchie
d'héritage
:
astre
etoile
planeter
exoplanète
planeter
solaire
pégaside
chtonienne
tellurique
habitable
constructeur
d'une
sous-classe
devoir
invoquer
constructeur
de
super-classe
en
premier
instruction
(à
défaut,
java
essayer
d'insérer
appel
automatique).
forme
d'appel
être
suivante
:
super(actualparameters)
;
classe
sans
super-classe
explicite
avoir
object
super-classe.
pour
hiérarchie
de
classes,
type
former
hiérarchie
de
types.
type
définir
par
définition
d'une
sous-classe
être
sous-type
type
définir
par
super-classe.
exemple
:
etoile
être
sous-type
type
astre
variable
pouvoir
contenir
:
-
objet
type
déclarer
de
variable
-
objet
de
sous-type
de
type
déclarer
exemple
:
astre
al
=
new
astre();
//
correct
astre
a2
=
new
etoile);
//
correct
(transtypage
ascendant)
astre
a3
=
new
planete();
//
correct
(transtypage
ascendant)
etoile
el
=
new
astre();
//
erreur
etoile
e3
=
(etoile)a2
;
//
correct
(un
transtypage
descendre
//
devoir
être
explicite)
objet
d'un
sous-type
utiliser
objet
d'un
super-type
être
attendu.
s'appelle
substitution.
java
permettre
l'héritage
multiple
:
sous-classe
pouvoir
hériter
d'une
seule
super-classe.
9.2
qu'hérite
sous-classe
?
sous-classe
hériter
de
membre
de
super-classe
être
accessibles,
sauf
membre
(attribut
méthode)
être
redéfinir
dans
sous-classe.
sous-classe
hériter
de
super-classe
:
-
membre
déclarer
public
protected
-
membre
déclarer
sans
modificateur
d'accès,
sous-classe
être
dans
même
paquetage
super-classe.
sous-classe
n'hérite
de
super-classe
:
-
membre
être
redéfinir
dans
sous-classe
-
constructeurs.
attention
choix
identificateurs
dans
sous-classe
:
choix
pouvoir
masquer
membre
de
super-classe!
!c'est
cas
pour
attribut
:
attribut
avoir
même
nom
qu'un
attribut
de
super-classe
masquer
l'attribut
de
super-
classe,
même
s'ils
être
de
type
différents.
9.3
redéfinir
méthode
pour
redéfinir
méthode
dans
sous-classe,
falloir
qu'elle
avoir
même
signature
même
type
de
retour
méthode
de
super-classe.
méthode
redéfinir
pouvoir
autoriser
accès
large
(ex
:
méthode
déclarer
protected
dans
super-
classe
pouvoir
être
redéfinir
public
dans
sous-classe,
private).
l'exemple
typique
être
méthode
tostring
de
classe
object
:
appliquer
à
objet,
produire
chaîne
de
caractère
former
nom
de
classe
de
code
de
hachage,
méthode
pouvoir
être
redéfinir
dans
classe.
méthode
redéfinir
dans
sous-classe
avoir
besoin
d'ajouter
fonctionnalité
complémentaires
à
de
méthode
de
super-classe,
n'est
besoin
de
réécrire
pouvoir
appeler
méthode
de
super-classe
par
:
super.superclassmethodname(actualparameters)
règles
:
-
méthode
d'instance
pouvoir
redéfinir
méthode
de
classe,
-
méthode
d'instance
d'une
sous-classe
avoir
mêmes
signature
type
qu'une
méthode
d'instance
dans
super-classe
redéfinir
méthode
de
super-classe
:
version
de
méthode
invoquer
sur
instance
de
sous-classe
(type
dynamique
liaison
dynamique
méthode
d'instance)
être
de
sous-classe.
-
méthode
de
classe
d'une
sous-classe
avoir
mêmes
signature
type
qu'une
méthode
de
classe
dans
super-classe
masquer
méthode
de
super-classe
:
version
de
méthode
invoquer
dépendre
de
être
appeler
sur
super-classe
sur
sous-classe
(car
liaison
statique
méthode
de
classe).
-
sous-classe
pouvoir
redéfinir
méthode
déclarer
final
de
super-classe
-
sous-classe
devoir
redéfinir
méthode
déclarer
abstract
dans
super-classe,
à
sous-classe
déclarer
abstract.
depuis
plate-forme
5.0
(voir
chapitrer
16)
:
être
conseiller
d'utiliser
l'annotation
(ou
méta-donnée)
@override
pour
marquer
méthode
être
supposer
redéfinir
méthode
hériter
d'une
classe
parent.
permettre
compilateur
de
signaler
erreur
redéfinition
n'est
avérer
(à
cause
par
exemple
d'une
faute
de
frappe
dans
nom
de
méthode).
en
outre,
en
signaler
méthode
redéfinies,
l'annotation
@override
permettre
d'accroître
lisibilité
code.
covariance
type
de
retour
être
autoriser
:
méthode
d'une
sous-classe
pouvoir
retourner
objet
type
être
sous-classe
type
retourner
par
méthode
de
même
signature
dans
super-classe.
caractéristique
supprimer
besoin
de
test
de
conversion
de
type
excessifs.
exemple
:
@override
public
string
tostring()
{
//
...
}
exemple
:
classe
point
posséder
deux
attribut
x
;
classe
coloredpoint
hériter
de
point
posséder
attribut
spécifique
color.
écrire
méthode
equals
sans
duplication
de
code
?
/*
in
the
*/
@override
public
boolean
equals(
object
o
)
{
if
(o
==
null
)
return
false;
//
caser
null
if
(
this
==
o
)
return
true;
//
reflexivity
if
(
this.getclass()!
!=
o.getclass()
)
return
false;
//
symmetry
//
now,
this
and
o
having
the
same
class,
comparer
the
fields
point
p
=
(point)o;
return
(this.x
==
p.x
)
&&
(
this.y
==
p.y
)
;
}
/*
in
the
coloredpoint
extending
*/
@override
public
boolean
equals(
object
o
)
{
//
verify
if
this
and
o
haver
the
same
and
if
their
super
//
fields
are
equal
if
(!
!super.equals(o)
)
return
false;
//
now
comparer
the
specific
fields
coloredpoint
cp
=
(coloredpoint)o;
return
this.color.equals(cp.color)
;
}
exemple
:
public
class
motherclass
{
public
void
normal()
{
system.out.println("the
normal
method
in
motherclass")
;
}
public
static
void
hide()
{
system.out.println("the
hide
method
in
motherclass")
;
}
public
void
override()
{
system.out.println("the
override
method
in
motherclass");
}
}
//
end
motherclass
public
class
daughterclass
extends
motherclass
{
@override
public
static
void
hide()
{
system.out.println("the
hide
method
in
daughterclass");
}
@override
public
void
override()
{
system.out.println("the
override
method
in
daughterclass")
;
}
public
static
void
main(string[]
args)
{
daughterclass
o1
=
new
daughterclass()
;
motherclass
o2
o1
;
o1.normal()
;
//
call
super.normal()
o2.normal()
;
//
call
super.normal()
o1.hide();
//
call
this.hide()
o2.hide();
//
call
super.hide()!!
!!liaison
statique
o1.override();
//
call
this.override()
o2.override();
//
call
this.override()!!
!!tiaison
dynamique
}
}
//
end
daughterclass
méthode
main
afficher
:
the
normal
method
in
motherclass
the
normal
method
in
motherclass
the
hide
method
in
daugterclass
the
hide
method
in
motherclass
the
override
method
in
daugterclass
the
override
method
in
daugterclass
9.4
type
statique
/
dynamique
-
liaison
statique
/
dynamique
section
reprendre
formaliser
un
importants
concept
introduire
dans
section
précédentes.
9.4.1
type
statique
/
dynamique
-
transtypage
type
statique
d'un
objet
être
type
spécifier
par
déclaration.
c'est
type
déclaré.
c'est
type
à
compilation.
type
dynamique
d'un
objet
être
type
(i.e.
classe
d'appartenance)
de
l'objet
instancié.
c'est
type
constaté.
c'est
type
effectif
à
l'exécution.
type
dynamique
d'un
objet
être
type
statique
sous-type
de
type
statique
(sauf
excepter
devoir
transtypages).
exemple
:
être
classe
a
classe
b
sous-classe
de
a.
considérer
code
suivre
:
avoir
avoir
;
if
(
myclass.booleanrandom()
)
{
avoir
=
new
a()
;
}
else
{
avoir
=
new
b()
;
//
transtypage
ascendre
implicite
}
type
statique
de
avoir
être
a
;
type
dynamique
de
avoir
être
a
b
pouvoir
être
constater
qu'après
condition
avoir
être
évaluée.
transtypage
(casting)
appliquer
à
référence
n'est
possibilité
d'avoir
vue
spécifique
de
l'objet
pointé.
changer
en
type
de
l'objet
sous-jacent!
!(qui
garder
long
de
vie
type
avec
avoir
être
créé).
l'opération
de
transtypage
être
syntaxique
faire
qu'indiquer
compilateur
point
de
vue
depuis
devoir
voir
l'objet.
transtypage
vers
sur-type
être
dire
ascendant.
transtypage
ascendant
être
implicite.
transtypage
vers
sous-type
être
dire
descendant.
transtypage
descendant
devoir
être
explicite.
permettre
de
forcer
compilation
garantir
l'absence
d'erreur
d'exécution.
transtypage
n'est
garantir
correct
s'il
respecter
règle
suivante
:
être
t1
t2
deux
type
définis.
o
objet
de
type
dynamique
t3.
considérer
déclaration
:
t1
obj
=
(t2)o;
transtypage
être
garantir
possible,
à
compilation
qu'à
l'exécution,
t3
être
sous-type
de
t2
t2
sous-type
de
t1.
l'opérateur
instanceof
permettre
de
tester
objet
être
d'un
type
dynamique
donner
de
sous-type
de
type
donné.
pouvoir
permettre
vérifier
compatibilité
type
avant
d'opérer
transtypage.
exemple
:
supposer
définir
:
public
shape2d
{
...
}
public
class
circle
extends
shape2d
{
...
}
public
class
triangle
extends
shape2d
{
...
}
public
class
date
{
...
}
déclaration
suivantes
génèreraient
erreur
pour
incompatibilité
de
type
:
shape2d
s
=
(shape2d)
(new
date())
;
//
erreur
de
compilation
circle
c
=
new
shape2d()
;
//
erreur
de
compilation
circle
c
=
(circle)(new
shape2d())
;
//
erreur
d'exécution
triangle
t
=
new
triangle()
;
circle
c
=
(circle)t
;
//
erreur
d'exécution
déclaration
suivantes
être
saines
:
shape2d
s
=
new
circle()
;
circle
c
=
(circle)s
;
shape2d
s
;
if
(
obj
instanceof
shape2d
)
s
=
(shaped2d)obj
;
9.4.2
liaison
statique
/
dynamique
considérer
l'invocation
o.m
o
être
objet
de
type
statique
t
de
type
dynamique
t',
m
message
(attribut
méthode)
envoyer
à
o.
message
m
exécuter
être
code
être
accessible
depuis
classe
t,
liaison
de
l'objet
message
être
dire
statique
(liaison
à
compilation)
être
dire
dynamique
(liaison
à
l'exécution).
en
java
:
-
liaison
d'un
objet
avec
variables
d'instance
être
statique
;
-
liaison
d'un
objet
avec
méthode
être
dynamique
(sauf
méthode
static
final).
exemple
:
public
class
a
{
public
boolean
m1(a
a)
{
return
true
;
}
public
boolean
m2(a
a)
{
return
true
;
}
}
public
class
b
extends
a
{
public
boolean
m1(a
a)
{
return
false
;
}
public
boolean
m3(a
a)
{
return
false
;
}
public
static
void
main(string[]
args)
{
a
avoir
=
new
b()
;
system.out.prinln(a.m1(a));
system.out.prinln(a.m2(a));
//
system.out.prinln(a.m3(a));
//
problème
}
}
méthode
main
afficher
:
false
true
?
type
statique
de
avoir
être
a,
type
dynamique
b.
c'est
m1
de
b
être
exécutée.
quant
à
méthode
m2,
n'est
définir
dans
b
dans
super-classe
a
:
b
hériter
de
m2
m2
être
exécutée.
dernière
instruction
system.out.prinln(a.m3(a))
provoquer
erreur
à
compilation.
?
compilateur
connaître
type
statique
(i.e.
type
déclaré)
:
méthode
m3
n'étant
définir
dans
classe
a
dans
un
de
super-classes,
compilateur
trouver
définition
de
m3
(bien
dans
b)
générer
erreur.
solution
être
transtypage
descendre
préalable
de
avoir
:
system.out.prinln(((b)a).m3(a)).
transtypage
être
correct
à
posséder
déjà,
par
création,
attribut
d'une
instance
de
b.
9.5
polymorphisme
même
appel
de
méthode
pouvoir
invoquer
méthode
différentes
liaison
être
réaliser
(i.e.
à
l'exécution
à
compilation),
l'identification
type
de
l'objet
associer
à
l'appel
être
dynamique.
exemple
de
polymorphisme
d'héritage
:
public
shape
{
public
void
draw()
{
system.out.println(
this
+
".draw();"
);
}
}
public
class
circle
extends
shape
{
@override
public
string
tostring()
{
return
"circle";
}
}
public
class
square
extends
shape
{
@override
public
string
tostring()
{
return
"square";
}
}
public
class
picture
{
public
static
void
main(string[]
args)
{
vector<shape>
v
=
new
vector<shape>()
;
v.add(
new
circle()
);
v.add(
new
square()
);
for
(shape
s
:
v)
{
system.out.prinln(
s.draw()
);
//
polymorphism
}
méthode
main
afficher
:
circle.draw();
square.draw()
;
9.6
classe
méthode
particulières
classe
déclarer
final
pouvoir
être
sous-classée.
méthode
déclarer
final
pouvoir
être
redéfinir
dans
un
sous-classe.
classe
déclarer
abstract
représenter
concept
abstrait
:
pouvoir
être
instanciée
pouvoir
être
sous-classée.
méthode
déclarer
abstract
être
méthode
corps
n'est
spécifié.
classe
abstraite
pouvoir
contenir
méthode
abstraites,
classe
contenir
méthode
abstraite
devoir
être
déclarer
abstract.
sous-classe
n'implémente
méthode
abstraire
de
super-classe,
devoir
être
déclarer
abstract.
9.7
interface
interface
(au
sens
langage
java,
cf
section
3.3)
être
protocole
de
comportement
pouvoir
être
implanter
par
classe.
interface
être
en
dehors
de
hiérarchie
classes.
interface
différencier
d'une
classer
abstraire
par
caractéristique
:
-
méthode
concrète
(par
opposition
à
abstraite)
pouvoir
être
définir
dans
interface
;
-
classe
pouvoir
implémenter
interfaces.
pouvoir
construire
hiérarchie
de
classes,
pouvoir
construire
hiérarchie
d'interfaces.
qu'une
classe
pouvoir
étendre
qu'une
seule
super-classe,
(pas
d'héritage
multiple),
interface
pouvoir
étendre
super-interfaces
(héritage
multiple
possible).
exemple
:
public
interface
list<e>
extends
collection<e>
{
...
}
exemple
:
public
interface
predator
{
boolean
chaseprey(prey
p);
}
public
interface
prey
{
boolean
ischasedby(predator
p);
}
public
interface
venomous
{
...
}
public
interface
venomouspredator
extends
predator,
venomous
{
...
}
public
class
pet
{
...
}
public
class
cat
extends
pet
implements
predator
{
...
}
public
class
frog
implements
predator,
prey
{
...
}
10
exception
exception
être
objet
fournir
information
relatives
à
défaillance
programme.
exception
être
générer
dans
situation
suivantes
:
-
condition
d'exécution
anormale,
par
exemple
:
tentative
de
division
par
zéro,
mémoire
insuffisante,
-
exécution
d'une
instruction
throw
paquetage
java.
lang
définir
nombre
de
classe
d'exception
couvrir
cas
courants.
10.1
exception
contrôler
contrôler
exception
être
instance
de
classe
throwable
de
sous-classe
:
object
throwable
error
exception
mycheckedexception
runtimeexception
myuncheckedexception
java
diviser
classe
d'exception
en
deux
catégorie
:
-
exception
contrôler
(unchecked).
exception
concerner
cas
"
imprévus
",
situation
devoir
avoir
de
défaillance
en
fonctionnement
normal.
concerner
situation
pouvoir
être
éviter
(exemple
:
indice
de
tableau
hors
limite).
exception
indiquer
erreur
de
programme.
avoir
vocation
à
conduire
à
arrêt
immédiat
définitif
programme.
-
exception
contrôler
(checked).
exception
concerner
cas
"
prévus
",
situation
programmeur
devoir
s'attendre
à
qu'une
opération
pouvoir
échouer.
concerner
situation
de
défaillance
être
contrôle
programmeur
(exemple
:
disque
devenir
plein
rendre
impossible
écriture
dans
fichier).
exception
avoir
vocation
à
être
récupérer
pour
permettre
programme
de
poursuivre
normalement.
gestion
d'une
exception
contrôler
imposer
l'utilisation
de
clause
throws
de
l'instruction
de
contrôle
try
..
catch.
exception
contrôler
être
classe
runtimeexception,
error
sous-
classe
;
autres
classe
sous-classe
être
exception
contrôlées.
10.2
classe
d'exception
standard
10.2.1
hiérarchie
error
classe
error
être
super-classe
d'une
hiérarchie
d'erreurs
graves
contrôlées.
hiérarchie
être
réserver
erreur
d'exécution
système.
exemple
de
sous-
classe
prédéfinies
:
nosuchmethoderror
stackoverflowerror
outofmemoryerror
illegalaccesserror
10.22
hiérarchie
exception
classe
exception
être
super-classe
d'une
hiérarchie
d'exceptions,
exclusion
faire
de
sous-hiérarchie
runtimeexception,
contrôlées.
exemple
de
sous-classe
d'exceptions
contrôler
prédéfinies
:
dataformatexception
ioexception
eofexception
filenotfoundexception
10.23
hiérarchie
runtimeexception
classe
runtimeexception
être
super-classe
d'une
hiérarchie
d'exceptions
contrôlées.
exemple
de
sous-classe
prédéfinies
:
arithmeticexception
illegalargumentexception
numberformatexception
illegalstateexception
indexoutofboundsexception
nullpointerexception
10.3
lancement
d'une
exception
l'instruction
throw
permettre
de
lancer
un
exception.
être
recommander
de
l'appliquer
qu'à
exception
contrôlées.
syntaxe
:
throw
new
classofexception("
diagnostic
message
to
print")
;
exemple
:
if
(key
==
null)
{
throw
new
nullpointerexception("null
key
found
in
method
x");
}
exemple
:
if
(key
==
0)
{
throw
new
illegalargumentexception("empty
key
received")
;
}
exemple
(dans
constructeur)
:
if
(this.name.length()
==
0)
{
throw
new
illegalstateexception(
"name
must
be
provided
-
"
+
"object
creation
aborted"
);
}
exemple.
l'opération
remove()
de
l'interface
iterator
être
spécifier
optionnelle,
implémentation
pouvoir
être
dans
cas
:
public
void
remove()
{
throw
new
unsupportedoperationexception()
;
}
10.4
capture
d'une
exception
capture
d'une
exception
n'est
obligatoire
pour
exception
l'on
vouloir
contrôler.
dans
cas
exception
contrôlées,
compilateur
renforcer
contrôle
à
fois
dans
méthode
lancer
exception
dans
l'appelant
de
méthode.
10.41
clause
throws
clause
throws
être
déclaration
ajouter
à
l'en-tête
d'une
méthode
susceptible
de
lever
exception
contrôlée.
déclarer
exception
contrôler
à
prendre
en
compte
dans
cadre
de
méthode.
être
nécessaire
compilateur
pouvoir
savoir
excepter
contrôler.
par
convention,
exception
contrôler
devoir
être
incluses
dans
clause
throws.
syntaxe
:
throws
exceptionclass1,
exceptionclass2,
...
exemple
:
public
void
savetofile(string
filename)
throws
ioexception
{
...
}
10.42
instruction
try
..
catch
l'instruction
try
..
catch
permettre
de
capturer
exception
générer
par
l'appel
d'une
méthode.
exception
être
générée,
contrôle
être
transférer
code
avoir
générer
l'exception
à
clause
catch
avoir
capturer
l'exception.
clause
catch
devoir
avoir
seul
paramètre
formel.
type
de
paramètre
devoir
être
classe
throwable
de
sous-classes.
instruction
try
pouvoir
contenir
bloc
catch.
dans
cas,
l'exception
générale
devoir
être
traiter
en
dernier.
syntaxe
:
try
{
//
protect
one
more
statement
here
}
catch
(exceptionclass
e)
{
//
report
and
recover
from
the
exception
here
}
finally
{
//
in
fine,
in
any
case,
always
execute
these
statements
}
bloc
finally
être
optionnel,
permettre
d'éviter
duplication
de
code.
exemple
(à
partir
de
plate-forme
5.0)
:
//
read
avoir
double
from
the
standard
input
stream
scanner
input
=
new
scanner(system.in);
doubler
x
;
try
{
x
=
input.nextdouble()
;
}
catch(inputmismatchexception
e)
{
system.err.println("error
-
double
waited
-
"
+
e);
}
input.close()
;
exemple
(à
partir
de
plate-forme
5.0)
:
//
create
avoir
copy
of
avoir
text
filer
scanner
in
=
null
;
printwriter
=
null
;
try
{
in
=
new
scanner(new
file(inputfilename))
;
=
new
printwriter(outputfilename)
;
while
(in.hasnext())
{
out.println(in.nextline());
}
}
catch
(exception
e)
{
system.err.println("error
in
reading/writing
file
-
"
+
e);
}
finally
{
if
(in!
!=
null)
in.close())
;
if
(out!
!=
null)
out.close()
;
}
exemple
(à
partir
de
plate-forme
5.0)
:
//
read
and
print
avoir
text
file
of
doubles
scanner
in
=
null
;
try
{
in
=
new
scanner(new
file(inputfilename))
;
while(in.hasnext())
{
system.out.println(double.parsedouble(in.next()))
;
}
}
catch
(filenotfoundexception
e)
{
system.err.println("unable
to
open
the
input
file."
+
e);
}
catch
(numberformatexception
e)
{
system.err.println("a
token
is
not
avoir
double."
+
e)
;
}
catch
(exception
e)
'
system.err.println("problem
in
reading
the
file
"
+
e)
;
}
finally
{
if
(in!
!=
null
)
{
try
{
in.close()
;
}
catch
(exception
e)
{
system.err.println("error
in
closing
the
file."
+
e)
;
}
}
10.5
définir
nouvelle
classe
d'exception
un
principales
raison
conduire
à
définition
d'une
nouvelle
classe
d'exception
être
besoin
d'inclure
information
complémentaires
dans
l'objet
exception
de
permettre
diagnostic
récupération
de
l'erreur.
nouvelle
classe
d'exception
être
définir
sous-classe
d'une
classe
d'exception
existante
de
hiérarchie
exception.
exemple
:
public
class
wrongvalueexception
extends
exception
{
private
string
key
;
public
wrongvalueexception(string
key)
{
this.key
=
key;
}
public
string
getkey()
{
return
key
;
}
public
string
tostring()
{
return
"wrong
valoir
"
+
key
+
"
found"
;
}
}
11
annexe
1
-
programmation
graphique
référence
:
base
de
swing
exemple
de
programmation
d'interfaces
graphiques
:
java.sun.com/docs/books/tutorial/uiswing/mini/index.html
gestion
événement
exemple
de
programmation
:
java.sun.com/docs/books/tutorial/uiswing/events/api.html
swing
architecturer
overview
java.sun.com/products/jfc/isc/articles/architecture
chapitre
introduire
à
programmation
graphique
avec
bibliothèque
javax.swing
11.1
swing
exister
deux
grands
paquetage
d'utilitaires
java
pour
réaliser
interface
graphiques
:
-
awt
(abstract
window
toolkit)
:
paquetage
primitif.
composant
de
paquetage
s'importent
par
:
import
java.awt.*
;
-
swing
:
récent
évolué,
construire
sur
awt,
c'est
paquetage
recommandé.
composant
de
paquetage
s'importent
par
:
import
javax.swing.*
;
deux
paquetage
swing
utiliser
être
:
javax.swing
javax.swing.event
classe
de
javax.swing
courantes
être
:
jframe
jpanel
jlabel
jtextfield
jbutton
joptionpane
exemple
de
saisie
/
affichage
dans
boîte
de
dialogue
:
//
import
javax.swing.joptionpane
;
//
user
method
showinputdialog
to
prompt
for
some
input
string
inputvalue
=
joptionpane.showinputdialog("value
?");
//
user
method
showmessagedialog
to
display
avoir
message
joptionpane.showmessagedialog(null,"a
message
...")
11.2
conteneur
composants
objet
graphique
être
composer
de
différents
objet
:
conteneur
(containers)
composant
atomiques,
différents
constituant
être
organiser
en
hiérarchie
d'inclusion.
principales
catégorie
de
conteneur
composants
:
+
conteneur
de
haut
niveau
pour
qu'un
objet
graphique
pouvoir
être
afficher
à
l'écran,
hiérarchie
de
constituant
devoir
avoir
pour
racine
l'un
trois
conteneur
suivants
:
>
frame
(classe
jframe)
:
conteneur
général,
fournir
fenêtre
principale
dans
autres
composants
swing
pouvoir
dessiner.
>
dialog
(classe
jdialog)
:
limiter
qu'un
frame,
fournir
fenêtre
de
dialogue
;
classe
j0ptionpane
permettre
de
créer
fenêtre
de
dialogue
simples
standard
;
classe
jdialog
permettre
de
créer
fenêtre
de
dialogue
personnalisées.
>
applet
(classe
japplet)
:
spécialiser
pour
interface
web,
fournir
fenêtre
être
afficher
par
navigateur
web.
+
conteneur
intermédiaires,
:
>
panel
(classe
jpanel)
:
simplifier
positionnement
objet
graphiques
atomiques.
conteneur
de
haut
niveau
contenir
conteneur
intermédiaire
spécial
appeler
contentpane.
c'est
conteneur
intermédiaire
principal.
contenir
panels.
+
composants
atomiques,
par
exemple
:
>
button
(classe
jbutton)
>
label
(classe
jlabel)
>
text
field
(classe
jtextfield)
sauf
pour
conteneur
de
haut
niveau,
composants
(conteneur
intermédiaire
composer
atomique)
commencer
par
j
hériter
de
classe
jcomponent.
pour
ajouter
objet
à
conteneur,
utiliser
méthode
add.
méthode
prendre
en
général
deuxième
argument
spécifier
mise
en
page.
exemple
:
//
import
javax.swing.*
;
frame
=
new
jframe(.
.
.);
paner
=
new
jpanel();
button
=
new
jbutton(.
.
.);
label
=
new
jlabel(.
.
.);
pane.add(button)
;
pane.add(1abel)
;
frame.getcontentpane().add(pane,
borderlayout.center)
;
frame.pack();
//
sizes
at
or
above
preferred
sizes
frame.setvisible(true);
//
l'objet
frame
créer
avoir
pour
hiérarchie
:
jframe
contentpane
jpanel
jbutton
jlabel
exemple
:
import
javax.swing.japplet
;
public
appletexample
extends
japplet
{
public
void
init
)
{
jpanel
paner
=
new
jpanel()
;
pane.add(new
jlabel("hello,
world!
!")
;
this.setcontentpane(pane)
;
11.3
gestion
de
mise
en
page
mise
en
page
(layout)
consister
à
fixer
taille
position
composants.
conteneur
posséder
gestionnaire
de
mise
en
page
par
défaut.
s'il
convient
pas,
pouvoir
remplacer.
composant
pouvoir
solliciter
taille
alignement
donnés,
mais,
in
fine,
c'est
gestionnaire
de
mise
en
page
conteneur
conserver
décision
finale.
exister
6
gestionnaire
de
mise
en
page
:
+
borderlayout
:
gestionnaire
de
mise
en
page
par
défaut
pour
contentpane
;
définir
5
zone
de
placement
:
north,
south,
east,
west,
center
+
flowlayout
:
gestionnaire
de
mise
en
page
par
défaut
jpanel
;
positionner
composant
de
gauche
à
droite,
passer
à
nouvelle
ligne
nécessaire
+
boxlayout
:
gestionnaire
de
mise
en
page
flexible
;
positionner
composant
sur
seule
ligne
colonne
en
respecter
attente
de
composant
en
matière
de
taille
maximale
d'alignement
+
gridlayout
:
gestionnaire
de
mise
en
page
simple
;
créer
ensemble
de
composant
de
même
taille
affiche
dans
nombre
de
ligne
de
colonne
spécifier
+
gridbaglayout
:
gestionnaire
de
mise
en
page
sophistiqué
flexible
;
aligner
composant
en
placer
dans
grille
de
cellules,
permettre
à
de
s'étendre
sur
cellule
(les
largeur
rangée
hauteur
colonnes,
respectivement,
pouvoir
être
différentes)
+
cardlayout
:
gestionnaire
de
mise
en
page
pour
usage
spécial
;
permettre
d'implémenter
zone
contenir
différents
composant
à
différents
moment
;
utiliser
en
combinaison
avec
d'autres
gestionnaires
de
mise
en
page
exemple
de
changement
gestionnaire
de
mise
en
page
par
défaut
:
jpanel
paner
=
new
jpanel()
;
pane.setlayout(new
borderlayout());
taille
l'alignement
d'un
composer
pouvoir
être
spécifier
par
méthode
suivantes
:
setminimumsize,
setpreferredsize,
setmaximumsize,
setalignmentx,
setalignmenty.
11.4
gestion
événement
11.4.1
notion
d'événement
a
fois
l'utilisateur
agir
sur
clavier
souris,
événement
survient,
objet
événement
être
généré.
objet
événement
être
objet
contenir
information
sur
source
nature
de
l'événement
survenu.
swing
offrir
interface
(au
sentir
java)
appeler
"
écouteur
d'événements
"
(event
listeners)
permettre
de
capter
événement
de
façon
sélective
de
pouvoir
traiter.
event
source
event
object
event
listener
event
listener
event
listener
exemple
d'événement
type
de
listener
clic
d'un
bouton
graphique
enfoncement
de
touche
return
actionlistener
d'une
saisir
dans
champ
texte
fermeture
d'une
fenêtre
windowlistener
graphique
(frame)
clic
de
souris
passage
curseur
sur
composant
mouselistener
graphique
de
faciliter
travail
programmeur,
swing
associer
à
interface
listener
classe
adaptateur
(adapter).
adaptateur
existe,
c'est
avec
l'on
travaille.
exemple
d'interface
listener
classer
adapter
associer
actionlistener
none
windowlistener
windowadapter
mouselistener
mouseadapter
keylistener
keyadapter
11.4.2
réaliser
gestionnaire
d'événement
réaliser
gestionnaire
d'événement
(event
handler)
requérir
trois
élément
de
code
:
+
déclarer
classe
gestionnaire
d'événement
:
classe
devoir
implémenter
interface
listener
étendre
classe
adapter
exemple
:
import
java.awt.event.*
;
public
class
myclass
implements
actionlistener
{
.
.
.
}
+
définir
dans
classe
gestionnaire
d'événement
méthode
de
l'interface
listener
exemple
:
public
void
actionperformed(actionevent
e)
{
..
.
}
+
définir
instance
de
classe
gestionnaire
d'événement
l'enregistrer
sur
le(s)
composant(s)
concerné(s)
exemple
:
somecomponent.addactionlistener(instanceofmyclass)
;
type
actionlistener
permettre
de
définir
gestionnaires
d'événement
simples
communs.
lorsqu'un
événement
de
type
être
générer
(clic
d'un
bouton
graphique
enfoncement
de
touche
return
d'une
saisir
dans
champ
texte),
message
actionperformed
être
envoyer
à
écouteur
d'événements
être
enregistrer
sur
composant
concerné.
classe
gestionnaire
d'événement
être
implanter
sous
forme
d'une
classe
interner
(inner
class)
sein
d'une
classe
graphique.
exemple
:
//
ecriture
d'un
mouselistener
public
myclass
extends
jpanel
{
...
someobject.addmouselistener
(new
myadapter());
...
myadapter
extends
mouseadapter
{
public
void
mouseclicked(mouseevent
e)
{
...
}
}
}
typiquement,
classe
gestionnaire
d'événement
être
implanter
sous
forme
d'une
classe
interne
anonyme.
exemple
(solution
équivalente
à
de
l'exemple
précédent)
:
//
ecriture
d'un
mouselistener
public
myclass
extends
jpanel
{
...
someobject.addmouselistener(new
mouseadapter()
{
public
void
mouseclicked(mouseevent
e)
{
...
}
})
;
...
}
11.5
affichage
/
fermeture
d'une
fenêtrer
graphique
l'affichage
/
masquage
d'une
fenêtre
graphique
de
type
jframe
commander
par
méthode
setvisible.
l'utilisateur
fenêtre
graphique
de
type
jframe,
fenêtrer
n'est
en
fait,
par
défaut,
masquée.
quoiqu'invisible,
l'objet
graphique
exister
programme
pouvoir
à
nouveau
rendre
visible.
l'on
désirer
comportement
différent,
être
nécessaire
:
-
d'enregistrer
sur
objet
graphique
gestionnaire
d'événement
de
type
windowlistener
de
capter
message
windowclosing
-
de
spécifier
comportement
par
défaut
en
utiliser
méthode
setdefaultcloseoperation.
comportement
être
indiquer
en
argument
par
constante
(définie
dans
l'interface
windowconstants).
exemple
d'argument
:
dispose_on_close
11.6
architecture
composants
swing
objectif
:
application
adaptables.
l'architecture
composants
swing
être
baser
sur
adaptation
de
renommée
architecture
mvc
("
modèle-vue-contrôleur
"
;
voir
section
13.2).
dans
communauté
swing,
être
appeler
"
architecture
à
modèle
séparable
"
:
partie
modèle
d'un
composer
swing
(partie
représenter
donnée
de
l'application)
être
traiter
élément
séparé,
préconiser
conception
mvc
;
swing
fusionner
parties
vue
(qui
prendre
en
charge
représentation
visuelle
données)
contrôleur
(qui
traiter
entrée
utilisateur)
de
composant
en
seul
objet
interface
utilisateur
(user
interface
object).
être
en
général
considérer
bonne
pratique
de
centrer
l'architecture
d'une
application
de
donnée
qu'autour
de
interface
utilisateur.
pour
supporter
paradigme
[1],
swing
définir
interface
modeler
séparer
pour
composant.
séparation
fournir
programme
d'application
possibilité
de
connecter
composants
swing
dans
implémentation
modeler
propre.
table
suivante
montrer
interface
modeler
offrir
par
composants
swing
:
component
model
interface
model
typer
jbutton
buttonmodel
gui
jtogglebutton
buttonmodel
gui/data
jcheckbox
buttonmodel
gui/data
jradiobutton
buttonmodel
gui/data
jmenu
buttonmodel
gui
jmenuitem
buttonmodel
gui
jcheckboxmenuitem
buttonmodel
gui/data
jradiobuttonmenuitem
buttonmodel
gui/data
jcombobox
comboboxmodel
dater
jprogressbar
boundedrangemodel
gui/data
jscrollbar
boundedrangemodel
gui/data
slider
boundedrangemodel
gui/data
component
model
interface
model
typer
jtabbedpane
singleselectionmodel
gui
jlist
listmodel
dater
jlist
listselectionmodel
gui
jtable
tablemodel
dater
jtable
tablecolumnmodel
gui
jtree
treemodel
dater
jtree
treeselectionmodel
gui
jeditorpane
document
dater
jtextpane
document
dater
jtextarea
document
dater
jtextfield
document
dater
jpasswordfield
document
dater
interface
modeler
fournir
par
swing
relever
de
deux
grandes
catégorie
:
type
"
etat
de
l'interface
graphique
"
(gui),
définir
statut
visuel
commande
de
l'interface
graphique
;
type
"
données
d'application
"
(data),
représenter
donnée
quantifiables
avoir
sens
pour
l'application.
modèle
relever
de
type
partagés
(gui/data).
être
recommander
d'utiliser
catégorie
"
données
d'application
"
(data)
modèle
de
swing
renforcer
l'adaptabilité
modularité
application
sur
long
terme.
[1]
paradigme
être
vision
monde
reposer
sur
un
modèle.
11.7
applets
java
permettre
de
créer
deux
type
de
programme
:
-
applications,
s'exécutent
sous
contrôle
de
machine
virtuelle
java
-
appliquettes
(ou
applettes
;
en
anglais
:
applets)
destiner
à
être
exécuter
par
navigateur
web
réaliser
applette,
minimum
consister
à
:
-
créer
sous-classe
de
classe
japplet
(voir
section
11.2)
-
créer
méthode
init(),
être
lancer
par
navigateur
-
référencer
classe
dans
balise
<applet
code=
...>
d'un
fichier
html
syntaxe
:
import
javax.swing.japplet
;
public
appletclassname
extends
japplet
{
//
...
fields
...
public
void
init
)
{
;
...
}
}
syntaxe
:
<applet
code="appletclassname.class"
width=anint
height=anint
>
</applet>
12
annexe
2
-
threads
référence
:
programmation
concurrente,
processus,
threads
java.sun.com/docs/books/tutorial/essential/concurrency/procthread.html
threads
permettre
de
programmer
tâche
qui,
à
l'intérieur
d'un
même
programme,
s'exécuteront
concurremment.
être
processus
légers.
tâche
à
exécuter
par
thread
devoir
être
implémentée
dans
méthode
run().
exister
deux
façon
de
fournir
méthode
run()
:
-
définir
sous-classe
de
classe
thread
redéfinir
méthode
run()
-
définir
classe
implémente
l'interface
runnable
définir
méthode
run()
12.1
créer
thread
par
extension
de
classe
thread
exemple
:
//
example
of
defining
avoir
thread
avoir
extending
thread
public
class
simplethread
extends
thread
{
public
simplethread(string
threadname)
{
super
(threadname)
;
}
//
the
task
of
this
thread
is
to
print
10
times
its
name
//
at
avoir
random
rater
public
void
run()
{
for
(int
i
=
0;
i
<
10;
i++)
{
system.out.println(i
+
"
"
+
getname());
try
{
sleep((long)
(math.random()
*
1000)
);
}
catch
(interruptedexception
e)
{}
}
system.out.println("done!
!""
+
getname());
}
}
//
end
simplethread
//
example
of
running
two
threads
concurrently.
//
"jamaica"
and
"fiji"
will
be
printed
randomly
10
times.
public
static
void
main
(string[]
args)
{
new
simplethread("jamaica").start()
;
new
simplethread("fiji").start()
;
}
12.2
créer
thread
par
implémentation
de
l'interface
runnable
façon
de
faire
s'impose
classe
à
créer
devoir
sous-classer
classe
quelconque
(le
cas
typique
être
applet),
java
supporter
l'héritage
multiple.
exemple
:
//
example
of
defining
avoir
thread
avoir
implementing
runnable
public
simplethread
implements
runnable
{
string
threadname
;
public
simplethread(string
threadname)
{
this.threadname
=
threadname
;
}
//
the
task
of
this
thread
is
to
print
10
times
its
name
//
at
avoir
random
rater
public
void
run()
{
for
(int
i
=
0;
i
<
10;
i++)
{
system.out.println(i
+
"
"
+
threadname)
;
try
{
thread.sleep((long)
(math.random()
*
1000)
);
}
catch
(interruptedexception
e)
{}
}
system.out.println("done!
!"
+
threadname)
;
}
}
//
end
simplethread
//
example
of
running
two
threads
concurrently
//
("jamaica"
and
"fiji"
will
be
printed
randomly
10
times)
public
static
void
main
(string[]
args)
{
new
thread(new
simplethread("jamaica")).start()
;
new
thread(new
simplethread("fiji")).start()
;
}
12.3
synchronisation
communication
entre
threads
12.3.1
section
critiques
synchronisation
dans
programme,
segment
de
code
accéder
à
même
donner
depuis
threads
concurrents
être
appeler
section
critiques.
deux
threads
concurrents
invoquer
méthode
opérer
sur
même
donner
partagée
(méthodes
critiques),
être
nécessaire
java
pouvoir
synchroniser
méthode
de
garantir
accès
sûr
à
l'information.
a
fin,
de
méthode
devoir
être
déclarer
avec
modificateur
synchronized.
a
l'exécution,
l'accès
à
donnée
partagée
être
verrouiller
qu'elle
être
utiliser
par
méthode
critique.
exemple
:
get
pouvoir
être
supposer
deux
méthode
critiques
de
l'objet
partagé.
public
synchronized
int
get()
{
...
}
public
synchronized
void
put(int
value)
{
...
}
12.3.2
communication
entre
threads
deux
threads,
processus
indépendants
dérouler
de
façon
asynchrone,
pouvoir
communiquer
données,
être
nécessaire
qu'ils
savoir
synchroniser
d'un
sas
de
communication.
thread
émetteur
de
donnée
être
appeler
producteur
;
thread
destinataire
de
donnée
être
appeler
consommateur.
thread
producteur
de
donnée
devoir
être
capable
de
:
-
attendre
l'espace
de
stockage
sas
de
communication
être
libre
;
-
déposer
nouvelle
donnée
;
-
informer
threads
consommateur
de
mise
à
disposition
de
donnée.
de
façon
symétrique,
thread
consommateur
de
donnée
devoir
être
capable
de
:
-
attendre
donnée
être
mettre
à
disposition
dans
l'espace
de
stockage
sas
de
communication
;
-
lire
donnée
;
-
informer
threads
producteurs
de
disponibilité
sas
de
communication
accuser
réception.
c'est
sas
de
communication
qu'on
confier
charge
de
synchronisations.
mise
en
attente
réaliser
par
méthode
wait(),
notification
autres
threads
par
méthode
notify()
notifyall().
méthode
être
deux
définir
dans
classe
object().
exemple
de
classe
définir
sas
de
communication
d'un
seul
élément
de
type
entier
(attribut
contents).
noter
en
particulier
sécurisation
apporter
par
l'usage
d'un
while
d'un
if
de
prévenir
de
faux
réveil
éventuels.
public
cubbyhole
{
private
int
contents
;
private
boolean
available
=
false
;
public
synchronized
int
get()
{
//
called
by
consumer
while
(
available
==
false
)
{
try
{
wait()
;
//
wait
for
producer
to
pouvoir
valoir
}
catch
(interruptedexception
e)
()
{
}
}
available
=
false
;
notifyall();
return
contents
;
}
public
synchronized
void
put(int
x)
{
//
called
by
producer
while
(
available
==
true
)
{
try
{
wait()
;
//
wait
for
consumer
to
get
valoir
}
catch
(interruptedexception
e)
()
{
}
}
contents
=
x
;
available
=
true
;
notifyall();
}
13
annexe
3
-
conception
developpement
en
java
référence
:
architecture
modèle-vue-contrôleur
:
java.sun.com/blueprints/guidelines/designing_enterprise_applications_2e/app-arch/app-arch2.html
développement
de
test
unitaires
avec
cadre
d'applications
junit
:
junit.sourceforge.net/doc/cookbook/cookbook.htm
javabeans
:
java.sun.com/products/javabeans/
java.sun.com/docs/books/tutorial/javabeans/index.html
design
pattern
:
section
aller
langage
java
pour
aborder
aspect
de
conception
développement
de
programme
java.
13.1
conseil
généraux
pour
bonne
conception
classe
rechercher
couplage
faible.
couplage
décrire
l'interconnectivité
entre
classes.
couplage
être
faible
classe
être
indépendante
autres
communiquer
avec
via
interface
petite
définir
(l'interface
d'une
classe
être
partie
visible
publique
de
classe
:
définir
par
liste
membre
(attributs,
constructeurs,
méthodes)
priver
associer
à
commentaire
de
documentation).
rechercher
cohesion
forte.
cohésion
décrire
l'adéquation
entre
unité
de
code
entité
tâche
logique.
cohésion
être
forte
unité
de
code
(méthode,
classe,
module,
.....)
être
responsable
d'une
entité
tâcher
définie.
utiliser
maximum
l'encapsulation.
l'encapsulation
être
technique
de
base
pour
réduire
couplage.
contribuer
à
séparer
comment,
vue
l'implémentation,
définition
l'utilisation.
principe
de
base
:
rendre
attribut
priver
utiliser
méthode
d'accès.
decoupler
entrees,
traitement
sorties.
voir
en
particulier
section
13.2
adopter
conception
dirigee
par
responsabilités.
l'attribution
bonnes
responsabilité
bonnes
classe
être
l'un
problème
délicats
de
conception
orienter
objet.
programmation
diriger
par
responsabilité
être
processus
de
conception
de
classe
par
attribution
de
responsabilité
définir
à
classe.
approche
pouvoir
être
utiliser
pour
déterminer
classe
devoir
implémenter
fonctionnalité.
conception
diriger
par
responsabilité
contribuer
à
réduire
couplage.
eviter
duplication
de
code.
eviter
qu'un
même
segment
de
code
retrouver
d'une
fois
dans
application.
utiliser
l'heritage
à
bon
escient.
l'héritage
être
relation
"
est_un
",
relation
"a_un
".
dans
hiérarchie
d'héritage,
objet
devoir
avoir
relation
"
est_un
"
avec
classe
de
base,
l'héritage
de
attributs,
propriété
méthode
de
classe
de
base
garder
sens
(même
sous-classe
spécialiser
complète).
objet
relever
d'une
relation
"
est_un
"
devoir
traduire
par
classe
interface
sans
relation
d'héritage
entre
elles.
limiter
taille
complexite.
mettre
de
chose
dans
méthode
:
méthode
être
longue
faire
d'une
tâcher
logique.
mettre
dans
seule
classe
:
classe
être
complexe
représenter
d'une
entité
logique.
chercher
à
faciliter
changement
localises.
réaliser
changement
dans
classe
devoir
avoir
qu'un
minimum
d'impact
sur
autres
classes.
localisation
changement
être
l'un
but
recherchés
d'une
bonne
conception
de
classe.
être
produit
d'un
couplage
faible
d'une
cohésion
forte.
13.2
architecture
d'une
application
interactive
:
modèle
mvc
l'architecture
modèle-vue-contrôleur
(model-view-controller,
mvc)
être
modèle
d'architecture
logicielle
recommander
-
utiliser
-
pour
conception
d'applications
interactives.
modèle
viser
à
minimiser
degré
de
couplage
entre
objet
de
l'application
en
découpler
entrées,
traitement
sorties.
point
essentiel
consister
à
séparer
objet
relever
de
l'interface
utilisateur
objet
métier,
de
pouvoir
faire
évoluer
réutiliser.
mvc
organiser
application
interactive
en
trois
grandes
composante
:
modèle,
vue
contrôleur,
découpler
responsabilité
respectives
:
+
modele
encapsuler
fonctionnalité
données
cur
de
l'application.
être
indépendant
de
représentation
de
sortie
spécifiques
d'un
comportement
d'entrée.
avoir
à
charge
représentation
interne
donnée
de
l'application
logique
de
gestion
de
données.
notifier
à
composante
vue
changement
de
donnée
permettre
de
l'interroger
sur
état.
fournir
contrôleur
possibilité
d'accéder
à
fonctionnalité
applicatives
encapsuler
dans
modèle.
+
vue
afficher
information
à
l'utilisateur.
récupérer
modèle
donnée
à
présenter
à
l'utilisateur,
spécifier
présentation
externe
mettre
à
jour
l'information
affichée.
relayer
contrôleur
entrée
utilisateur
l'autorise
à
sélectionner
vues.
séparation
modèle
d'une
part
de
vue
contrôleur
d'autre
part
permettre
vue
multiples
d'un
modèle.
avoir
vue
modèle,
vue
avoir
contrôleur
associé.
+
controleur
gérer
entrée
utilisateur.
recevoir
entrées,
sous
forme
d'événements
encoder
mouvement
de
souris,
l'activation
d'un
bouton,
entrée
clavier
(ou
bien,
s'il
s'agit
d'une
application
web,
requête
http
get
post).
événement
être
traduire
en
requête
de
service
pour
modèle
vue.
application
avoir
contrôleur
pour
ensemble
de
fonctionnalité
apparentées.
application
pouvoir
avoir
contrôleur
séparer
par
type
de
client
interaction
utilisateurs
varier
selon
type
de
client.
l'utilisateur
interagir
avec
système
travers
contrôleurs.
l'ensemble
voir
+
contrôleur
composer
l'interface
utilisateur.
modèle
interrogation
d'état
notification
de
changement
changement
d'état
voir
requêter
utilisateur
sélection
de
vue
contrôleur
invocation
de
méthode
evènements
en
pratique,
schéma
de
principe
laisser
place
à
grande
variété
d'implémentations
possibles.
un
difficulté
pour
implémentation
idéale
en
java
résider
dans
fait
composants
graphiques
swing
fusionner
partie
voir
contrôleur
(cf
section
11.6).
pour
petits
programme
particulièrement,
vue
contrôleur
être
combinés,
dans
cas
modèle
devoir
être
séparé.
exemple
d'implémentation
d'une
architecture
mvc
:
import
java.util.observable
;
import
java.util.observer
;
import
javax.swing.japplet
;
import
javax.swing.jpanel
;
import
java.awt.event.actionlistener
;
import
java.awt.event.actionevent
;
public
class
controller
extends
japplet
implements
actionlistener
{
private
view
view
;
private
model
model
;
public
void
init()
{
model
=
new
mode1()
;
view
=
new
view(model,
this);
model.addobserver(view)
;
this.setcontentpane
(view)
;
}
public
void
actionperformed(actionevent
e)
{
//
process
the
event
}
}
public
class
view
extends
jpanel
implements
observer
{
private
model
model
;
//
declare
here
the
jpanel
components.
public
view(model
m,
actionlistener
listener)
{
model
=
m
;
makecontentpane(listener)
;
}
public
void
update(observable
o,
object
arg)
{
//
automatically
called
when
observer
is
notified.
//
update
the
view.
}
public
void
makecontentpane(actionlistener
listener)
{
//
create
and
initialize
the
jpanel
components
and,
//
when
need
be,
attach
them
the
event
listener.
//
define
the
layout.
}
}
public
class
model
extends
observable
{
//
wherever
the
valoir
of
an
attribute
interesting
the
//
view
is
changed,
insert
these
two
statements
//
setchanged()
;
//
notifyobservers()
;
or
notifyobservers(arg);
}
chercher
à
découpler
traitement
entrées-sorties
être
classique
en
programmation.
dans
esprit,
pouvoir
noter
en
particulier
modèle
mvc
avoir
certaine
similitude
avec
classique
architecture
trois-tiers
(three-tiers)
système
distribués.
architecture
trois-
tiers
être
architecture
logicielle
client-serveur
dans
l'interface
utilisateur,
logique
de
traitement
donnée
être
trois
module
indépendants
:
l'interface
utilisateur
être
stocker
dans
client,
de
logique
de
l'application
être
stocker
dans
serveur
d'application,
donnée
être
stocker
dans
serveur
de
base
de
données.
exemple.
pour
application
web
professionnelles
reposer
sur
solution
java
ee
(voir
chapitrer
16),
modèle
être
assurer
par
ejb
et/ou
javabeans,
contrôleur
être
assurer
par
servlets,
vue
par
jsp
(glossaire
en
chapitre
17).
13.3
test
unitaires
13.3.1
définition
test
être
activité
consister
à
déterminer
segment
de
code
(méthode,
classe
programme)
produire
résultat
attendu.
définir
trois
niveau
de
tests,
être
mettre
en
uvre
:
+
test
unitaire
(unit
testing)
:
s'agit
de
tester
composante
individuelle
(méthode,
classe)
de
l'application.
+
test
d'intégration
(integration
testing)
:
s'agit
de
tester
groupe
de
classe
en
interrelation
l'application
dans
ensemble.
test
appliqués
suivre
plan
de
test
(i.e.
approche
systématique
méthodique).
+
test
système
(system
testing)
:
s'agit
de
tester
l'application
intégrer
dans
environnement
d'utilisation
complet.
test
entrer
dans
catégorie
test
boîte
noires,
et,
en
tels,
devoir
nécessiter
de
connaissance
de
conception
interne
code
de
logique.
considération
suivantes
limiter
test
unitaires.
cas
de
test
être
ensemble
de
condition
variables
à
partir
testeur
déterminer
exigence
requise
être
satisfaite.
cas
de
test
être
caractériser
par
entrée
connaître
(pré-condition)
sortie
attendre
(post-
condition).
de
nombreux
cas
de
test
pouvoir
être
nécessaires
pour
vérifier
exigence
donnée.
distinguer
deux
type
de
cas
de
test
:
-
cas
de
test
positifs,
consister
à
tester
cas
censés
faire
réussir
fonctionnalité.
test
devoir
convaincre
l'élément
de
code
tester
fonctionner
espéré.
-
cas
de
test
négatifs,
consister
à
tester
cas
censés
mettre
en
échec
fonctionnalité.
être
situation
de
valeur
hors
limites,
d'erreurs,
....
exemple
:
entrer
valeur
hors
plage,
lire
ensemble
vide,
...
.
dans
de
cas,
devoir
attendre
à
programme
traiter
l'erreur
d'une
façon
contrôler
appropriée.
simple
correction
erreur
détecter
par
test
devoir
améliorer
qualité
programme.
malheureusement,
l'expérience
montrer
changement
dans
programme
pouvoir
introduire,
de
façon
inattendue,
d'autres
erreurs.
en
particulier
erreur
de
régression
(regression
bugs)
:
erreur
de
régression
survenir
fonctionnalité
fonctionner
fonctionner
suite
à
modification
programme.
méthode
courante
de
test
de
non-régression
(non-regression
testing)
consister
à
réexécuter
test
réaliser
voir
défaut
apparaître
réapparaissent.
test
être
appliquer
seule
fois
à
modification
logiciel,
être
souhaitable
de
disposer
d'une
batterie
de
test
programmer
de
permettre
automatisation
test.
s'agit
de
programmer
cas
de
test
pour
méthode
triviale,
en
veiller
à
cas
de
test
séparer
autres.
13.3.2
junit
junit,
développer
par
communauté
open
source,
offrir
cadre
d'applications
(framework)
pour
programmation
de
test
de
régression.
être
utiliser
pour
implémenter
test
unitaires
en
java.
classe
testcase
permettre
de
définir
cas
de
test
;
classe
assert
fournir
ensemble
de
méthode
faciliter
gestion
erreur
détecter
;
classe
testsuite
permettre
d'exécuter
suite
de
test
;
classe
testrunner
être
outil
d'exploitation
permettre
de
définir
suite
de
test
à
exécuter
d'afficher
résultats.
exemple
de
cas
de
test
:
/**
*
a
test
caser
for
the
myclass
*/
import
junit.framework.*
;
public
class
testmyclass
extends
testcase
{
/*
the
test
need
to
run
against
the
background
of
à
known
*
set
of
objects.
this
set
of
objects
is
called
à
test
*
fixture.
*
define
here
an
instance
variable
for
each
part
of
the
*
fixture.
*/
private
myclass
myobject;
public
testmyclass(string
name)
{
super
(name)
;
}
/**
*
set
up
the
test
fixture.
*
setup()
is
called
before
every
test
caser
method.
*
initializes
the
instance
variables.
*/
protected
void
setup()
{
myobject
=
new
myclass(
.
.
.
)
;
}
/**
*
tears
down
the
test
fixture.
*
teardown()
is
called
after
every
test
caser
method.
*
releases
any
permanent
resources
allocated
in
setup
*
(example:
clore
files,
...)
*/
protected
void
teardown()
{
//
...
}
//
once
the
fixture
is
in
place,
avoir
many
test
case
avoir
//
necessary
can
be
written.
/**
*
test
the
method
methodx()
*/
public
void
testmethodx()
{
argumenttype
argument
=
.
.
.
;
responsetype
expectedresponse
=
.
.
.
;
string
errormessage
=
"
.
.
.
"
;
asserttrue(errormessage,
expectedresponse.equals(methodx(argument))
;
}
}
//
end
testmyclass
junit
déterminer
succès
l'échec
d'un
test
via
instruction
d'assertion.
assertion
être
procédure
de
comparaison
entre
valeur
espérer
valeur
effective
générer
échec
en
cas
de
différence.
procédure
d'assertion
disponibles
être
définir
dans
classe
junit.framework.assert.
exemple
d'instructions
d'assertion
:
asserttrue(
errormessage,
booleancondition
)
;
assertfalse(
errormessage,
booleancondition
)
;
assertequals(
errormessage,
expectedvalue,
actualvalue
)
;
assertequals(
errormessage,
doubleexpected,
doubleactual,
doubledelta
)
;
pour
exécuter
test,
créer
instance
de
classe
avec
en
paramètre
nom
de
méthode
de
test.
exemple
new
testmyclass("testmethodx")
;
junit
être
intégrer
dans
outil
de
développement.
de
outil
offrir
fonctionnalité
permettre
de
créer
tests.
13.4
java
beans
java
bean
("
grain
java
")
être
définir
par
sun
"
composant
réutilisable
java
destiner
à
être
manipuler
par
outil
de
développement
graphique
visuel
".
java
beans
être
composants
java
(i.e.
classes)
respecter
critère
de
pouvoir
être
développés,
assemblé
réutiliser
pour
créer
application
sophistiquées.
par
exemple,
technologie
java
beans
être
l'architecture
composant
dans
plate-forme
java
se.
obligation
devoir
respecter
java
bean
être
nombreuses
l'enjeu
être
d'importance
:
disposer
de
composant
"
write
one,
run
anywhere
"
(wora)
réutilisables.
java
beans
être
classe
publiques
concrètes
avoir
pour
caractéristiques
commune
de
:
+
supporter
"
propriété
"
:
propriété
être
attribut
discrets
nommer
d'un
java
bean
pouvoir
affecter
apparence
comportement.
propriété
être
pour
java
beans
l'équivalent
champ
pour
objets.
par
exemple,
bouton
graphique
pouvoir
avoir
propriété
nommer
"
label
"
représenter
texte
afficher
dans
bouton.
méthode
d'accès
propriété
devoir
respecter
convention
de
nommage
particulières,
par
exemple
:
-
pour
propriété
simples
(il
exister
d'autres
:
liées,
contraintes,
indexées,
...)
:
propertytype
getpropertyname()
;
//
simple
getter
void
setpropertyname(propertytype)
;
//
simple
setter
-
pour
propriété
booléennes,
utiliser
is
lieu
de
get
+
communiquer
entre
par
événement
:
en
pratique,
utiliser
technique
swing
"
listeners
"
(voir
section
11.4)
;
+
supporter
l'introspection
:
à
l'exécution
dans
l'environnement
de
développement,
devoir
être
capable
de
déterminer
d'analyser
propriétés,
événement
méthode
supporter
java
bean.
a
noter
propriété
d'introspection
être
présente
dans
objet
java
puisqu'un
objet
pouvoir
être
analyser
grâce
classe
class,
method,
field,
+
supporter
personnalisation
("
customization
")
:
outil
de
développement
devoir
permettre
de
modifier
l'apparence
comportement
d'un
java
bean
en
phase
de
conception
;
+
supporter
persistance
:
persistance
d'un
objet
être
capacité
de
sauvegarder
sur
support
de
stockage
de
restaurer
à
l'identique
programme
pouvoir
terminer
sans
objet
être
perdu.
exemple
de
persistance
:
qu'un
objet
pouvoir
prétendre
à
être
document
excel
à
l'intérieur
d'un
document
word.
mécanisme
rendre
possible
persistance
être
appeler
"
sérialisation
"
(serialization).
a
fin,
java
bean
devoir
implémenter
l'interface
serializable
externalizable.
exemple
de
java
bean
:
package
sunw.demo.simple;
import
java.awt.*;
import
java.io.serializable;
/**
*
simplebean
wi11
be
displayed
with
avoir
green
*
centered
rectangle,
but
its
color
may
be
changed
1ater.
*/
public
class
simplebean
extends
canvas
implements
serializable
{
private
color
color
=
color.green;
//
property
getter
method.
public
color
getcolor(){
return
color;
}
//
property
setter
method.
//
set
new
simplebean
color
and
repaints.
public
void
setcolor(color
newcolor)
{
color
=
newcolor;
repaint()
;
}
public
void
paint(graphics
g)
{
g.setcolor(color);
g.fillrect(20,
5,
20,
30);
}
//
constructor
set
inherited
properties
public
simplebean()
{
setsize(60,40);
setbackground(color.red)
;
}
}
//
end
simplebean
être
reconnaître
par
outil
de
développement,
java
bean
devoir
être
conditionnné
dans
fichier
d'archive
format
jar.
être
obligatoire,
être
souhaitable
java
beans
être
paquetage
(évite
conflit
en
cas
d'homonymie
beans).
13.5
design
pattern
section
n'est
qu'une
premier
introduction
modèle
de
conception
(design
patterns)
[1].
développement
orienter
objet
d'applications
professionnelles
conduire
à
rencontrer
problème
de
conception
type
être
familiers
à
communauté
développeurs
confirmer
solution
éprouver
existent.
s'agit
de
solution
théoriques
(algorithmes)
de
solution
orienter
objet
empiriques
solidité
l'efficacité
avoir
faire
preuve
en
pratique.
solution
être
appeler
modèle
de
conception
(design
patterns).
développeur
expérimenté
devoir
de
connaître
de
disposer
d'un
"
panier
"
de
modèle
de
conception
qu'il
appliquer
possible.
modèle
de
conception
être
stratégie
de
résolution
de
grands
type
de
problème
de
conception
orienter
objet.
décrire
forme
génériques
d'organisation
de
classes.
être
indépendants
langage
de
programmation
objet
mettre
en
oeuvre.
a
titre
illustratif,
l'architecture
mvc,
décrire
à
section
13.2,
être
exemple
de
modèle
de
conception
d'architecture
logicielle
(architectural
design
pattern).
connaître
modèle
de
conception
de
base
être
23
modèle
fondamentaux
décrire
par
quatre
auteur
être
appeler
"
the
gang
of
four
"
("
bande
quatre
")
gof
[2].
distinguer
3
grandes
famille
de
modèle
de
conception
:
[1]
l'expression
design
pattern
être
traduire
par
patron
de
conception.
[2]
-
modèle
de
construction
avoir
pour
but
d'organiser
création
d'objets
de
façon
à
gagner
en
abstraction.
exemple
présenter
ci-après
:
modèle
singleton.
-
modèle
de
structuration
faciliter
l'organisation
de
hiérarchie
classe
de
relations.
exemple
présenter
ci-après
:
modèle
decorator.
-
modèle
de
comportement
proposer
solution
pour
organiser
interaction
pour
répartir
traitement
entre
objets.
tenter
de
répartir
responsabilité
entre
classe.
exemple
:
modèle
chain
of
responsibility
permettre
de
créer
chaîne
d'objets
que,
l'un
d'eux
pouvoir
répondre
à
requête,
pouvoir
transmettre
à
successeur
jusqu'à
l'un
d'entre
réponde.
13.5.1
exemple
:
modèle
singleton
modèle
de
conception
singleton
permettre
d'assurer
qu'une
classe
posséder
qu'une
instance
d'offrir
méthode
unique
retourner
instance.
exemple
d'implémentation
(cas
information
nécessaires
à
création
singleton
être
disponibles
moment
chargement
de
classe
en
mémoire)
public
final
class
mysingleton
{
//
creating
at
the
loading
private
static
mysingleton
singleinstance
=
new
mysingleton()
;
//
private
constructor.
can't
be
used
outside
this
private
mysingleton()
{
...
}
/**
get
avoir
singleton
of
this
*/
public
static
mysingleton
getinstance()
{
return
singleinstance
;
}
}
//
creation
of
avoir
singleton
mysingleton
singleton
=
mysingleton.getinstance()
;
13.5.2
exemple
:
modèle
decorator
modèle
de
conception
decorator
permettre
d'ajouter
fonctionnalité
à
objet.
réaliser
en
créer
nouvelle
classe
decorator
envelopper
classe
originale.
modèle
de
conception
decorator
être
alternative
à
l'approche
par
création
d'une
sous-
classe
de
classe
originale.
s'impose
à
approche
par
extension
de
classe
originale
dans
cas
suivants
:
classe
originale
pouvoir
être
étendre
par
héritage
;
nombre
de
sous-classe
permettre
de
définir
combinaison
possibles
de
fonctionnalité
être
important
;
l'ajout
fonctionnalité
pouvoir
être
statique
(i.e.
réaliser
à
compilation)
devoir
être
dynamique
(.e.
réaliser
à
l'exécution).
exemple
[wikipedia].
considérer
fenêtre
d'affichage
instance
d'une
classe
window
supposer
classe
n'offre
possibilité
d'ajouter
barre
de
défilement.
créer
décorateur
pouvoir
ajouter
fonctionnalité
à
objet
window
existants.
//
an
interface
common
to
the
decorator
and
the
decorated
public
interface
window
{
public
void
draw();
}
//
the
original
class,
the
instance
of
which
can
be
decorated
public
class
simplewindow
implements
window
public
void
draw()
{
...
}
}
//
the
abstract
decorator
public
abstract
class
windowdecorator
implements
window
{
protected
window
decoratedwindow;
public
windowdecorator(
window
decoratedwindow
)
{
this.decoratedwindow
=
decoratedwindow
;
}
}
//
a
first
concrete
decorator
public
class
verticalscrollbardecorator
extends
windowdecorator
{
public
verticalscrollbardecorator(
window
decoratedwindow
)
{
super
(decoratedwindow)
;
}
public
void
draw()
{
drawverticalscrollbar();
decoratedwindow.draw()
;
}
public
void
drawverticalscrollbar()
{
...
}
}
//
a
second
concrete
decorator
public
class
horizontalscrollbardecorator
extends
windowdecorator
{
public
horizontalscrollbardecorator(
window
decoratedwindow
)
{
super
(decoratedwindow)
;
}
public
void
draw()
{
drawhorizontalscrollbar()
;
decoratedwindow.draw()
;
}
public
void
drawhorizontalscrollbar()
{
...
}
}
//
example:
creation
of
avoir
fully
decorated
window
instance.
window
decoratedwindow
=
new
horizontalscrollbardecorator(
new
verticalscrollbardecorator(
new
simplewindow()
));
14
annexe
4
--
machine
virtuelle
java
(jvm)
objectifs
premier
de
chapitre
être
:
-
comprendre
s'opère
chargement
dynamique
classe
en
mémoire
de
l'exécution
d'un
programmer
java
;
-
comprendre
traitement
champ
bloc
static
chargement
de
classe.
machine
virtuelle
java
(jvm)
être
interpréteur
de
code
java
compiler
(bytecode)
permettre
d'exécuter
programme
java
sur
machine
cible.
l'espace
mémoire
de
jvm
comporter
zones,
:
-
zone
méthode
:
contenir
code
méthode
constructeur
information
sur
structure
de
classe
(notamment
table
symboles)
;
-
pile
:
espace
propre
à
thread,
mémoriser
contexte
d'exécution
(variables
locales
notamment)
méthode
en
cours
d'exécution
;
-
tas
:
contenir
objet
créer
par
new
(instances
de
classe
tableaux)
(cf
chapitrer
4).
c'est
demande
d'exécution
d'un
programmer
java
lancer
machine
virtuelle
java.
jvm
réaliser
grandes
étape
suivantes
:
-
chargement
de
classe
principale
spécifier
(main
class)
classe
dépendre
(au
premier
rang
sur-classes)
:
o
création
champ
static,
création
de
table
méthodes,
...
o
traitement
champ
(initialisation)
bloc
(exécution)
static
-
exécution
de
méthode
main
de
classe
principale.
durant
l'exécution
d'un
coder
java,
classe
(leur
bytecode)
être
charger
dans
jvm
fur
à
mesure
besoins.
dans
hiérarchie
d'héritage,
chargement
classe
être
opérer
par
ordre
hiérarchique
descendant
(i.e
de
super-classe
raciner
vers
classe
courante).
exemple
:
public
class
classer
{
static
{
system.out.println("start
loading
classa");
}
public
static
final
int
c
;
private
static
int
n
=
100
;
static
{
c
=
29979
;
}
static
{
system.out.println("c
=
"
+
c);
system.out.println("n
=
"
+
n);
}
public
classa()
{
system.out.println("start
classa()");
n
=
n
+
1;
system.out.println("end
classa()")
;
}
public
int
getn
()
{
return
n
;
}
static
{
system.out.println("end
loading
classa");
}
}
//
end
classer
public
class
classb
extends
classer
{
static
{
system.out.println("start
loading
classb");
}
private
int
x
=
5
;
public
classb()
{
system.out.println("start
classb()");
x
=
x
+
getn()
;
system.out.println(x)
;
system.out.println("end
classb()");
}
static
{
system.out.println("end
loading
classb");
}
}
//
end
classb
public
class()
{
static
{
system.out.println("start
loading
class0");
}
private
static
int
=
inity()
;
private
static
int
inity()
{
system.out.println("init
y");
return
256
;
}
public
static
void
main(string[]
args)
{
system.out.println("start
main
class0");
classb
b
=
new
classb();
system.out.println("end
main
class0");
}
static
{
system.out.println("end
loading
class0");
}
}
//
end
class0
après
compilation
de
trois
classes,
l'exécution
de
commande
:
java
class0
afficher
(commentaires
ajouté
en
marge)
:
start
loading
class0
init
end
loading
class0
start
main
class0
start
loading
classer
//
sur-classes
de
classb
c
=
29979
n
=
100
end
loading
classer
start
loading
classb
//
classb.
end
loading
classb
start
classa()
//
super()
d'abord.
end
classa()
start
classb()
106
//
100
+
1
classa()
+
5
classb()
end
classb()
end
main
class0
15
annexe
5
-
communication
entre
java
c
(jni)
référence
:
"the
java
native
interface:
programmer'
s
guide
and
specification"
java.sun.com/docs/books/jni/
tutoriel
:
java.sun.com/docs/books/jni/html/jnitoc.html
"java
native
interface
specification
v1.5"
java.sun.com/j2se/1.5.0/docs/guide/jni/spec/jnitoc.html
"javah
-
c
header
and
stub
filer
generator"
java.sun.com/javase/6/docs/technotes/tools/windows/javah.html
poser
problème
d'appeler
sous-programme
c
depuis
méthode
java
dans
environnement
unix.
solution
mettre
en
uvre
l'interface
de
programmation
jni
(java
native
interface)
offrir
par
plate-forme
java.
jni
être
ensemble
de
fonctionnalité
permettre
à
programme
java
fonctionner
sur
machine
virtuelle
java
(jvm)
d'appeler
d'être
appeler
par
programme
écrire
dans
autre
langage
(typiquement
en
c,
c++
assembleur).
en
permettre
l'interfaçage
avec
application
bibliothèque
natives
[1],
mise
en
uvre
de
jni
accroître
l'interopérabilité
application
java,
détriment
de
portabilité.
bonne
architecture
de
l'application
devoir
minimiser
nombre
de
classe
faire
référence
à
méthode
native.
par
suite,
supposer
fichier
java
appeler
sous-programme
c
nommer
myclass.java,
fichier
c
implémentant
sous-programme
nommer
myroutines.c
développement
de
l'application
complète
comporter
6
étape
:
1)
ecrire
programme
java
compiler
:
javac
myclass.java
2)
produire
fichier
d'en-tête
myclass.h
pour
programme
c
:
javah
myclass
3)
ecrire
sous-programme
c
compiler
:
gcc
-o
myroutines
-c
myroutines.c
-pedantic
-w
-wal1l
-idir
dir
être
répertoire
d'installation
par
jdk
fichier
d'include
jni.
par
exemple
(ces
fichier
être
répartir
dans
deux
répertoires)
:
gcc
-o
myroutines
-c
myroutines.c
-pedantic
-w
-wall
-i/usr/lib/jdk1.5.0v11/include
-i/usr/lib/jdk1.5.0v11/include/linux
[1]
application
bibliothèque
de
sous-programme
être
dire
en
code
natif
être
dépendante
d'un
environnement
hôte
(système
d'exploitation
jeu
d'instructions
processeur)
particulier.
par
exemple,
programme
c
compiler
sur
système
d'exploitation
donner
être
en
code
natif
fonctionner
sur
autre
système
d'exploitation.
4)
produire
bibliothèque
partagée
(lib*.so)
être
chargeable
par
programme
java
:
gcc
-wall
-shared
-o
libmyroutines.so
myroutines.o
5)
avant
premier
exécution,
spécifier
à
machine
virtuelle
java
chemin
d'accès
à
bibliothèque
:
setenv
ld_library_path
path
path
désigner
chemin
d'accès.
en
supposer
celui-ci
répertoire
courant,
commande
être
:
setenv
ld_library_path
.
6)
exécuter
programme
java
:
java
myclass
façon
d'écrire
programme
java
d'implémenter
sous-programme
c
associé
être
illustrer
ci-après.
15.1
appel
d'une
procédure
c
considèrera
de
bout
en
bout
exemple.
15.1.1
déclaration
appel
java
exemple
de
classe
java
public
class
myclass
{
//
declaration
of
an
extern
procedure
native
public
static
void
procedure1();
//
declaration
of
an
extern
instance
procedure
native
public
void
procedure2()
;
//
test
procedure
public
static
void
main(string[]
argv)
{
myclass.procedure1()
;
myclass
o
=
new
myclasse();
o.procedure2()
;
}
//
load
the
library
libmyroutines
static
{
system.loadlibrary("myroutines")
;
}
}
commentaire
:
-
modificateur
native
indique
qu'il
s'agit
d'une
procédure
externe
écrire
en
java.
nom
de
procédure
être
arbitraire.
-
méthode
loadlibrary
aller
charger
bibliothèque
libmyroutines.so
;
mot
clé
static
encapsuler
bloc
d'instructions
dans
l'appel
être
réaliser
permettre
d'exécuter
bloc
dès
chargement
de
classe
myclass
sans
avoir
besoin
de
passer
par
l'appel
d'une
méthode
intermédiaire.
15.12
prototype
c
fichier
myclass.h
produire
par
javah
(cf
étape
2
précédente)
spécifier
prototype
devoir
respecter
sous-programme
c
à
écrire.
contenu
(expurgé)
fichier
myclass.h
produire
par
javah
/*
do
not
edit
this
filer
-
it
is
machiner
generated
*/
/*
header
for
class
myclass
*/
jniexport
void
jnicall
java_myclass_procedure1
(jnienv
*,
jclass);
jniexport
void
jnicall
java_myclass_procedure2
(jnienv
*,
jobject);
commentaire
:
-
jniexport
jnicall
être
deux
macros
prédéfinies
par
jni
faire
communiquer
java
c
-
void
spécifier
qu'il
s'agit
d'une
procédure
-
java_myclass_procedure1
être
nom
imposé
devoir
porter
procédure
c
correspondant
à
méthode
de
nom
procedure1
déclarer
dans
programme
java
;
pour
procedure2
-
deux
paramètre
être
introduire
en
tête
de
liste
paramètre
:
o
premier,
de
type
jnienv
*,
être
pointeur
vers
l'environnement
jnienv
être
pointeur
vers
structure
contenir
fonction
d'interface
avec
machine
virtuelle
java
(jvm)
;
o
second,
de
type
jclass
s'il
s'agit
d'une
méthode
de
classe
jobject
s'il
s'agit
d'une
méthode
d'instance,
être
pointeur
vers
descripteur
de
classe
de
l'objet
(une
sorte
de
this)
d'appel
15.1.3
implémentation
c
exemple
de
fichier
myroutines.c
#include
<stdio.h>
#include
"myclass.h"
jniexport
void
jnicall
java_myclass_procedure1
(jinienv
*
penv,
jclass
cla)
{
printf("routine
procedure1\n");
}
jniexport
void
jnicall
java_myclass_procedure2
(jinienv
*
penv,
jobject
obj)
{
printf("routine
procedure2\n");
}
15.2
echange
de
donnée
entre
java
c
l'échange
de
donnée
entre
l'application
java
sous-programme
c
(par
paramètre
résultat
de
fonction)
supposer
compatibilité
type
correspondants.
n'y
avoir
de
correspondance
systématique
naturelle
entre
type
langage
java
type
langage
c
(un
caractère,
par
exemple,
être
coder
sur
16
bit
en
java
sur
8
bit
en
c).
jni
définir
ensemble
de
type
en
c
(de
nom
j*)
correspondre
type
de
java.
jni
traiter
type
primitifs
type
objet
différemment.
correspondance
type
primitifs
être
directe
(voir
tableau
ci-après),
reposer
sur
représentation
machiner
donnée
identique,
n'est
cas
pour
type
objets.
transmission
d'une
chaîne
de
caractères,
d'un
tableau,
avoir
d'une
instance
quelconque
de
classe,
n'est
directe
nécessiter
conversion
de
type.
paramètre
java
de
type
objet
être
transmettre
sous-
programme
c
sous
forme
d'un
pointeur
sur
structure
de
donnée
interne
à
machine
virtuelle
java.
l'organisation
interner
de
structure
être
masquer
programmeur
celui-ci
pouvoir
accéder
composante
sous-jacentes
via
fonction
utilitaires
offrir
par
jni
dans
l'environnement
jnienv.
typer
primitif
java
typer
primitif
côté
c
description
boolean
jboolean
unsigned
8
bit
byte
jbyte
signed
8
bit
char
jchar
unsigned
16
bit
short
jshort
signed
16
bit
int
jint
signed
32
bit
long
jlong
signed
64
bit
float
jfloat
32
bit
double
jdouble
64
bit
par
suite,
considèrera
de
bout
en
bout
exemple.
15.2.1
déclaration
appel
java
exemple
de
classe
java
public
class
myclass
{
//
declaration
of
an
extern
instance
function
native
public
string
getmessage(int
id,
string
prompt);
//
test
procedure
public
static
void
main(string[]
argv)
{
myclass
o
=
new
myclasse();
system.out.println(o.getmessage(10,
"name:
"));
}
//
load
the
library
libmyroutines
static
{
system.loadlibrary("libmyroutines")
;
}
}
15.22
prototype
c
contenu
(expurgé)
fichier
myclass.h
produire
par
javah
/*
do
not
edit
this
filer
-
it
is
machiner
generated
*/
/*
header
for
class
myclass
*/
jniexport
jstring
jnicall
java_myclass_getmessage
(inienv
*,
jobject,
jint,
jstring);
15.2.3
implémentation
c
exemple
de
fichier
myroutines.c
#include
<stdio.h>
#include
"myclass.h"
jniexport
jstring
jnicall
java_myclass_getmessage
(jinienv
*
penv,
jobject
obj,
jint
jid,
jstring
jprompt);
{
const
char
*
str;
char
buf[128];
/*
get
the
c
string
from
the
java
string
*/
str
=
(*penv)->getstringutfchars(penv,
jprompt,
null);
printf("%d
-
%s",
jid,
str);
/*
don't
forget
this
line!!!
!!!*/
(*penv)->releasestringutfchars(penv,
jprompt,
str);
/*
assumer
the
user
doesn't
type
more
than
127
char
*/
scanf("%s",
buf);
return
(*penv)->newstringutf(penv,
buf);
}
commentaire
:
-
représentation
physiques
chaîne
de
type
jstring
de
type
char*
être
identiques.
conversion
devoir
être
réalisée.
c'est
rôle
fonction
getstringutfchars
newstringutf.
à
noter
que,
dans
cas,
conversion
caractère
codables
en
ascii
7
bit
(lettres
accentuées,
...)
poser
problème.
-
fonction
getstringutfchars
réaliser
allocation
mémoire
dynamique,
désallocation
devoir
être
réaliser
avant
fin
sous-
programme
:
c'est
rôle
de
fonction
releasestringutfchars
16
annexe
6
-
plates-formes
java
référence
:
java
platform,
standard
edition
6,
api
specification
:
java.sun.com/javase/6/docs/api/
new
features
and
enhancements
j2se
5.0
:
java.sun.com/j2se/1.5.0/docs/relnotes/features.html
java
platform,
standard
edition
:
java.sun.com/javase/
java
platform,
enterprise
edition
:
java.sun.com/javaee/
java
platform,
micro
edition
:
java.sun.com/javame/
jdk
tools
and
utilities
:
java.sun.com/javase/6/docs/technotes/tools/
sun
microsystems
fournir
trois
plates-formes
java
permettre
développement
l'exécution
de
programme
java
:
java
(le
standard
de
base),
java
ee
java
me.
a
noter
nom
être
employé
pour
version
sortir
depuis
2006
:
antérieurement,
plates-
forme
être
nommer
j2se,
j2ee
j2me.
java
platform,
standard
edition
(java
se).
plate-forme
être
framework
java
de
base
permettre
de
développer
ou/et
exécuter
programme
java.
dernière
version
nommée
j2se
être
version
5.0
porter
nom
j2se
5.0
:
être
à
souligner
version
apporter
mise
à
jour
majeure
par
rapport
à
précédente.
version
actuelle
récente
date
de
décembre
2006
:
c'est
version
6
porter
nom
java
@ord@
version
7
(java
7)
être
annoncer
nouvelle
mise
à
jour
majeure
mais,
à
mi
2010,
être
attendue.
plate-forme
java
délivrer
deux
produit
logiciel
principaux
:
java
runtime
environment
(ou
jre),
fournir
librairies,
machine
java
virtuelle
d'autres
composante
nécessaires
pour
exécuter
programme
java.
java
development
kit
(ou
jdk),
inclure
jre
outil
de
développement,
compilateur
débogueur,
nécessaires
utiles
pour
développer
programme
java.
a
noter
terme
jdk,
populaire,
être
devenir
imprécis
d'autres
plates-formes
java
(java
ee
par
exemple)
comporter
propre
kit
de
développement.
java
platform,
enterprise
edition
(java
ee).
plate-forme
être
framework
java
destiner
application
d'entreprises.
offrir
cadre
standard
pour
développer
application
distribuées.
java
platform,
micro
edition
(java
me).
plate-forme
être
framework
java
spécialiser
dans
application
mobiles.
plates-formes
java
compatibles
avec
j2me
être
embarquer
dans
de
nombreux
téléphone
mobiles
pda.
de
façon
spécifique,
pouvoir
citer
plateformes
java
card
(qui
fournir
environnement
pour
développement
d'applications
sur
carte
à
puce)
javafx
(pour
créer
rich
internet
applications).
17
annexe
7
-
glossaire
trouver
sur
web
d'excellentes
définition
en
anglais
termes,
sigles,
même
produit
de
référence,
informatiques.
parmi
source
possibles,
citer
par
exemple
:
-
parmi
encyclopédie
:
www.wikipedia.org
(la
version
anglaise
être
complète)
-
parmi
moteur
spécialiser
dans
recherche
dans
encyclopédies,
dictionnaire
glossaire
:
www.answers.com
glossaire
de
terme
sigle
généraux
courants
:
sigle
/
terme
définition
commentaire
api
application
programming
bibliothèque
de
fonctionnalité
communes,
interface
courantes
de
bas
niveau.
constituer
interface
entre
couche
basses
couche
applicatives
de
haut
niveau.
exemple
:
java.sun.com/javase/6/docs/api/
spécifier
api
standard
de
java
fournir
dans
jdk
framework
cadre
d'applications
ensemble
cohérent
de
classe
(généralement
abstraites)
d'interfaces
permettre
développement
rapide
d'applications.
fournir
de
brique
logicielles
pour
pouvoir
produire
application
aboutie.
spécialiser
pour
type
d'application.
gui
graphical
user
interface
interface
homme-machine
graphique,
par
opposition
à
interface
en
ligne
de
commande.
ide
integrated
development
programme
regrouper
d'utilitaires
environment
logiciel
pour
développement
de
programme
(éditeur
de
texte,
compilateur,
débogueur,
gestionnaire
de
versions,
aide
à
production
d'interfaces,
...).
dédier
à
seul
langage
de
programmation.
jdk
java
development
kit
(voir
chapitrer
16)
jfc
java
foundation
classer
cadre
d'applications
graphiques.
ensemble
de
classe
java
permettre
de
construire
interface
utilisateur
graphiques
portables.
contenir
composant
swing.
jre
java
runtime
environment
(voir
chapitrer
16)
j2ee
java
2
platform,
enterprise
(voir
chapitrer
16)
edition
java
java
platform,
enterprise
j2me
java
2
platform,
micro
(voir
chapitrer
16)
edition
java
java
platform,
micro
edition
j2se
java
2
platform,
standard
(voir
chapitrer
16)
edition
java
java
platform,
standard
edition
dans
cadre
d'applications
professionnelles
java
distribuer
:
sigle
/
terme
définition
commentaire
ejb
enterprise
javabeans
technologie
java,
offrir
par
plateforme
java
ee,
permettre
de
créer
composant
distribuer
héberger
dans
serveur
d'applications.
dans
architecture
mvc,
utiliser
pour
réaliser
modèle.
java.sun.com/products/ejb/
jsp
java
server
page
technologie
java,
offrir
par
plateforme
java
ee,
permettre
de
créer
page
web
dynamiques.
dans
architecture
mvc,
utiliser
pour
réaliser
vue.
java.sun.com/products/jsp/
servlet
technologie
java,
offrir
par
plateforme
java
ee,
permettre
d'étendre
fonctionnalité
d'un
serveur
web
(accès
à
base
de
données,
transaction
d'e-commerce,
......).
dans
architecture
mvc,
utiliser
pour
réaliser
contrôleur.
java.sun.com/products/servlet/
